<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter 基础控件]]></title>
    <url>%2F2019%2F05%2F14%2Fflutter%2F%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[基础控件Tabbar 控件实现Tabbar 页面是常有需求，而在 Flutter 中：Scaffold、AppBar、Tabbar、TabbarView 是 Tabbar 页面的最简单实现。 下面代码为一个 Tabbar Widget。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class _GSYTabBarState extends State&lt;GSYTabBarWidget&gt; with SingleTickerProviderStateMixin &#123; // ...省略非关键代码 @override void initState() &#123; super.initState(); // 初始化时创建控制器 // 通过 with SingleTickerProviderStateMixin 实现动画效果 _tabController = new TabController(vsync: this, length: _tabItems.length); &#125; @override void dispose() &#123; _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; // 底部 Tabbar 模式 return new Scaffold( // 设置侧边滑出 drawer 不需要可以不设置 drawer: _drawer, // 设置悬浮按键 不需要可以不设置 floatingActionButton: _floatingActionButton, // 标题栏 appBar: new AppBar( backgroundColor: _backgroundColor, title: _title, ), // 页面主体 PageView 用于承载 Tab 对应的页面 body: new PageView( // 必须有的控制器 与 tabBar 的控制器同步 controller: _pageController, // 每一个 tab 对应的页面主体 是一个 List&lt;Widget&gt; children: _tabViews, onPageChanged: (index) &#123; // 页面触摸作用滑动回调 用于同步 tab 选中状态 _tabController.animateTo(index); &#125;, ), // 底部导航栏 也就是 tab 栏 bottomNavigationBar: new Material( color: _backgroundColor, // tabbar 控件 child: new TabBar( // 必须有的控制器 与 pageView 的控制器同步 controller: _tabController, // 每一个 tab item 是一个 List&lt;Widget&gt; tabs: _tabItems, // tab 底部选中条颜色 indicatorColor: _indicatorColor, ), ), ); &#125;&#125; 如上代码所示，这是一个 底部 TabBar 的页面效果。TabBar 和 PageView 之间通过 _pageController 和 _tabController 实现 Tab 和页面的同步，通过 SingleTickerProviderStateMixin 实现 Tab 的动画切换效果： 手动左右滑动 PageView 时，通过 onPageChanged 回调使用 _tabController.animateTo(index); 同步 TabBar 状态。 _tabItems 中，监听每个 TabBarItem 的点击，通过 _pageController 实现 PageView 的状态同步。 而上面代码还缺少了 TabBarItem 的点击，因为这块被放到了外部实现。当然你也可以直接在内部封装好控件，直接传递配置数据显示，这个可以根据个人需要封装。 外部调用代码如下：每个 Tabbar 点击时，通过 pageController.jumpTo 跳转页面，每个页面需要跳转坐标为：当前屏幕大小乘以索引 index。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class _TabBarBottomPageWidgetState extends State&lt;TabBarBottomPageWidget&gt; &#123; final PageController pageController = new PageController(); final List&lt;String&gt; tab = ['动态', '趋势', '我的']; // 渲染底部Tab _renderTab() &#123; List&lt;Widget&gt; list = new List(); for (int i = 0; i &lt; tab.length; i++) &#123; list.add(new FlatButton(onPressed: () &#123; // 每个 Tabbar 点击时，通过jumpTo 跳转页面 // 每个页面需要跳转坐标为：当前屏幕大小 * 索引index。 topPageControl.jumpTo(MediaQuery.of(context).size.width * i); &#125;, child: new Text( tab[i], maxLines: 1, ))); &#125; return list; &#125; // 渲染Tab 对应页面 _renderPage() &#123; return [ new TabBarPageFirst(), new TabBarPageSecond(), new TabBarPageThree(), ]; &#125; @override Widget build(BuildContext context) &#123; // 带 Scaffold 的 Tabbar 页面 return new GSYTabBarWidget( type: GSYTabBarWidget.BOTTOM_TAB, // 渲染tab tabItems: _renderTab(), // 渲染页面 tabViews: _renderPage(), topPageControl: pageController, backgroundColor: Colors.black45, indicatorColor: Colors.white, title: new Text("Flutter Demo")); &#125;&#125; 如果到此结束，你会发现页面点击切换时，StatefulWidget 的子页面每次都会重新调用 initState。这肯定不是我们想要的，所以这时你就需要 AutomaticKeepAliveClientMixin。 每个 Tab 对应的 StatefulWidget 的 State ，需要通过 with AutomaticKeepAliveClientMixin，然后重写 @override bool get wantKeepAlive =&gt; true;，就可以实不重新构建的效果。 既然底部 Tab 页面都实现了，干脆顶部 tab 页面也一起完成。如下代码，和底部 Tab 页的区别在于： 底部 tab 是放在了 Scaffold 的 bottomNavigationBar 中。 顶部 tab 是放在 AppBar 的 bottom 中，也就是标题栏之下。 123456789101112131415161718192021222324252627282930313233return new Scaffold( // 设置侧边滑出 drawer，不需要可以不设置 drawer: _drawer, // 设置悬浮按键，不需要可以不设置 floatingActionButton: _floatingActionButton, // 标题栏 appBar: new AppBar( backgroundColor: _backgroundColor, title: _title, // tabBar控件 bottom: new TabBar( // 顶部时，tabBar为可以滑动的模式 isScrollable: true, // 必须有的控制器，与pageView的控制器同步 controller: _tabController, // 每一个tab item，是一个List&lt;Widget&gt; tabs: _tabItems, // tab底部选中条颜色 indicatorColor: _indicatorColor, ), ), // 页面主体，PageView，用于承载Tab对应的页面 body: new PageView( // 必须有的控制器，与tabBar的控制器同步 controller: _pageController, // 每一个 tab 对应的页面主体，是一个List&lt;Widget&gt; children: _tabViews, // 页面触摸作用滑动回调，用于同步tab选中状态 onPageChanged: (index) &#123; _tabController.animateTo(index); &#125;, ),); 在 TabBar 页面中，一般还会出现：父页面需要控制 PageView 中子页的需求。这时候就需要用到 GlobalKey 了。比如 GlobalKey&lt;PageOneState&gt; stateOne = new GlobalKey&lt;PageOneState&gt;();，通过 globalKey.currentState 对象，你就可以调用到 PageOneState 中的公开方法。这里需要注意 GlobalKey 需要全局唯一，一般可以在 build 方法中创建。 上下刷新列表毫无争议，必备控件。Flutter 中 为我们提供了 RefreshIndicator 作为内置下拉刷新控件；同时我们通过给 ListView 添加 ScrollController 做滑动监听，在最后增加一个 Item， 作为上滑加载更多的 Loading 显示。 如下代码所示，通过 RefreshIndicator 控件可以简单完成下拉刷新工作。这里需要注意一点是：可以利用 GlobalKey&lt;RefreshIndicatorState&gt; 对外提供 RefreshIndicator 的 RefreshIndicatorState，这样外部就 可以通过 GlobalKey 调用 globalKey.currentState.show();，主动显示刷新状态并触发 onRefresh 。 上拉加载更多在代码中是通过 _getListCount() 方法，在原本的数据基础上，增加实际需要渲染的 item 数量给 ListView 实现的，最后通过 ScrollController 监听到底部，触发 onLoadMore。 如下代码所示，通过 _getListCount() 方法，还可以配置空页面，头部等常用效果。其实就是在内部通过改变实际 item 数量与渲染 Item，以实现更多配置效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class _GSYPullLoadWidgetState extends State&lt;GSYPullLoadWidget&gt; &#123; // ··· final ScrollController _scrollController = new ScrollController(); @override void initState() &#123; // 增加滑动监听 _scrollController.addListener(() &#123; // 判断当前滑动位置是不是到达底部，触发加载更多回调 if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) &#123; if (this.onLoadMore != null &amp;&amp; this.control.needLoadMore) &#123; this.onLoadMore(); &#125; &#125; &#125;); super.initState(); &#125; // 根据配置状态返回实际列表数量 // 实际上这里可以根据你的需要做更多的处理 // 比如多个头部，是否需要空页面，是否需要显示加载更多。 _getListCount() &#123; // 是否需要头部 if (control.needHeader) &#123; // 如果需要头部，用Item 0 的 Widget 作为ListView的头部 // 列表数量大于0时，因为头部和底部加载更多选项，需要对列表数据总数+2 return (control.dataList.length &gt; 0) ? control.dataList.length + 2 : control.dataList.length + 1; &#125; else &#123; // 如果不需要头部，在没有数据时，固定返回数量1用于空页面呈现 if (control.dataList.length == 0) &#123; return 1; &#125; // 如果有数据,因为不加载更多选项，需要对列表数据总数+1 return (control.dataList.length &gt; 0) ? control.dataList.length + 1 : control.dataList.length; &#125; &#125; // 根据配置状态返回实际列表渲染Item _getItem(int index) &#123; if (!control.needHeader &amp;&amp; index == control.dataList.length &amp;&amp; control.dataList.length != 0) &#123; // 如果不需要头部，并且数据不为0，当index等于数据长度时，渲染加载更多Item（因为index是从0开始） return _buildProgressIndicator(); &#125; else if (control.needHeader &amp;&amp; index == _getListCount() - 1 &amp;&amp; control.dataList.length != 0) &#123; // 如果需要头部，并且数据不为0，当index等于实际渲染长度 - 1时，渲染加载更多Item（因为index是从0开始） return _buildProgressIndicator(); &#125; else if (!control.needHeader &amp;&amp; control.dataList.length == 0) &#123; // 如果不需要头部，并且数据为0，渲染空页面 return _buildEmpty(); &#125; else &#123; // 回调外部正常渲染Item，如果这里有需要，可以直接返回相对位置的index return itemBuilder(context, index); &#125; &#125; @override Widget build(BuildContext context) &#123; return new RefreshIndicator( // GlobalKey，用户外部获取RefreshIndicator的State，做显示刷新 key: refreshKey, // 下拉刷新触发，返回的是一个Future onRefresh: onRefresh, child: new ListView.builder( // 保持ListView任何情况都能滚动，解决在RefreshIndicator的兼容问题。 physics: const AlwaysScrollableScrollPhysics(), // 根据状态返回子孔健 itemBuilder: (context, index) &#123; return _getItem(index); &#125;, // 根据状态返回数量 itemCount: _getListCount(), // 滑动监听 controller: _scrollController, ), ); &#125; // 空页面 Widget _buildEmpty() &#123; // ··· &#125; // 上拉加载更多 Widget _buildProgressIndicator() &#123; // ··· &#125;&#125; Loading矢量图标库路由跳转数据模块]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 基础]]></title>
    <url>%2F2019%2F05%2F13%2Fflutter%2Fdart%E3%80%81flutter%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Dart 语言下的 flutter基本类型var 可以定义变量，如 var tag = &#39;666&#39;，这和 JavaScript 语言类似，同时 Dart 属于动态类型语言，支持闭包。 Dart 中 number 类型分为 int 和 double，其中 Java 中的 long 对应的也是 Dart 中的 int 类型。Dart 中没有 float 类型。 Dart 下只有 bool 类型可以用于 if 等判断，不同于 JavaScript 这种使用方式是不合法的 var g = &#39;null&#39;; if(g) {};。 Dart 中，switch 支持 String 类型。 变量Dart 不需要给变量设置 setter getter 方法。Dart 中所有的基础类型、类等都继承 Object，默认值是 NULL，自带 getter 和 setter，而如果是 final 或者 const 的话，那么它只有一个 getter 方法。 Dart 中 final 和 const 表示常量，比如 final name = &#39;GSY&#39;; const value = 10000; 同时 static const 组合代表了静态常量。其中 const 的值在编译期确定，final 的值要到运行时才确定。 Dart 下的数值，在作为字符串使用时，是需要显式指定的。比如: int i = 0; print(&#39;111&#39; + i); 这样是不支持的，需要 print(&#39;111&#39; + i.toString()); 这样使用。所以在使用动态类型时，需要注意不要把 number 类型当做 String 使用。 Dart 中数组等于列表，所以 var list = []; 和 List list = new List(); 可以简单看做一样。 方法Dart 下 ??、??= 属于操作符，如：AA ?? &quot;999&quot; 表示如果 AA 为空，返回 999；AA ??= &quot;999&quot; 表示如果 AA 为空，给 AA 设置成 999。 Dart 方法可以设置 参数默认值 和 指定名称。比如：getDetail(String userName, resposeName, {branch = &#39;master&#39;}){} 方法，这里 branch 不设置的话，默认是 “master”。参数类型 可以指定或者不指定。调用效果：getRepositoryDetailDao(&#39;aa&#39;, &#39;bb&#39;, branch: &#39;dev&#39;); Dart 不像 Java，没有关键词 public、private 等修饰符，_ 下划线直接代表 private，但是有 @protected 注解。 Dart 中的构造函数，可以通过如下代码实现的。默认构造方法只能有一个，而通过 Model.empty() 方法可以创建一个空参数的类，其实方法名称随你喜欢。而变量初始化值时，只需要通过 this.name 在构造方法中指定即可： 12345678910111213class ModelA &#123; String name; String tag; // 默认构造方法 赋值给 name 和 tag ModelA(this.name, this,tag); // 返回一个空的 ModelA ModelA.empty(); // 返回一个设置了 name 的 ModelA ModelA.forName(this.name);&#125; FlutterFlutter 中支持 async/await。这一点和 ES7 很像，如下代码所示，只是定义的位置不同。同时异步操作也和 ES6 中的 Promise 很像，只是 Flutter 中返回的是 Future 对象，通过 then 可以执行下一步。如果返回的还是 Future 便可以 then().then() 的流式操作。 12345678910111213141516171819// 模拟等待两秒 返回 okrequest() async &#123; await Future.delayed(Duration(seconds: 1)); return 'ok';&#125;// 得到 'ok' 后 将 'ok' 修改为 'ok from request'doSomeThing() async &#123; String data = await request(); data = 'ok from request'; return data;&#125;// 打印结果renderSome() &#123; doSomeThing().then((value) &#123; print(value); // 输出 'ok from request' &#125;);&#125; Flutter 中一切皆 Widget 呈现，通过 build 方法返回 Widget，这也是和 React Native 中，通过 render 函数返回需要渲染的 component 一样的模式。 Flutter Widget在 Flutter 中，一切的显示都是 Widget。Widget 是一切的基础，作为响应式的渲染，属于 MVVM 的实现机制。我们可以通过修改数据，再用 setState 设置数据，Flutter 会自动通过绑定的数据更新 Widget。所以你需要做的就是实现 Widget 界面，并且和数据绑定起来。 Widget 分为 有状态 和 无状态 两种，在 Flutter 中每个页面都是一帧。无状态就是保持在那一帧。而有状态的 Widget 当数据更新时，其实是绘制了新的 Widget，只是 State 实现了跨帧的数据同步保存。 这里有个小 Tip，当代码框里输入 stl 的时候，可以自动弹出创建&gt; 无状态控件的模板选项，而输入 stf 的时候，就会弹出创建有状 态 Widget 的模板选项。代码格式化的时候，括号内外的逗号都会影响格式化时换行的位置。 无状态 StatelessWidget继承 StatelessWidget，通过 build 方法返回一个布局好的控件。 Widget 和 Widget 之间通过 child 进行嵌套。其中有的 Widget 只能有一个 child，比如下方的 Container；有的 Widget 可以多个 child，也就是 children，比如 Column 布局。 123456789101112131415161718import 'package:flutter/meterial.dart';class DEMOWidget extends StatelessWidget &#123; final String text; // 数据可以通过构造方法传递进去 DEMOWidget(this.text); @override Widget build(BuildContext context) &#123; // 这里返回你需要的控件 // 这里末尾有没有的逗号 对于格式化代码而已 是不一样的 return Container( color: Colors.white, child: Text(text ?? '这就是无状态 demo'), ); &#125;&#125; 有状态 StatefulWidget你需要创建管理的是主要是 State，通过 State 的 build 方法去构建控件。在 State 中，你可以动态改变数据，这类似 MVVM 实现，在 setState 之后，改变的数据会触发 Widget 重新构建刷新。而下方代码中，是通过延两秒之后，让文本显示为 “这就变了数值”。 如下代码还可以看出，State 中主要的声明周期有: initState: 初始化，理论上只有初始化一次。 didChangeDependencies: 在 initState 之后调用，此时可以获取其他 State。‘ dispose: 销毁，只会调用一次。 你需要的就是在 build 中堆积你的布局，然后把数据添加到 Widget 中，最后通过 setStae 改变数据，从而实现画面变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import 'dart:async';import 'package:flutter/material.dart';class DemoStateWidget extends StatefulWidget &#123; final String text; DemoStateWidget(this.text); @override _DemoStateWidgetState createState() =&gt; _DemoStateWidgetState(text);&#125;class _DemoStateWidgetState extends State&lt;DemoStateWidget&gt; &#123; String text; _DemoStateWidgetState(this.text); @override void initState() &#123; super.initState(); new Future.delayed(const Duration(seconds: 1), () &#123; setState(() &#123; text = '这就变了数值'; &#125;); &#125;); &#125; @override void dispose() &#123; super.dispose(); &#125; @override void didChangeDependencies() &#123; super.didChangeDependencies(); &#125; @override Widget build(BuildContext context) &#123; return Container( child: Text(text ?? '这就是有状态 demo'), ); &#125;&#125; Flutter 布局 类型 作用特点 Container 只有一个子 Widget。默认充满，包含了 padding、margin、color、宽高、decoration 等配置。 Padding 只有一个子 Widget。只用于设置 Padding，常用于嵌套 child，给 child 设置 padding。 Center 只有一个子 Widget。只用于居中显示，常用于嵌套 child，给 child 设置居中。 Stack 可以有多个子 Widget。 子 Widget 堆叠在一起。 Column 可以有多个子 Widget。垂直布局。 Row 可以有多个子 Widget。水平布局。 Expanded 只有一个子 Widget。在 Column 和 Row 中充满。 ListView 可以有多个子 Widget。 Container: 最常用的默认布局。只能包含一个 child，支持配置 padding，margin，color，_宽高_，decoration(一般配置边框和阴影)等配置。在 Flutter 中，不是所有的控件都有 _宽高_、padding、margin、color等属性，所以才会有 Padding、 Center 等 Widget 的存在。 1234567891011121314new Container( margin: EdgeInsets.all(10.0), height: 120.0, width: 500.0, decoration: new BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(4.0)), color: Colors.black, border: new Border.all( color: Color(GSYColors.subTextColor), width: 0.3, ), ), child: Text('1111'),); Column、Row 绝对是必备布局，横竖布局也是日常中最常见的场景。如下方所示，它们常用的有这些属性配置：主轴方向是 start 或 center 等；副轴方向是 start 或 center 等；mainAxisSize 是充满最大尺寸，或者只根据子 Widget 显示最小尺寸。 123456// 主轴方向 Column 的竖向 Row 的横向mainAxisAlignment: MainAxisAlignment.start,// 默认是最大充满 还是根据 child 显示最小大小mainAxisSize: MainAxisSize.max,// 副轴方向 Column 的横向 Row 的竖向crossAxisAlignment: CrossAxisAlignment.center, Expanded 在 Column 和 Row 中代表着平均充满，当有两个存在的时候默认均分充满。同时页面可以设置 flex 属性决定比例。 12345678910111213141516171819new Colunm( // 主轴居中 即是竖直向居中 mainAxisAlignment: MainAxisAlignment.center, // 大小按照最小显示 mainAxisSize: MainAxisSize.min, // 横向也居中 crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ // flex 默认为 1 new Expanded( child: new Text('111', flex: 2, ), ), new Expanded( child: new Text('222'), ), ],); 接下来我们来写一个复杂一些的控件。首先我们创建一个私有方法 _getBottomItem，返回一个 Expanded Widget，因为后面我们需要将这个方法返回的 Widget 在 Row 下平均充满。 如代码中注释，布局内主要是现实一个居中的 Icon 图标和文本，中间间隔 5.0 的 padding : 123456789101112131415161718192021222324252627282930313233_getBottomItem(IconData icon, String text) &#123; return new Expanded( flex: 1, child: new Center( child: new Row( mainAxisAlignment: MainAxisAlignment.center, mainAxisSize : MainAxisSize.max, crossAxisAlignment : CrossAxisAlignment.center, children: &lt;Widget&gt;[ new Icon( icon, size: 16.0, color: Colors.grey, ), new Padding( padding: new EdgeInsets.only( left: 5.0, ), ), new Text( text, style: new TextStyle( color: Colors.grey, fontSize: 14.0, ), overflow: TextOverflow.ellipsis, maxLines: 1, ), ], ), ), );&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@overrideWidget build(BuildContext context) &#123; return new Container( child: new Card( child: new FlatButton( onPressed: () &#123; print('点击事件'); &#125;, child: new Padding( padding: new EdgeInsets.only( left: 0.0, top: 10.0, right: 10.0, bottom: 10.0, ), child: new Column( mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ new Container( child: new Text( '这是一点描述', style: TextStyle( color: Color(GSYColors.subTextColor), fontSize: 14.0, ), maxLines: 3, overflow: TextOverflow.ellipsis, ), margin: new EdgeInsets.only( top: 6.0, bottom: 2.0, ), alignment: Alignment.topLeft, ), new Padding( padding: EdgeInsets.all(10.0), ), new Row( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ _getBottomItem(Icons.star, '1000'), _getBottomItem(Icons.link, '1000'), _getBottomItem(Icons.subject, '1000'), ], ), ], ), ), ), ), );&#125; Flutter 页面 类型 作用特点 MaterialApp 一般作为 APP 顶层的主页入口，可配置主题，多语言，路由等 Scaffold 一般用户页面的承载 Widget，包含 appbar、snackbar、drawer 等 material design 的设定。 Appbar 一般用于 Scaffold 的 appbar ，内有标题，二级页面返回按键等，当然不止这些，tabbar 等也会需要它 。 Text 显示文本，几乎都会用到，主要是通过 style 设置 TextStyle 来设置字体样式等。 RichText 富文本，通过设置 TextSpan，可以拼接出富文本场景。 TextField 文本输入框 ：new TextField(controller: //文本控制器, obscureText: &quot;hint 文本&quot;); Image 图片加载: new FadeInImage.assetNetwork( placeholder: &quot;预览图&quot;, fit: BoxFit.fitWidth, image: &quot;url&quot;); FlatButton 按键点击: new FlatButton(onPressed: () {},child: new Container()); 1234567891011121314151617181920212223242526272829303132import 'package:flutter/material.dart';import 'package:gsy_github_app_flutter/test/DemoItem.dart';class DemoPage extends StatefulWidget &#123; @override _DemoPageState createState() =&gt; _DemoPageState();&#125;class _DemoPageState extends State&lt;DemoPage&gt; &#123; @override Widget build(BuildContext context) &#123; ///一个页面的开始 ///如果是新页面，会自带返回按键 return new Scaffold( ///背景样式 backgroundColor: Colors.blue, ///标题栏，当然不仅仅是标题栏 appBar: new AppBar( ///这个title是一个Widget title: new Text("Title"), ), ///正式的页面开始 ///一个ListView，20个Item body: new ListView.builder( itemBuilder: (context, index) &#123; return new DemoItem(); &#125;, itemCount: 20, ), ); &#125;&#125; 123456789101112131415import 'package:flutter/material.dart';import 'package:gsy_github_app_flutter/test/DemoPage.dart';void main() &#123; runApp(new DemoApp());&#125;class DemoApp extends StatelessWidget &#123; DemoApp(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return new MaterialApp(home: DemoPage()); &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的 this、call 和 apply]]></title>
    <url>%2F2019%2F05%2F09%2Fjavascript%2Fthis%E3%80%81call%E5%92%8Capply%2F</url>
    <content type="text"><![CDATA[thisJavaScript 的 this 指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this 的指向this 的指向大致可以分为以下 4 种。 作为对象的方法调用 作为普通函数调用 构造器调用 Function.prototype.call 或 Function.prototype.apply 调用 作为对象的方法调用当函数作为对象的方法被调用时，this 指向该对象。 12345678var obj = &#123; a: 1, getA: function() &#123; alert(this === obj); // 输出 true alert(this.a); // 输出 1 &#125;&#125;;obj.getA(); 作为普通函数调用当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。 1234567891011121314151617181920window.name = 'globalName';var getName = function() &#123; return this.name;&#125;;console.log(getName()); // 输出 golbalName// 或者：window.name = 'globalName';var myObject = &#123; name: 'sven', getName: function() &#123; return this.name; &#125;&#125;;var getName = myObject.getName;console.log(getName()); // globalName 有时候我们会遇到一些困扰，比如在 div 节点的事件函数内部，有一个局部的 callback 方法， callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往是想让它指向该 div 节点，见如下代码: 12345678910111213141516&lt;html&gt; &lt;body&gt; &lt;div id="div1"&gt;我是一个div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; window.id = 'window'; document.getElementById('div1').onclick = function() &#123; alert(this.id); // 输出 div1 var callback = function() &#123; alert(this.id); // 输出 window &#125;; callback(); &#125;; &lt;/script&gt;&lt;/html&gt; 此时有一种简单的解决方案，可以用一个变量保存 div 节点的引用: 1234567document.getElementById('div1').onclick = function() &#123; var that = this; var callback = function() &#123; alert(that.id); // 输出 div1 &#125;; callback();&#125;; 在 ES6 的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined ： 12345function func() &#123; 'use strict'; alert(this); // 输出 undefined&#125;func(); 构造器调用JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。 除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码: 123456var MyClass = function() &#123; this.name = 'sevn';&#125;;var obj = new MyClass();alert(obj.name); // sevn 但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this : 123456789var MyClass = function() &#123; this.name = 'sevn'; return &#123; name: 'lili' &#125;;&#125;;var obj = new MyClass();alert(obj.name); // lili 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题: 12345678910var MyClass = function() &#123; this.name = 'sevn'; this.getName = function() &#123; return this.name; &#125;; return 'lili'; // 返回其他类型的数据 string&#125;;var obj = new MyClass();alert(obj.name); // sevn Function.prototype.call 或 Function.prototype.apply 调用跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this : 1234567891011121314var obj1 = &#123; name: 'sevn', getName: function() &#123; return this.name; &#125;&#125;;var obj2 = &#123; name: 'lili'&#125;;console.log(obj1.getName()); // sevnconsole.log(obj1.getName.call(obj2)); // liliconsole.log(obj1.getName.apply(obj2)); // lili call 和 apply 方法能很好地体现 JavaScript 的函数式语言特性，在 JavaScript 中，几乎第一次编写函数式语言风格的代码，都离不开 call 和 apply 。在 JavaScript 诸多版本的设计模式中，也用到了 call 和 apply 。 丢失的 this这是一个经常遇到的问题，我们来看下面的代码: 1234567891011var obj = &#123; myName: 'lili', getName: function() &#123; return this.myName; &#125;&#125;;console.log(obj.getName()); // lilivar getName2 = obj.getName;console.log(getName2()); // undefined 当调用 obj.getName 时，getName 方法是作为 obj 对象的属性被调用的，此时的 this 指向 obj 对象，所以 obj.getName() 输出 lili 。 当用另外一个变量 getName2 来引用 obj.getName，并且调用 getName2 时，此时是普通函数调用方式，this 是指向全局 window 的，所以程序的执行结果是 undefined。 再看另一个例子，document.getElementById 这个方法名实在有点过长，我们大概尝试过用一个短的函数来代替它: 12345var getId = function(id) &#123; return document.getElementById(id);&#125;;getId('div1'); 我们也许思考过为什么不能用下面这种更简单的方式: 12var getId = document.getElementById;getId('div1'); 现在不妨花 1 分钟时间，让这段代码在浏览器中运行一次: 123456789&lt;html&gt; &lt;body&gt; &lt;div id="div1"&gt;我是一个 div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; var getId = document.getElementById; getId('div1'); &lt;/script&gt;&lt;/html&gt; 在浏览器中执行过后就会发现，这段代码抛出了一个异常。这是因为许多引擎的 document.getElementById 方法的内部实现中需要用到 this 。这个 this 本来被期望指向 document，当 getElementById 方法作为 document 对象的属性被调用时，方法内部的 this 确实是指向 document 的。 但当用 getId 来引用 document.getElementById 之后，再调用 getId，此时就成了普通函数调用，函数内部的 this 指向了 window，而不是原来的 document。 我们可以尝试利用 apply 把 document 当作 this 传入 getId 函数，帮助”修正” this : 12345678910document.getELementById = (function(func) &#123; return function() &#123; return func.apply(document, arguments); &#125;;&#125;)(document.getElementById);var getId = document.getElementById;var div = getId('div1');alert(div.id); // div1 call 和 applyECMAScript 3 给 Function 的原型定义了两个方法，它们是 Function.prototype.call 和 Function.prototype.apply。在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤为有用。在 JavaScript 版本的设计模式中，这两个方法的应用也非常广泛，能熟练运用这两个方法，是我们真正成为一句 JavaScript 程序员的重要一步。 call 和 apply 的区别Function.prototype.call 和 Function.prototype.apply 都是非常常用的方法。它们的作用是一样的，区别仅在于传入参数形式的不同。 apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数: 12345var func = function(a, b, c) &#123; alert([a, b, c]); // [1, 2, 3]&#125;;func.apply(null, [1, 2, 3]); 在这段代码中，参数 1，2，3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列表中的 a、b、c。 call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。 12345var func = function(a, b, c) &#123; alert([a, b, c]); // [1, 2, 3]&#125;;func.call(null, 1, 2, 3); 当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript 的参数在内部就是用一个数组来表示的。从这个意义上说，apply 比 call 的使用率更高，我们不必关心具体有多少参数被传入函数，只要用 apply 一股脑地推过去就可以了。 call 是包装在 apply 上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call 来传送参数。 当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window : 12345var func = function(a, b, c) &#123; alert(this === window); // 输出 true&#125;;func.apply(null, [1, 2, 3]); 但如果是在严格格式下，函数体内的 this 还是为 null : 123456var func = function(a, b, c) &#123; 'use strict'; alert(this === null); // 输出 true&#125;;func.apply(null, [1, 2, 3]); 我们有时候使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象: 1Math.max.apply(null, [1, 2, 3, 4, 5]); // 输出 5 call 和 apply 的用途能够熟练使用 call 和 apply，是我们真正成为一名 JavaScript 程序员的重要一步。 改变 this 指向call 和 apply 最常见的用途是改变函数内部的 this 指向，我们来看个例子： 1234567891011121314151617var obj1 = &#123; name: 'sevn'&#125;;var obj2 = &#123; name: 'lili'&#125;;window.name = 'window';var getName = function() &#123; alert(this.name);&#125;;getName(); // 输出 windowgetName.call(obj1); // 输出 sevngetName.call(obj2); // 输出 lili 当执行 getName.call(obj1) 这句代码时，getName 函数体内的 this 就指向 obj2 对象，所以此处的 123var getName = function() &#123; alert(this.name);&#125;; 实际相当于: 123var getName = function() &#123; alert(obj1.name);&#125;; 在实际开发中，经常会遇到 this 指向被不经意改变的场景，比如有一个 div 节点， div 节点的 onclick 事件中的 this 本来是指向这个 div 的: 123document.getElementById('div1').onclick = function() &#123; alert(this.id);&#125;; 假如该事件函数中有一个内部函数 func，在事件内部调用 func 函数时，func 函数体内的 this 就指向了 window，而不是我们预期的 div，见如下代码: 123456789document.getElementById('div1').onclick = function() &#123; alert(this.id); // 输出 div1 var func = function() &#123; alert(this.id); // 输出 undefined &#125;; func();&#125;; 这时候我们用 call 来修正 func 函数内的 this，使其依然指向 div: 1234567document.getElementById('div1').onclick = function() &#123; var func = function() &#123; alert(this.id); // 输出 div1 &#125;; func.call(this);&#125;; 使用 call 来修正 this 的场景，我们并非第一次遇到，我们曾经修正过 document.getElementById 函数内部 “丢失” 的 this，代码如下: 123456789document.getElementById = (function(func) &#123; return function() &#123; return func.apply(document, arguments); &#125;;&#125;)(document.getElementById);var getId = document.getElementById;var div = getId('div1');alert(div.id); // 输出 div1 Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向，即使没有原生的 Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下: 1234567891011121314151617Function.prototype.bind = function(context) &#123; var self = this; // 保存原函数 return function() &#123; // 返回一个新的函数 return self.apply(context, arguments); // 执行新的函数的时候 会把之前传入的 context 当作新函数体内的 this &#125;;&#125;;var obj = &#123; name: 'lili'&#125;;var func = function() &#123; alert(this.name); // 输出 lili&#125;.bind(obj);func(); 我们通过 Function.prototype.bind 来 “包装” func 函数，并且传入一个对象 context 当作参数，这个 context 对象就是我们想修正的 this 对象。 在 Function.prototype.bind 的内部实现中，我们先把 func 函数的引用保存起来，然后返回一个新的函数。当我们在将来执行 func 函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，self.apply(context, arguments) 这句代码才是执行原来的 func 函数，并且指定 context 对象为 func 函数体内的 this。 这是一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一点，使得可以往 func 函数中预先填入一些参数: 1234567891011121314151617181920212223Function.prototype.bind = function() &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 需要绑定的 this 上下文 args = [].slice.call(arguments); // 剩余的参数转成数组 return function() &#123; // 返回一个新的函数 return self.apply(context, [].concat.call(args, [].slice.call(arguments))); // 执行新的函数的时候 会把之前传入的 context 当作新函数体内的 this // 并且组合两次分别传入的参数 作为新函数的参数 &#125;;&#125;;var obj = &#123; name: 'lili'&#125;;var func = function(a, b, c, d) &#123; alert(this.name); // 输出 lili alert([a, b, c, d]); // 输出 [1, 2, 3, 4]&#125;.bind(obj, 1, 2);func(3, 4); 借用其他对象的方法在 JavaScript 中也存在类似的借用对象。 借用方法的第一种场景是”借用构造函数”，通过这种技术，可以实现一些类似继承的效果: 1234567891011121314var A = function(name) &#123; this.name = name;&#125;;var B = function() &#123; A.apply(this, arguments);&#125;;B.prototype.getName = function() &#123; return this.name;&#125;;var b = new B('lili');console.log(b.getName()); // 输出 lili 借用方法的第二种运用场景跟我们的关系更加密切。 函数的参数列表 arguments 是一个类数组对象，虽然它也有”下标”，但它并非真正的数组，所以也不能像数组一样，进行排序或者往集合里添加一个新的元素。在这种情况下，我们常常常常会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用 Array.prototype.push : 1234(function() &#123; Array.prototype.push.call(arguments, 3); console.log(arguments); // 输出 [1 2 3]&#125;)(1, 2);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>this, call, apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb 常用语法教程]]></title>
    <url>%2F2019%2F04%2F17%2Fmongodb%2Fmongodb%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[创建数据库MongoDB use DATABASE_NAME 用于创建数据库。该命令如果数据库不存在，将创建一个新的数据库， 否则将返回现有的数据库。 语法use DATABASE语句的基本语法如下： 1use DATABASE_NAME 例子：如果想创建一个数据库名称为 \， 那么 use DATABASE 语句应该如下： 12&gt;use mydbswitched to db mydb 要检查当前选择的数据库使用命令 db 12&gt;dbmydb 如果想查询数据库列表，那么使用命令 show dbs. 123&gt;show dbslocal 0.78125GBtest 0.23012GB 所创建的数据库（mydb）不存在于列表中。要显示的数据库，需要至少插入一个文档进去。 12345&gt;db.movie.insert(&#123;"name":"yiibai tutorials"&#125;)&gt;show dbslocal 0.78125GBmydb 0.23012GBtest 0.23012GB MongoDB的默认数据库是test。 如果没有创建任何数据库，那么集合将被保存在测试数据库。 删除数据库MongoDB db.dropDatabase() 命令用于删除现有的数据库。 语法dropDatabase()指令的基本语法如下： 1db.dropDatabase() 这将删除选定的数据库。如果没有选择任何数据库，那么它会删除默认的“test”数据库 例子：如果想删除新的数据库 \, 那么 dropDatabase() 命令将如下所示： 12345&gt;use mydbswitched to db mydb&gt;db.dropDatabase()&gt;&#123; "dropped" : "mydb", "ok" : 1 &#125;&gt; 创建集合MongoDB 的 db.createCollection(name, options) 用于创建集合。 在命令中, name 是要创建集合的名称。 Options 是一个文档，用于指定集合的配置 参数 类型 描述 Name String 要创建的集合的名称 OPtions Document （可选）指定有关内存大小和索引选项 选项参数是可选的，所以需要指定集合的唯一名字。 语法createCollection()方法的基本语法如下 12345&gt;use testswitched to db test&gt;db.createCollection("mycollection")&#123; "ok" : 1 &#125;&gt; 可以通过使用 show collections 命令来检查创建的集合 123&gt;show collectionsmycollectionsystem.indexes 选项列表 字段 类型 描述 capped Boolean （可选）如果为true，它启用上限集合。上限集合是一个固定大小的集合，当它达到其最大尺寸会自动覆盖最老的条目。 如果指定true，则还需要指定参数的大小。 autoIndexID Boolean （可选）如果为true，自动创建索引_id字段。默认的值是 false. size number （可选）指定的上限集合字节的最大尺寸。如果capped 是true，那么还需要指定这个字段。 max number （可选）指定上限集合允许的最大文件数。 尽管插入文档，MongoDB首先检查字段集合的上限大小，那么它会检查最大字段。 语法:123&gt;db.createCollection("mycol", &#123; capped : true, autoIndexID : true, size : 6142800, max : 10000 &#125; )&#123; "ok" : 1 &#125;&gt; 在MongoDB中并不需要创建集合。 当插入一些文档 MongoDB 会自动创建集合。 1234567&gt;db.yiibai.insert(&#123;"name" : "yiibai"&#125;)&gt;show collectionsmycolmycollectionsystem.indexesyiibai&gt; 删除集合MongoDB 的 db.collection.drop() 用于从数据库中删除集合。 语法drop() 命令的基本语法如下 12345678910111213db.COLLECTION_NAME.drop()``` ##### 例子下面给出的例子将删除给定名称的集合：**mycollection**``` javascript&gt;use mydbswitched to db mydb&gt;db.mycollection.drop()true&gt; 插入文档将数据插入到MongoDB集合，需要使用MongoDB 的 insert() 方法。 语法insert()命令的基本语法如下： 1&gt;db.COLLECTION_NAME.insert(document) 例子123456789&gt;db.mycol.insert(&#123; _id: ObjectId(7df78ad8902c), title: 'MongoDB Overview', description: 'MongoDB is no sql database', by: 'yiibai tutorials', url: 'http://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100&#125;) 这里 mycol 是我们的集合名称，它是在之前的教程中创建。如果集合不存在于数据库中，那么MongoDB创建此集合，然后插入文档进去。 在如果我们不指定_id参数插入的文档，那么 MongoDB 将为文档分配一个唯一的ObjectId。 _id 是12个字节十六进制数在一个集合的每个文档是唯一的。 12个字节被划分如下： 1_id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer) 要以单个查询插入多个文档，可以通过文档 insert() 命令的数组方式。 例子1234567891011121314151617181920212223242526&gt;db.post.insert([&#123; title: 'MongoDB Overview', description: 'MongoDB is no sql database', by: 'yiibai tutorials', url: 'http://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100&#125;,&#123; title: 'NoSQL Database', description: 'NoSQL database doesn't have tables', by: 'yiibai tutorials', url: 'http://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 20, comments: [ &#123; user:'user1', message: 'My first comment', dateCreated: new Date(2013,11,10,2,35), like: 0 &#125; ]&#125;]) 查询文档要从集合查询MongoDB数据，需要使用MongoDB的 find()方法。 语法find()方法的基本语法如下 1&gt;db.COLLECTION_NAME.find() find() 方法将在非结构化的方式显示所有的文件。 如果显示结果是格式化的，那么可以用pretty() 方法。 语法1&gt;db.mycol.find().pretty() 例子1234567891011&gt;db.mycol.find().pretty()&#123; "_id": ObjectId(7df78ad8902c), "title": "MongoDB Overview", "description": "MongoDB is no sql database", "by": "yiibai tutorials", "url": "http://www.yiibai.com", "tags": ["mongodb", "database", "NoSQL"], "likes": "100"&#125;&gt; 除了find()方法还有findOne()方法，仅返回一个文档。 RDBMS Where子句等效于MongoDB查询文档在一些条件的基础上，可以使用下面的操作 操作 语法 示例 RDBMS等效语句 Equality {:} db.mycol.find({“by”:”yiibai tutorials”}).pretty() where by 等于 ‘yiibai tutorials’ Less Than :{$lt:}} db.mycol.find({“likes”:{$lt:50}}).pretty() where likes 小于 50 Less Than Equals {:{$lte:}} db.mycol.find({“likes”:{$lte:50}}).pretty() where likes 小于等于 50 Greater Than {:{$gt:}} db.mycol.find({“likes”:{$gt:50}}).pretty() where likes 大于 50 Greater Than Equals {:{$gte:}} db.mycol.find({“likes”:{$gte:50}}).pretty() where likes 大于等于 50 Not Equals {:{$ne:}} db.mycol.find({“likes”:{$ne:50}}).pretty() where likes 不等于 50 AND 在 MongoDB语法在 find()方法，如果您传递多个键通过”,”将它们分开，那么MongoDB对待它就如AND条件一样。基本语法如下所示： 1&gt;db.mycol.find(&#123;key1:value1, key2:value2&#125;).pretty() 例子下面给出的例子将显示所有教程含“yiibai tutorials”和其标题是“MongoDB Overview” 1234567891011&gt;db.mycol.find(&#123;"by":"yiibai tutorials","title": "MongoDB Overview"&#125;).pretty()&#123; "_id": ObjectId(7df78ad8902c), "title": "MongoDB Overview", "description": "MongoDB is no sql database", "by": "yiibai tutorials", "url": "http://www.yiibai.com", "tags": ["mongodb", "database", "NoSQL"], "likes": "100"&#125;&gt; 对于上面给出的例子相当于where子句：’ where by=’yiibai tutorials’ AND title=’MongoDB Overview’ ‘。可以传递任何数目的键-值对在find子句。 OR 在 MongoDB语法要查询基于OR条件的文件，需要使用$or关键字。OR的基本语法如下所示： 1234567&gt;db.mycol.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() 例子下面给出的例子将显示所有撰写含有 ‘yiibai tutorials’ 或是标题为 ‘MongoDB Overview’ 的教程 1234567891011&gt;db.mycol.find(&#123;$or:[&#123;"by":"tutorials point"&#125;,&#123;"title": "MongoDB Overview"&#125;]&#125;).pretty()&#123; "_id": ObjectId(7df78ad8902c), "title": "MongoDB Overview", "description": "MongoDB is no sql database", "by": "yiibai tutorials", "url": "http://www.yiibai.com", "tags": ["mongodb", "database", "NoSQL"], "likes": "100"&#125;&gt; 使用 AND 和 OR 在一起例子下面给出的例子显示有喜欢数大于100 的文档，其标题要么是 ‘MongoDB Overview’ 或 ‘yiibai tutorials’. 等效于SQL的where子句：‘where likes&gt;10 AND (by = ‘yiibai tutorials’ OR title = ‘MongoDB Overview’)’ 1234567891011&gt;db.mycol.find("likes": &#123;$gt:10&#125;, $or: [&#123;"by": "yiibai tutorials"&#125;, &#123;"title": "MongoDB Overview"&#125;] &#125;).pretty()&#123; "_id": ObjectId(7df78ad8902c), "title": "MongoDB Overview", "description": "MongoDB is no sql database", "by": "yiibai tutorials", "url": "http://www.yiibai.com", "tags": ["mongodb", "database", "NoSQL"], "likes": "100"&#125;&gt; 更新文档MongoDB的update()和save()方法用于更新文档到一个集合。 update()方法将现有的文档中的值更新，而save()方法使用传递到save()方法的文档替换现有的文档。 MongoDB Update() 方法语法update()方法的基本语法如下 1&gt;db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA) 例子考虑mycol集合有如下数据。 123&#123; "_id" : ObjectId(5983548781331adf45ec5), "title":"MongoDB Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Yiibai Overview"&#125; 下面的例子将设置其标题“MongoDB Overview”的文件为新标题为“New MongoDB Tutorial” 123456&gt;db.mycol.update(&#123;'title':'MongoDB Overview'&#125;,&#123;$set:&#123;'title':'New MongoDB Tutorial'&#125;&#125;)&gt;db.mycol.find()&#123; "_id" : ObjectId(5983548781331adf45ec5), "title":"New MongoDB Tutorial"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Tutorial Overview"&#125;&gt; 默认情况下，MongoDB将只更新单一文件，更新多，需要一个参数 ‘multi’ 设置为 true。 1&gt;db.mycol.update(&#123;'title':'MongoDB Overview'&#125;,&#123;$set:&#123;'title':'New MongoDB Tutorial'&#125;&#125;,&#123;multi:true&#125;) MongoDB Save() 方法save() 方法取代，通过新文档到 save()方法 语法mongodb 的 save()方法如下所示的基本语法： 1&gt;db.COLLECTION_NAME.save(&#123;_id:ObjectId(),NEW_DATA&#125;) 例子下面的例子将替换该文件_id ‘5983548781331adf45ec7’ 12345678910&gt;db.mycol.save( &#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Yiibai New Topic", "by":"Yiibai Yiibai" &#125;)&gt;db.mycol.find()&#123; "_id" : ObjectId(5983548781331adf45ec5), "title":"Yiibai Yiibai New Topic", "by":"Yiibai Yiibai"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Yiibai Overview"&#125;&gt; 删除文档MongoDB 的 remove()方法用于从集合中删除文档。remove()方法接受两个参数。一个是标准缺失，第二是justOne标志 deletion criteria : 根据文件（可选）删除条件将被删除。 justOne : （可选）如果设置为true或1，然后取出只有一个文档。 语法remove()方法的基本语法如下 1&gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA) 例子考虑mycol集合有如下数据。 123&#123; "_id" : ObjectId(5983548781331adf45ec5), "title":"MongoDB Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Yiibai Overview"&#125; 下面的例子将删除所有的文件，其标题为 ‘MongoDB Overview’ 12345&gt;db.mycol.remove(&#123;'title':'MongoDB Overview'&#125;)&gt;db.mycol.find()&#123; "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Toturials Overview"&#125;&gt; 只删除一个如果有多个记录，并要删除仅第一条记录，然后在 remove()方法设置参数 justOne 。 1&gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1) 删除所有文件如果没有指定删除条件，则MongoDB将从集合中删除整个文件。这相当于SQL的 truncate 命令。 123&gt;db.mycol.remove()&gt;db.mycol.find()&gt; MongoDB投影mongodb投影意义是只选择需要的数据，而不是选择整个一个文档的数据。如果一个文档有5个字段，只需要显示3个，只从中选择3个字段。 MongoDB的find()方法，解释了MongoDB中查询文档接收的第二个可选的参数是要检索的字段列表。在MongoDB中，当执行find()方法，那么它会显示一个文档的所有字段。要限制这一点，需要设置字段列表值为1或0。1是用来显示字段，而0被用来隐藏字段。 语法find()方法的基本语法如下 1&gt;db.COLLECTION_NAME.find(&#123;&#125;,&#123;KEY:1&#125;) 例子考虑集合 myycol 有下列数据 123&#123; "_id" : ObjectId(5983548781331adf45ec5), "title":"MongoDB Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Yiibai Overview"&#125; 下面的例子将显示文档的标题，在查询文档时。 12345&gt;db.mycol.find(&#123;&#125;,&#123;"title":1,_id:0&#125;)&#123;"title":"MongoDB Overview"&#125;&#123;"title":"NoSQL Overview"&#125;&#123;"title":"Yiibai Yiibai Overview"&#125;&gt; 请注意在执行find()方法时_id字段始终显示，如果不想要显示这个字段，那么需要将其设置为0 限制文档MongoDB Limit() 方法要在MongoDB中限制记录，需要使用limit()方法。 limit() 方法接受一个数字类型的参数，这是要显示的文档数量。 语法limit()方法的基本语法如下 1&gt;db.COLLECTION_NAME.find().limit(NUMBER) 例子考虑集合 myycol 有下列数据 123&#123; "_id" : ObjectId(5983548781331adf45ec5), "title":"MongoDB Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Yiibai Overview"&#125; 下面的例子将只显示2个文档，在查询文档时。 1234&gt;db.mycol.find(&#123;&#125;,&#123;"title":1,_id:0&#125;).limit(2)&#123;"title":"MongoDB Overview"&#125;&#123;"title":"NoSQL Overview"&#125;&gt; 如果不指定 limit() 方法的参数数量，然后它会显示集合中的所有文档。 MongoDB Skip() 方法除了 limit() 方法还有一个方法 skip() 也接受数字类型参数并用于跳过文件数。 语法skip() 方法的基础语法如下所示： 1&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 例子下面的例子将仅显示第二个文档。 123&gt;db.mycol.find(&#123;&#125;,&#123;"title":1,_id:0&#125;).limit(1).skip(1)&#123;"title":"NoSQL Overview"&#125;&gt; 请注意，skip() 方法的默认值是 0 文档排序要排序MongoDB中的文档，需要使用 sort()方法。 sort() 方法接受一个包含字段列表以及排序顺序的文档。 要使用1和-1指定排序顺序。1用于升序，而-1是用于降序。 语法sort()方法的基本语法如下 1&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;) 例子考虑集合 myycol 有如下数据 123&#123; "_id" : ObjectId(5983548781331adf45ec5), "title":"MongoDB Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec6), "title":"NoSQL Overview"&#125;&#123; "_id" : ObjectId(5983548781331adf45ec7), "title":"Yiibai Yiibai Overview"&#125; 下面的例子将显示的文件排序按标题降序排序。 12345&gt;db.mycol.find(&#123;&#125;,&#123;"title":1,_id:0&#125;).sort(&#123;"title":-1&#125;)&#123;"title":"Yiibai Yiibai Overview"&#125;&#123;"title":"NoSQL Overview"&#125;&#123;"title":"MongoDB Overview"&#125;&gt; 请注意，如果不指定排序类型，那么 sort() 方法将以升序排列文档。 MongoDB索引索引支持查询高效率执行。如果没有索引，MongoDB必须扫描集合中的每一个文档，然后选择那些符合查询语句的文档。若需要 mongod 来处理大量数据，扫描是非常低效的。 索引是特殊的数据结构，存储在一个易于设置遍历形式的数据的一小部分。索引存储在索引中指定特定字段的值或一组字段，并排序字段的值。 要创建索引，需要使用MongoDB的ensureIndex()方法。 语法ensureIndex()方法的基本语法如下 1&gt;db.COLLECTION_NAME.ensureIndex(&#123;KEY:1&#125;) 这里键是要创建索引字段，1是按名称升序排序。若以按降序创建索引，需要使用 -1. 例子12&gt;db.mycol.ensureIndex(&#123;"title":1&#125;)&gt; 在 ensureIndex()方法，可以通过多个字段，来创建多个字段索引。 12&gt;db.mycol.ensureIndex(&#123;"title":1,"description":-1&#125;)&gt; ensureIndex() 方法还接受选项列表（这是可选），其列表如下： 参数 类型 描述 background Boolean 构建索引在后台以便建立索引不阻止其它数据库活动。指定true时建立在后台。缺省值是false. unique Boolean 创建一个唯一的索引，以使集合将不接受插入的的文档，其中的索引关键字或键匹配索引的现有值。指定true以创建唯一索引。缺省值是 false. name string 索引的名称。如果未指定，MongoDB通过连接索引的字段和排序顺序的名称生成一个索引名。 dropDups Boolean 创建一个字段唯一索引时可能会有重复。MongoDB索引键仅第一次出现，并从集合中删除包含该键后续出现的所有文档。指定true以创建唯一索引。缺省值是 false. sparse Boolean 如果为true，索引只引用与指定的字段的文档。这些索引使用更少的空间，但在某些情况下表现不同（特别是排序）。缺省值是 false. expireAfterSeconds integer 指定的值，以秒为单位，作为一个TTL控制MongoDB保留在此集合文件多久。 v index version 索引版本号。默认的索引版本取决于mongod创建索引时运行的版本。 weights document 重量（weight ）是一个数字，它是从1至99,999的数字，表示字段相对于其它索引字段在得分方面的意义。 default_language string 对于文本索引，并为词干分析器和标记生成器列表中的语言决定了停用词和规则。它的默认值： english. language_override string 对于一个文本索引，包含在文档中指定字段的名称，语言来覆盖默认语言。它的默认值：language. MongoDB 聚合聚合操作处理数据记录并返回计算结果。从多个文档聚合分组操作数值，并可以执行多种对分组数据业务返回一个结果。 在SQL中的count(*)，使用group by 与mongodb的聚合是等效的。 对于MongoDB的聚合，使用的是aggregate()方法。 语法aggregate()方法的基本语法如下 1&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) 例子在集合中有以下数据： 123456789101112131415161718192021222324252627&#123; _id: ObjectId(7df78ad8902c) title: 'MongoDB Overview', description: 'MongoDB is no sql database', by_user: 'Yiibai Yiibai ', url: 'http://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100&#125;,&#123; _id: ObjectId(7df78ad8902d) title: 'NoSQL Overview', description: 'No sql database is very fast', by_user: 'Yiibai Yiibai', url: 'http://www.yiibai.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 10&#125;,&#123; _id: ObjectId(7df78ad8902e) title: 'Neo4j Overview', description: 'Neo4j is no sql database', by_user: 'Neo4j', url: 'http://www.neo4j.com', tags: ['neo4j', 'database', 'NoSQL'], likes: 750&#125; 现在从上面的集合，如果想知道每一个用户编写的教程是多少，那么使用aggregate()方法，如下图所示的列表： 123456789101112131415&gt; db.mycol.aggregate([&#123;$group : &#123;_id : "$by_user", num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])&#123; "result" : [ &#123; "_id" : "Yiibai Yiibai", "num_tutorial" : 2 &#125;, &#123; "_id" : "Neo4j", "num_tutorial" : 1 &#125; ], "ok" : 1&#125;&gt; 用于上述用途将等效于sql查询： select by_user, count(*) from mycol group by by_user 另外，在上述例子中，我们已经使用字段by_user进行分组并计算总和，也就是by_user 出现各个次数。一个列表中可用的聚集表达式。 表达式 描述 示例 $sum 从集合累加所有文档中的定义值 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}]) $avg 从集合中的所有文档计算所有给定值的平均值 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}]) $min 从集合中获取的所有文件的最小的相应值 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}]) $max 从集合中的所有文档中的相应值中获取最大值 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}]) $push 插入数组值到文档中 db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}]) $addToSet 插入值所产生的数组到文档中，但不会产生重复 db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}]) $first 从源文件获取根据分组的头文件。通常，这使得只能意会再加上一些以前应用“$sort” -stage db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}]) $last 从源文件获取根据分组的最后文件。通常，这使得只能意会再加上一些以前应用 “$sort”-stage. db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}]) MongoDB 复制复制是同步在多个服务器上的数据过程。复制提供了冗余和数据在不同的数据库服务器上的多个副本提高数据的可用性，复制防止在单个服务器上丢失数据库。 复制也可以从硬件故障和服务中断中恢复。带有数据的其他副本，可以选择其中一个灾难恢复，报告或备份。 为什么要复制？ 为了让数据安全 数据的高（24*7）可用性 灾难恢复 无停机维护（如备份，索引重建，压缩） 读取缩放（额外的副本来读取） 副本集是透明的应用 MongoDB复制的工作原理MongoDB通过使用副本集的复制来实现。副本集是一组承载同一个数据集的mongod实例。在副本的一个节点是接收所有的写操作主节点。所有的实例，次级，应用操作从主以便它们具有相同的数据集。副本集只能有一个主节点。 副本集是一组两个或更多个节点（通常至少3节点是必需的）。 在副本集一个节点是主节点和其余的节点都是次要的。 所有的数据复制是从主到次节点。 在自动故障转移或维护时，选建立了主要和一个新的主节点被选择。 故障节点的恢复后，再次加入副本集，并可以作为一个辅助节点。 mongodb复制的典型图如下图，其中客户端应用程序总是与主节点和主节点交互，然后将数据复制到辅助节点。 副本集特征 N个节点的集群 任何节点可为原发/主节点 所有的写操作进入到主节点 自动故障转移 自动恢复 协商一致选择主节点 建立一个副本集在本教程中，我们将独立的 mongod 实例转换为副本集。 要转换为副本集，按照以下的步骤： 关闭已经运行的 MongoDB 服务器。 现在，通过指定–replSet选项启动 MongoDB 服务器。–replSet 的基本语法如下： 1mongod --port "PORT" --dbpath "YOUR_DB_DATA_PATH" --replSet "REPLICA_SET_INSTANCE_NAME" 1mongod --port 27017 --dbpath "D:\software\MongoDB\Server\3.0\mongodb\data" --replSet rs0 这将启动一个名为rs0的一个mongod实例，端口为： 27017 现在打开启动命令提示符，然后连接到mongod实例 在Mongo的客户端使用命令rs.initiate()来启动一个新的副本集 要检查副本设置配置，则使用命令rs.conf() 要检查副本集发行的状态，使用命令rs.status() MongoDB创建备份MongoDB数据转储要使用 mongodump 命令来执行 MongoDB 数据库备份。此命令将转储服务器的所有数据到转储目录。有许多可用的选项，通过它可以限制数据量或创建远程服务器备份。 语法mongodump命令的基本语法如下 1&gt;mongodump 例子启动 mongod 服务器。假设 mongod 服务器运行在本地主机和端口 27017. 现在打开一个命令提示符，然后转到你的MongoDB实例的bin目录，然后输入命令mongodump。 考虑mycol集合有以下数据。 1&gt;mongodump 该命令将连接到服务器127.0.0.1和端口27017，并备份所有数据到服务器上的目录： /bin/dump/. 命令的输出如下所示： 以上是可用的选项能够与mongodump命令一起使用的列表。 此命令将只备份指定数据库到指定的路径 语法 描述 示例 mongodump –host HOST_NAME –port PORT_NUMBER 这个命令将备份指定的mongod实例的所有数据库 mongodump –host yiibai.com –port 27017 mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY mongodump –dbpath /data/db/ –out /data/backup/ mongodump –collection COLLECTION –db DB_NAME 此命令将仅备份指定的特定数据库集合 mongodump –collection mycol –db test 数据恢复要恢复备份的MongoDB数据，则使用mongorestore命令。该命令将从备份目录恢复所有的数据。 语法mongorestore命令的基本语法 1&gt;mongorestore 这个命令的输出如下所示：]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 数据类型(数值)]]></title>
    <url>%2F2019%2F04%2F10%2Fjavascript%2F%E6%95%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[整数和浮点数Javascript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，1 与 1.0 是相同的，是同一个数。 121 === 1.0;// true 这就是说，Javascript 语言的底层根本没有整数，所有数字都是小数(64 位浮点数)。容易造成混淆的是，某些运算只有整数才能完成，此时 Javascript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3;// false0.3 / 0.1;// 2.99999999999999960.3 - 0.2 === 0.2 - 0.1;// false 数值精度根据国际标准 IEEE 754，Javascript 浮点数的 64 个二进制位，从最左边开始，是这样组成的。 第 1 位：符号位，0 表示正数，1 表示负数。 第 2 位到第 12 位(共 11 位)：指数部分。 第 13 位到第 64 位(共 52 位)：小数部分(即有效数字)。 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有 11 个二进制位，因些大小范围就是 0 到 2047。IEEE 754 规定，如果指数部分的值在 0 到 2047 之间(不含两个端点)，那么有效数字的第一位默认总是 1，不保存在 64 位浮点数之中。也就是说，有效数字这时总是 1.xx...xx 的形式，其中 xx...xx 的部分保存在 64 位浮点数之中，最长可能为 52 位。因此，Javascript 提供的有效数字最长为 53 个二进制位。 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下(指数部分在 0 到 2047 之间)，一个数在 Javascript 内部实际的表示形式。 精度最多只能到 53 个二进制位，这意味着，绝对值小于 2 的 53 次方的整数，即 -2^53 到2^53，都可以精确表示。 1234567891011121314Math.pow(2, 53);// 9007199254740992Math.pow(2, 53) + 1;// 9007199254740992Math.pow(2, 53) + 2;// 9007199254740994Math.pow(2, 53) + 3;// 9007199254740996Math.pow(2, 53) + 4;// 9007199254740996 上面代码中，大于 2 的 53 次方以后，整数运算的结果开始出现错误。所以，大于 2 的 53 次方的数值，都无法保持精度。由于 2 的 53 次方是一个 16 位的十进制数值，所以简单的法则就是，Javascript 对 15 位的十进制数都可以精确处理。 123456Math.pow(2, 53);// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111;// 9007199254740992000 上面示例表明，大于 2 的 53 次方以后，多出来的有效数字(最后三位的 111)都会无法保存，变成 0。 数值范围根据标准，64 位浮点数的指数部分的长度是 11 个二进制位，意味着指数部分的最大值是 2047(2 的 11 次方减 1)。也就是说，64 位浮点数的指数部分的值最大为 2047，分出一半表示负数，则 Javascript 能够表示的数值范围为 2^1024 到 2^-1023 (开区间)，超出这个范围的数无法表示。 如果一个数大于等于 2 的 1024 次方，那么就会发生正向溢出，即 Javascript 无法表示这么大的数，这时就会返回 Infinity。 1Math.pow(2, 1024); // Infinity 如果一个数小于等于 2 的-1075 次方(指数部分最小值-1023，再加上小数部分的 52 位)，那么就会发生为负向溢出，即 Javascript 无法表示这么小的数，这时会直接返回 0。 1Math.pow(2, -1075); // 0 下面是一个实际的例子。 1234567var x = 0.5;for (var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x; // 0 上面代码中，对 0.5 连续做 25 次平方，由于最后结果太接近 0，超出了可表示的范围，Javascript 就直接将其转为 0。 Javascriptr 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 12Number.MAX_VALUE; // 1.7976931348623157e+308Number.MIN_VALUE; // 5e-324 数值的表示法javascript 的数值有多种表示方法，可以用字面形式直接表示，比如35(十进制)和0xFF(十六进制)。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 1234123e3; // 123000123e-3; // 0.123-3.1e12; // -31000000000000.1e-23; // 1e-24 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，javascript 会自动将数值转为科学计数法表示。其他情况都采用字面形式直接表示。 （1）小数点前的数字多于 21 位。 123451234567890123456789012;// 1.2345678901234568e+21123456789012345678901;// 123456789012345680000 （2）小数点后的零多于 5 个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003; // 3e-7// 否则，就保持原来的字面形式0.000003; // 0.000003 数值的进制使用字面量（literal）直接表示一个数值时，javascript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导 0 的数值。 八进制：有前缀0o或00的数值，或者有前导 0、且只用到 0-7 的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，javascript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff; // 2550o377; // 2550b11; // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz; // 报错0o88; // 报错0b22; // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导 0 的数值会被视为八进制，但是如果前导 0 后面有数字8和9，则该数值被视为十进制。 120888; // 8880777; // 511 前导 0 表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 特殊数值正零和负零前面说过，Javascript 的 64 位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的值，就连 0 也不例外。 javascript 内部实际上存在 2 个 0：一个是 +0，一个是-0，区别就是 64 位浮点数表示法的符号位不同。它们是等价的。 123-0 === +0; // true0 === -0; // true0 === +0; // true 几乎所有场合，正零和负零都会被当作正常的 0。 12345678910+0 - // 0 0( // 0 -0 ) .toString()( // '0' +0 ) .toString(); // '0' 唯一有区别的场合是，+0 或 -0 当作分母，返回的值是不相等的。 121 / +0 === 1 / -0; // falseInfinity - Infinity; 上面的代码之所以出现这样的结果，是因为除以正零得到 +Infinity，除以负零得到 -Infinity，这两者是不相等的。 NaN 含义 NaN 是 javascript 的特殊值，表示非数字(Not a Number)，主要出现在将字符串解析成数字出错的场合。 15 - 'x'; // NaN 上面的代码运行时，会自动将字符串 x 转为数值，但是由于 x 不是数值，所以最后得到结果为 NaN，表示它是非数字(NaN)。 另外，一些数学函数的运算结果会出现 NaN。 123Math.acos(2); // NaNMath.log(-1); // NaNMath.sqrt(-1); // NaN 0 除以 0 也会得到 NaN。 10 / 0; // NaN 需要注意的是，NaN 不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于 Number，使用 typeof 运算符可以看得很清楚。 1typeof NaN; // 'number' 运算规则 NaN 不等于任何值，包括它本事。 1NaN === NaN; // false 数组的 indexOf 方法内部使用的是严格相等运算符，所以该方法对 NaN 不成立。 1[NaN].indexOf(NaN); // -1 NaN 在布尔运算时被当作 false。 1Boolean(NaN); // false NaN 与任何数(包括它自己)的运算，得到的都是 NaN。 1234NaN + 32; // NaNNaN - 32; // NaNNaN * 32; // NaNNaN / 32; // NaN Infinity 含义 Infinity 表示无穷，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非 0 数值除以 0，得到Infinity。 1234567// 场景一Math.pow(2, 1024);// Infinity// 场景二0 / 0; // NaN1 / 0; // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回 Infinity。第二个场景是 0 除以 0 会得到 NaN，而非 0 数值除以 0，会返回 Infinity。 Infinity 有正负之分，Infinity 表示正的无穷，-Infinity 表示负的无穷。 1234Infinity === -Infinity; // false1 / -0; // -Infinity-1 / -0; // Infinity 由于数值正向溢出（overflow）、负向溢出（underflow）和被 0 除，javascript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。 Infinity 大于一切数值（别无他物了NaN），-Infinity小于一切数值（除了 NaN）。 1234Infinity &gt; 1000 - // true Infinity &lt; -1000; // true Infinity 与 NaN 比较，总是返回 false。 12345Infinity &gt; NaN; // false-Infinity &gt; NaN; // falseInfinity &lt; NaN; // false-Infinity &lt; NaN; // false 运算规则 Infinity 的四则运算，符合无穷的数学计算规则。 12345 * Infinity; // Infinity5 - Infinity; // -InfinityInfinity / 5; // Infinity5 / Infinity; // 0 0 乘以Infinity，返回NaN；0 除以Infinity，返回0；Infinity除以 0，返回Infinity。 1230 * Infinity; // NaN0 / Infinity; // 0Infinity / 0; // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity; // InfinityInfinity * Infinity; // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity; // NaNInfinity / Infinity; // NaN Infinity与null计算时，null会转成 0，等同于与0的计算。 123null * Infinity; // NaNnull / Infinity; // 0Infinity / null; // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity; // NaNundefined - Infinity; // NaNundefined * Infinity; // NaNundefined / Infinity; // NaNInfinity / undefined; // NaN 与数值相关的全局方法parseInt() 基本用法 parseInt 方法用于将字符串转为整数。 1parseInt('123'); // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(' 81'); // 81 如果 parseInt 的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23); // 1// 等同于parseInt('1.23'); // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt('8a'); // 8parseInt('12**'); // 12parseInt('12.34'); // 12parseInt('15e2'); // 15parseInt('15px'); // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回 NaN。 12345parseInt('abc'); //NaNparseInt('.3'); // NaNparseInt(''); // NaNparseInt('+'); // NaNparseInt('+1'); // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt('0x10'); // 16 如果字符串以0开头，将其按照 10 进制解析。 1parseInt('011'); // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5); // 1// 等同于parseInt('1e+21'); // 1parseInt(0.0000008); // 8// 等同于parseInt('8e-7'); // 8 进制转换 parseInt方法还可以接受第二个参数(2 到 36)之间，表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为 10，即默认是十进制转十进制。 12parseInt('1000'); // 1000parseInt('1000', 10); // 1000 下面是转换指定进制的数的例子。 123parseInt('1000', 2); // 8parseInt('1000', 6); // 216parseInt('1000', 8); // 512 上面代码中，二进制、六进制、八进制的 1000，分别等于十进制的 8、216 和 512。这意味着，可以用 parseInt 方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在 2 到 36 之间，才能得到有意义的结果，超出这个范围，则返回 NaN。如果第二个参数是 0、undefined 和 null，则直接忽略。 12345parseInt('10', 37); // NaNparseInt('10', 1); // NaNparseInt('10', 0); // 10parseInt('10', null); // 10parseInt('10', undefined); // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回 NaN。 12parseInt('1546', 2); // 1parseInt('546', 2); // NaN 上面代码中，对于二进制来说，1 是有意义的字符，5、4、6 都是无意义的字符，所以第一行返回 1，第二行返回 NaN。 前面说过，如果 parseInt 的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36); // 43parseInt(0x11, 2); // 1// 等同于parseInt(String(0x11), 36);parseInt(String(0x11), 2);// 等同于parseInt('17', 36);parseInt('17', 2); 上面代码中，十六进制的 0x11 会被先转为十进制的 17，再转为字符串。然后，再用 36 进制或二进制解读字符串17，最后返回结果 43 和 1。 这种处理方式，对于八进制的前缀 0，尤其需要注意。 1234567parseInt(011, 2); // NaN// 等同于parseInt(String(011), 2);// 等同于parseInt(String(9), 2); 上面代码中，第一行的 011 会被先转为字符串 9，因为 9 不是二进制的有效字符，所以返回 NaN。如果直接计算 parseInt(&#39;011&#39;, 2)，011 则是会被当作二进制处理，返回 3。 JavaScript 不再允许将带有前缀 0 的数字视为八进制数，而是要求忽略这个 0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 parseFloat()parseFloat 方法用于将一个字符串转为浮点数。 1parseFloat('3.14'); // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat('314e-2'); // 3.14parseFloat('0.0314E+2'); // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat('3.14more non-digit characters'); // 3.14 parseFloat 方法会自动过滤字符串前导的空格。 1parseFloat('\t\v\r12.34\n '); // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回 NaN。 123parseFloat([]); // NaNparseFloat('FF2'); // NaNparseFloat(''); // NaN 上面代码中，尤其值得注意，parseFloat 会将空字符串转为 NaN。 这些特点使得 parseFloat 的转换结果不同于 Number 函数。 1234567891011parseFloat(true); // NaNNumber(true); // 1parseFloat(null); // NaNNumber(null); // 0parseFloat(''); // NaNNumber(''); // 0parseFloat('123.45#'); // 123.45Number('123.45#'); // NaN isNaN()isNaN 方法可以用来判断一个值是否为 NaN。 12isNaN(NaN); // trueisNaN(123); // false 但是，isNaN 只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成 NaN，所以最后返回 true，这一点要特别引起注意。也就是说，isNaN 为 true 的值，有可能不是 NaN，而是一个字符串。 123isNaN('Hello'); // true// 相当于isNaN(Number('Hello')); // true 出于同样的原因，对于对象和数组，isNaN 也返回 true。 1234567isNaN(&#123;&#125;); // true// 等同于isNaN(Number(&#123;&#125;)); // trueisNaN(['xzy']); // true// 等同于isNaN(Number(['xzy'])); // true 但是，对于空数组和只有一个数值成员的数组，isNaN 返回 false。 123isNaN([]); // falseisNaN([123]); // falseisNaN(['123']); // false 上面代码之所以返回 false，原因是这些数组能被 Number 函数转成数值。 因此，使用 isNaN 之前，最好判断一下数据类型。 123function myIsNaN(value) &#123; return typeof value === 'number' &amp;&amp; isNaN(value);&#125; 判断 NaN 更可靠的方法是，利用 NaN 为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) &#123; return value !== value;&#125; isFinite()isFinite 方法返回一个布尔值，表示某个值是否为正常的数值。 123456isFinite(Infinity); // falseisFinite(-Infinity); // falseisFinite(NaN); // falseisFinite(undefined); // falseisFinite(null); // trueisFinite(-1); // true 除了 Infinity、-Infinity、NaN 和 undefined 这几个值会返回 false，isFinite 对于其他的数值都会返回 true。 关于本文档的来历 摘抄自《JavaScript 标准参考教程（alpha）》，by 阮一峰 仅供学习使用]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript 数值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2019%2F04%2F10%2Fjavascript%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概述简介Javascript 语言的每一个值，都属于某一种数据类型。Javascript 的数据类型，共有六种。 数值(number): 整数和小数(比如 1 和 3.14)。 字符串(string): 文本(比如 hello world)。 布尔值(boolean): 表示真伪的两个特殊值，即 true (真)和 false (假)。 undefined: 表示”未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。 null: 表示空值，即此处的值为空。 对象(object): 各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始类型(primitive type) 的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型(complex type) 的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于 undefined 和 null，一般将它们看成两个特殊值。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象(object) 数值(array) 函数(function) 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象”都特指狭义的对象。函数其实是处理数据的方法，Javascript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 Javascript 的”函数式编程”奠定了基础。 typeof 运算符Javascript 有三种方法，可以确定一个值到底是什么类型。 typeof 运算符 instanceof 运算符 Object.prototype.toString 方法 instanceof 运算符和 Object.prototype.toString 方法，将在后文介绍。这里介绍 typeof 运算符。 typeof 运算符可以返回一个值的数据类型。 数值、字符串、布尔值分别返回 number 、string 、 boolean。 123typeof 123; // 'number'typeof '123'; // 'string'typeof false; // 'boolean' 函数返回 funciton。 123function f() &#123;&#125;typeof f; // 'function' undefined 返回 undefined。 1typeof undefined; // 'undefined' 利用这一点，typeof 可以用来检查一个没有声明的变量，而不报错。 12345v;// ReferenceError: v is not definedtypeof v;// 'undefined' 上面代码中，变量 v 没有用 var 命令声明，直接使用就会报错。但是，放在 typeof 后面，就不报错了，而是返回 undefined。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === 'undefined') &#123; // ...&#125; 对象返回 object。 123typeof window; // 'object'typeof &#123;&#125;; // 'object'typeof []; // 'object' 上面代码中，空数组( [] )的类型也是 object，这表示在 Javascript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof 运算符可以区分数组和对象。 12345var o = &#123;&#125;;var a = [];o instanceof Array; // falsea instanceof Array; // true null 返回 object。 1typeof null; // 'object' null 的类型是 object，这是由于历史原因造成的。1955 年的 Javascript 语言第一版，只设计了五种数据类型(对象、整数、浮点数、字符串和布尔值)，没考虑 null，只把它当作 object 的一种特殊值。后来 null 独立出来。作为一种单独的数据类型，为了兼容以前的代码，typeof null 返回 object 就没法改变了。 null、undefined 和布尔值null undefined 概述null 与 undefined 都可以表示没有，含义非常相似。将一个变量赋值为 undefined 或 null，老实说，语法效果几乎没区别。 123var a = undefined;// 或者var a = null; 上面代码中，变量 a 分别被赋值为 undefined 和 null，这两种写法的效果几乎等价。 在 if 语句中，它们都会被自动转为 false，相等运算符( == )甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log('undefined is false');&#125;// undefined is falseif (!null) &#123; console.log('null is false);&#125;// null is falseundefined == null;// true 从上面代码可见，两者的行为是何等相似！谷歌公司开发的 Javascript 语言的替代品 Dart 语言，就明确规定只有 null，没有 undefined ！ 既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史有关。 1995 年 Javascript 诞生时，最初像 Java 一样，只设置了 null 表示无。根据 C 语言的传统，null 可以自动转为 0。 12Number(null); // 05 + null; // 5 上面代码中，null 转为数字时，自动变成 0。 但是，Javascript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 Javascript 里面，null 就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示无的值最好不是对象。其次，那时的 Javascript 不包括错误处理机制，Brendan Eich 觉得，如果 null 自动转为 0，很不容易发现错误。 因些，他又设计了一个 undefined。区别是这样的：null 是一个表示空的对象，转为数值时为 0；undefined 是一个表示此处无定义的原始值，转为数值时为 NaN。 12Number(undefined); // NaN5 + undefined; // NaN 用法和含义对于 null 和 undefined，大致可以像下面这样理解。 null 表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这里就可以传入 null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入 null，表示未发生错误。 undefined 表示未定义，下面是返回 undefined 的典型场景。 1234567891011121314151617// 变量声明了 但没有赋值var i;i; // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f(); // undefined// 对象没有赋值的属性var o = new Object();o.p; // undefined// 函数没有返回值时， 默认返回 undefinedfunction f() &#123;&#125;f(); // undefined 布尔值布尔值代表真和假两个状态。真用关键字 true 表示，假用关键字 false 表示。布尔值只有这两个值。 下列运算符会返回布尔值： 前置逻辑运算符： !(Not) 相等运算符：===, !==, ==, != 比较运算符：&gt;, &gt;=, &lt;, &lt;= 如果 Javascript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 false，其他值都视为 true。 undefined null false 0 NaN &quot;&quot; 或 &#39;&#39; (空字符串) 布尔值往往用于程序流程的控制，请看一个例子。 1234if ('') &#123; console.log('true');&#125;// 没有任何输出 上面代码中，if 命令后面的判断条件，预期应该是一个布尔值，所以 Javascript 自动将空字符串，转为布尔值 false，导致程序不会进入代码块，所以没有任何输出。 注意，空数组( [] )和空对象( {} )对应的布尔值，都是 true。 1234567891011121314if ([]) &#123; console.log('true');&#125;// trueif ([].length == 0) &#123; console.log('true');&#125;// trueif (&#123;&#125;) &#123; console.log('true');&#125;// true 关于本文档的来历 摘抄自《JavaScript 标准参考教程（alpha）》，by 阮一峰 仅供学习使用]]></content>
      <categories>
        <category>数据类型</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 基本语法]]></title>
    <url>%2F2019%2F04%2F03%2Fjavascript%2Fjavascript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录语句Javascript 程度的执行单位为行（line）,也就是一行行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a = 1 + 3; 这条语句先用 var 命令，声明了变量 a，然后将 1 + 3 的运算结果赋值给变量 a。 1 + 3 叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，语句主要为了进行某种操作，一般情况下不需要返回值；表达式则是为了得到返回值，一定会返回一个值。凡是 Javascript 语句中预期为值的地方，都可以使用表达式。比如，赋值语句的选号右边，预期是一个值，因此可以放置各种表达式。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 1var a = 1 + 3; var b = &apos;abc&apos;; 分号前面可以没有任何内容，Javascript 引擎将其视为空语句。 1;;; 上面的代码就表示 3 个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 javascript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 121 + 3;('abc'); 上面两行语句只是单纯地产生一个值，并没有任何实际的意义。 变量概念变量是对 值 的具名引用。变量就是为 值 起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量 a，然后在变量 a 与数值 1 之间建立引用关系，称为将数值 1 赋值 给变量 a。以后，引用变量名 a 就会得到数值 1。最前面的 var，是变量声明命令。它表示通知解释引擎，要创建一个变量 a。 注意，javascript 的变量名区分大小写， A 和 a 是两个不同的变量。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是 undefined。undefined 是一个特殊的值，表示无定义。 12var a;a; // undefined 如果变量赋值的时候，忘了写 var 命令，这条语句也是有效的。 123var a = 1;// 基本等同a = 1; 但是，不写 var 的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用 var 命令表明变量。 如果一个变量没有声明就直接使用， javascirpt 会报错，告诉你变量未定义。 12a;// ReferenceError: a is not defined 上面的代码直接使用变量 a，系统就报错，告诉你变量 a 没有声明。 可以在同一条 var 命令中声明多个变量,变量之间用逗号隔开。 1var a, b; Javascript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 12var a = 1;a = 'hello'; 上面代码中，变量 a 开始被赋值为一个数值，后面又被重新赋值为一个字符串。第二次赋值的时候，因为变量 a 已经存在，所以不需要使用 var 命令。 如果使用 var 重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x; // 1 上面代码中，变量 x 声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 12345678var x = 1;var x = 2;// 等同于var x = 1;var x;x = 2; 变量提升Javascript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升(hoistin)。 12console.log(a);var a = 1; 上面代码首先使用 console.log 方法，在控制台(console)显示变量 a 的值。这时变量 a 还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后显示的结果是显示 undefined，表示变量 a 已声明，但还未赋值。 标识符标识符(identifier)指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。Javascript 语言的标识符对大小写敏感，所以 a 和 A 是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。Javascript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母(包括英文字母和其他语言的字母)，以及美元符号($)和下划线(_)。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字 0-9。 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或者连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; Javascript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 注释源码中被 Javascript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用 // 起头；另一种是多行注释，放在 /* 和 */ 之间。 1234567// 这是单行注释/* 这是 多行 注释*/ 此外，由于历史上 Javascript 可以兼容 HTML 代码的注释，所以 &lt;!-- 和 --&gt; 也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有 x = 1 会执行，其他的部分都被注释掉了。 需要注意的是， --&gt; 只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3);// 2// 1// 0 上面代码中，n --&gt; 0 实际上会当作 n-- &gt; 0，因此输出 2、1、0。 区块Javascript 使用大括号，将多个相关的语句组合在一起，称为区块(block)。 对于 var 命令来说，Javascript 的区块不构成单独的作用域(scope)。 12345&#123; var a = 1;&#125;a; // 1 上面代码在区块内部，使用 var 命令声明并赋值了变量 a，然后在区块外部，变量 a 依然有效，区块对于 var 命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 Javascript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如 for 、if 、while 、function 等。 条件语句Javascript 提供 if 结构和 switch 结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 if 结构if 结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指是 Javascript 的两个特殊值，true 表示真，false 表示伪。 1234if (布尔值) 语句;// 或者if (布尔值) 语句; 上面是 if 结构的基本形式。需要注意的是，布尔值往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为 true，就执行紧跟在后面的语句；如果结果为 false，则跳过紧跟在后面的语句。 1if (m === 3) m = m + 1; 上面代码表示，只有在 m 等于 3 时，才会将其值加上 1。 这种写法要求条件表达式只能有一个语句。如果想执行多个语句，必须在 if 的条件判断之后，加上大括号，表示代码块(多个语句合并成一个语句)。 123if (m === 3) &#123; m += 1;&#125; 建议总是在 if 语句中使用大括号，因为这样方便插入语句。 注意，if 后面的表达式之中，不要混淆赋值表达式( = )、严格相等运算符( === )和相等运算符( == )。尤其是赋值表达式不具有比较作用。 1234567var x = 1;var y = 2;if ((x = y)) &#123; console.log(x);&#125;// "2" 上面代码的原意是，当 x 等于 y 的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将 y 赋值给变量 x，再判断变量 x 的值(等于 2)的布尔值(结果为 true)。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将运算符写成赋值运算符，就会报错，因为常量不能被赋值。 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 if...else 结构if 代码块后面，还可以跟一个 else 代码块，表示不满足条件时，所要执行的代码。 12345if (3 === m) &#123; // 满足条件时 执行的语句&#125; else &#123; // 不满足条件时 执行的语句&#125; 上面代码判断变量 m 是否等于 3，如果等于就执行 if 代码块，否则执行 else 代码块。 对同一个变量进行多次判断时，多个 if...else 语句可以连写在一起。 123456789if (0 === m) &#123; // ...&#125; else if (1 === m) &#123; // ...&#125; else if (2 === m) &#123; // ...&#125; else &#123; // ...&#125; else 代码块总是与离自己最近的那个 if 语句配对。 123456var m = 1;var n = 2;if (1 !== m) if (2 === n) console.log('hello'); else console.log('world'); 上面代码不会有任何输出，else 代码块不会得到执行，因为它跟着的是最近的那个 if 语句，相当于下面这样。 12345678910var m = 1;var n = 2;if (1 !== m) &#123; if (2 === n) &#123; console.log('hello'); &#125; else &#123; console.log('world'); &#125;&#125; 如果想让 else 代码块跟随最上面的那个 if 语句，就要改变大括号的位置。 123456789101112var m = 1;var n = 2;if (1 !== m) &#123; if (2 === n) &#123; console.log('hello'); &#125;&#125; else &#123; console.log('world');&#125;// world switch 结构多个 if...else 连在一起使用的时候，可以转为使用更方便的 switch 结构。 12345678910switch (fruit) &#123; case 'banana': // ... break; case 'apple': // ... break; default: // ...&#125; 上面代码根据变量 fruit 的值，选择执行相应的 case。如果所有 case都不符合，则执行最后的 default 部分。需要注意的是，每个 case 代码块内部的 break 语句不能少，否则会接下去执行下一个 case 代码块，而不是跳出 switch 结构。 1234567891011121314var x = 1;switch (x) &#123; case 1: console.log('x 等于1'); case 2: console.log('x 等于2'); default: console.log('x 等于其他值');&#125;// x 等于1// x 等于2// x 等于其他值 上面代码中，case 代码块之中没有 break 语句，导致不会跳出 switch 结构，而会一直执行下去。正确的写法是像下面这样。 123456789101112var x = 1;switch (x) &#123; case 1: console.log('x 等于1'); break; case 2: console.log('x 等于2'); break; default: console.log('x 等于其他值');&#125; switch 语句部分和 case 语句部分，都可以使用表达式。 1234567switch (1 + 3) &#123; case 2 + 2: f(); break; default: neverHappens();&#125; 上面代码的 default 部分，是永远不会执行到的。 需要注意的是， switch 语句后面的表达式，与 cae 语句后面的表达式比较运行结果时，采用的是严格相等运算符( === )，而不是相等运算符( == )，这意味着比较时不会发生类型转换。 1234567891011var x = 1;switch (x) &#123; case true: console.log('x 发生类型转换'); break; default: console.log('x 没有发生类型转换');&#125;// x 没有发生类型转换 上面代码中，由于变量 x 没有发生类型转换，所以不会执行 case true 的情况。这表明，switch 语句内部采用的是严格相等运算符。 三元运算符 ?:Javascript 还有一个三元运算符(即该运算符需要三个运算子) ?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2; 上面代码中，如果条件为 true，则返回表达式 1的值，否则返回表达式 2的值。 1var even = n % 2 === 0 ? true : false; 上面代码中，如果 n 可以被 2 整除，则 even 等于 true，否则等于 false。它等同于下面的形式。 123456var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125; 这个三元运算符可以被视为 if...else... 的简写形式，因些可以用于多种场合。 1234var myVar;console.log(myVar ? 'myVar has a value' : 'myVar does not have a value');// myVar does not have a value 上面代码利用三元运算符，输出相应的提示。 1var msg = '数字' + n + '是' + (n % 2 === 0 ? '偶数' : '奇数'); 上面代码利用三元运算符，在字符串之中插入不同的值。 循环语句循环语句用于重复执行某个操作，它有多种形式。 while 循环while 语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while 语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; 下面是 while 语句的一个例子。 12345var i = 0;while (i &lt; 100) &#123; console.log('i 当前为：' + i); i = i + 1;&#125; 上面的代码将循环 100 次，直到 i 等于 100 为止。 下面的例子是一个无限循环，因为循环条件总是为真。 123while (true) &#123; console.log('hello world');&#125; for 循环for 语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 1234567for(初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for 语句后面的括号里面，有三个表达式。 初始化表达式(initalize)：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式(test)：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式(increment)：每轮循环的最后一个操作，通常用来递增循环变量。 下面是一个例子。 12345678var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2 上面代码中，初始化表达式是 var i = 0;，即初始化一个变量 i，测试表达式是 i &lt; x，即只要 i 小于 x，就会执行循环；递增表达式是 i++，即每次循环结束后，i 增大 1。 所有 for 循环，都可以改写成 while 循环。上面的例子改为 while 循环，代码如下。 1234567var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for 语句的三个部分(initalize、test、increment)，可以省略任何一个，也可以全部省略。 123for (;;) &#123; console.log('hello world');&#125; 上面代码省略了 for 语句表达式的三个部分，结果就导致了一个无限循环。 do...while 循环do...while 循环与 while 循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do...while 循环至少运行一次，这是这种结构最大的特点。另外，while 语句后面的分号注意不要省略。 下面是一个例子。 1234567var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while (i &lt; x); break 语句和 continue 语句break 语句和 continue 语句都具有跳转作用，可以让代码不按既有的顺序执行。 break 语句用于跳出代码块或循环。 1234567var i = 0;while (i &lt; 100) &#123; console.log('i当前为：' + i); i++; if (i == 10) break;&#125; 上面的代码只会执行 10 次循环，一旦 i 等于 10，就会跳出循环。 for 循环也可以使用 break 语句跳出循环。 1234567891011for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) &#123; break; &#125;&#125;// 0// 1// 2// 3 上面代码执行到 i 等于 3，就会跳出循环。 continue 语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 123456var i = 0;while (i &lt; 100) &#123; i++; if (i % 2 === 0) continue; console.log('i 当前为：' + i);&#125; 上面代码只有在 i 为奇数时，才会输出 i 的值。如果 i 为偶数，则直接进入下一轮循环。如果存在多重循环，不带参数的 break 语句和 continue 语句都只针对最内层循环。 标签(label)Javascript 语言允许，语句的前面有标签(label)，相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与 break 语句和 continue 语句配合使用，跳出特定的循环。 12345678910111213top: for (var i = 0; i &lt; 3; i++) &#123; for (var j = 0; j &lt; 3; j++) &#123; if (i === 1 &amp;&amp; j === 1) &#123; break top; console.log('i=' + i + ', j=' + j); &#125; &#125;&#125;// i=0 j=0// i=0 j=1// i=0 j=2// i=1 j=0 上面代码为一个双重循环区块，break 命令后面加上了 top 标签(注意，top 不用加引号)，满足条件时，直接跳出双层循环。如果 break 语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 123456789foo: &#123; console.log(1); break foo; console.log('本行不会输出');&#125;console.log(2);// 1// 2 上面代码执行到 break foo，就会跳出区块。 continue 语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++) &#123; for (var j = 0; j &lt; 3; j++) &#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log('i=' + i + ', j=' + j); &#125;&#125;// i=0 j=0// i=0 j=1// i=0 j=2// i=1 j=0// i=2 j=0// i=2 j=1// i=2 j=2 上面代码中，continue 命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果 continue 语句后面不使用标签，则只能进入下一轮的内层循环。 关于本文档的来历 摘抄自《JavaScript 标准参考教程（alpha）》，by 阮一峰 仅供学习使用]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 学习语法]]></title>
    <url>%2F2019%2F03%2F27%2Fmarkdown%2F01%20%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown 学习语法1. 标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 2. 字体 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 3. 引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 4. 分割线 三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 5. 图片 语法 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 1![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 6. 超链接 语法 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 注：Markdown 本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用 html 语言的 a 标签代替。 7. 列表 语法 无序列表 用 - + * 任何一种都可以 1234- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表 用数字加点 12341.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 8. 表格 语法 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 9. 流程图 示例： 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 URL 输入到页面展示]]></title>
    <url>%2F2019%2F03%2F27%2Finterview%2F%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[从 URL 输入到页面展示打开浏览器输入 url 的过程中，背后到底发生了哪些事情？从下面两张图来开始说。 可以分为如下几个过程： DNS 解析: 将域名(domain)解析成 IP 地址 TCP 连接: TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接: TCP 四次挥手 一、URL 到底是啥URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上的资源。结构如下:scheme://host.domain:port/path/filenamescheme - 定义因特网服务类型。有 http， https，ftp，file 等，最常见的类型是 http，而 https 则是进行加密的网络传输，安全性更高。host - 定义域主机(http 的默认主机是 WWW)domain - 定义域名(常见有 .com .cn .net 现在还有中文域名)port - 定义主机上的端口 http 默认端口 80(tcp)，https 默认端口 443(tcp,udp)path - 定义服务器上的路径filename - 定义文档/资源的名称 二、域名解析（DNS）在浏览器输入网址后，首页要经过域名解析，浏览器不能直接通过域名找到对应的服务器，需通过 IP 地址。 IP 地址（IP Address）ip 地址是指互联网协议地址，是 ip 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽设备物理地址的差异。IPv4 为一个 32 位的二进制数， IPv6 为 128 位的十六进制数 域名解析DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。 浏览器如何通过域名去查询 URL 对应的 IP 浏览器缓存: 浏览器会按照一定的频率缓存 DNS 记录。 操作系统缓存: 如果浏览器缓存中找不到需要的记录，会去操作系统中找。 路由缓存: 路由器也可缓存 DNS 记录。 ISP 的 DNS 服务器: ISP 指互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。 根服务器: 递归查询。 小结浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。 三、TCP 三次握手在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。 TCP 三次握手的过程如下: 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了） 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧） 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧） 为啥需要三次握手 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 四、发送 HTTP 请求 TCP 三次握手结束后，开始发送 HTTP 请求报文。 请求报文由请求行(request line)、请求头(header)、 请求体四个部分组成，如图所示: 请求行包含请求方法、URL、协议版本 请求方法包含: GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 URL 即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt;组成。 协议版本即 http 版本号。1POST /chapter17/user.html HTTP/1.1 以上代码中POST代表请求方法，/chapter17/user.html表示 URL，HTTP/1.1代表协议和协议的版本。 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号分隔。 请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如: Host 表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent,请求发出者，兼容性以及定制化需求。 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。 1name=tom&amp;password=1234&amp;realName=tomson 上面代码，承载着 name、password、realName 三个请求参数。 五、服务器处理请求并返回 HTTP 报文 服务器 服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机(客户机)提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache 、nginx 、IIS 等。 web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理(例如 CGL 脚本，JSP 脚本，servlets，ASP 脚本，服务端 JavaScript，或者一些其它的服务器端技术等)，然后返回后台程序处理产生的结果作为响应。 MVC 后台处理阶段 后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。 MVC 是一个设计模式，将应用程序分成三个核心部件: 模型（model）- 视图（view）- 控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。 视图（view）它是提供给用户的操作界面，是程序的外壳。 模型（model）模型主要负责数据交互。 在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。 控制器（controller）它负责根据用户从视图层输入的指令，选取模型层中的数据，然后对其进行相应的操作，产生最终结果。 控制器属于管理者角色，从视图接收请求并决定调用哪 个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。 这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口，供上面一层调用。首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。 http 响应报文 响应报文由响应行（response line）、响应头部（header）、响应主体三个部分组成。如下图所示： 响应行包含: 协议版本、状态码状态码规则如下：1xx：指示信息 - 表示请求已接收，继续处理。2xx：成功 - 表示请求已被成功接收、理解、接受。3xx：重定向 - 要完成请求必须进行更进一步的操作。4xx：客户端错误 - 请求有语法错误或请求无法实现。5xx：服务器端错误 - 服务器未能实现合法的请求。 响应头部包含响应报文的附加信息，由 名/值 对组成 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据 六、浏览器解析渲染页面浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制 浏览器解析渲染页面分为五个步骤： 根据 HTML 解析出 DOM 树 根据 CSS 解析生成 CSS 规则树 结合 DOM 树和 CSS 规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 根据 HTML 解析 DOM 树 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优选遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。 根据 CSS 解析生成 CSS 规则树 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。 浏览器在 CSS 规则树生成之前不会进行渲染。 结合 DOM 树和 CSS 规则树，生成渲染树 DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。 根据渲染树计算每一个节点的信息(布局) 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 根据计算好的信息绘制页面 绘制阶段，系统会遍历呈现树，并调用呈现器的paint方法，将呈现器的内容显示在屏幕上。 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。 回流：某个元素的尺寸发生了变化，则需要重新计算渲染树，重新渲染。 七、断开连接当数据传送完毕，需要断开 TCP 连接，此时发起 TCP 四次挥手。 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。（第一次挥手由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧） 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起发送报文段，Fin、Ack、Seq 请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也关闭吧)]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 常见知识点]]></title>
    <url>%2F2019%2F03%2F27%2Finterview%2Fvue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Vue 常见知识点一、什么是 mvvmMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。 Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来， ViewModel 是一个同步 View 和 Model 的对象。 在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因些 View 数据的变化会同步到 Model 中，而且 Model 数据的变化也会立即反应到 View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而且 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 二、mvvm 和 mvc 区别？mvc 和 mvvm 其实区别不大。 都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 ViewModel。 mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 model 频繁发生变化，开发者需要主动更新到 View。 三、vue 的优点是什么？ 低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的VIew上，当 View 变化的时候 Model 可以不变， 当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。 独立开发。 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 四、vue 生命周期的理解总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后: 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。 载入前/后: 在 beforeMount 阶段，vue 实例的 \$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点， data.message 还未替换。在 mounted 阶段， vue 实例挂载完成，data.message 成功渲染。 更新前/后: 当 data 变化时，会触发 beforeUpdate 和 updated 方法。 销毁前/后: 在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。 五、组件之间的传值 父组件与子组件传值（父组件通过标签上面定义传值） 子组件在 props 中创建一个属性，用以接收父组件传过来的值 父组件中注册子组件 在子组件标签中添加子组件 props 中创建的属性 把需要传给子组件的值赋给该属性 123456789101112131415161718192021222324252627282930313233343536// 父组件通过标签上面定义传值&lt;template&gt; &lt;Main :obj="data"&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt; // 引入子组件 import Main form "./main" export default &#123; name: "parent", data() &#123; return &#123; data: "我要向子组件传递的数据" &#125; &#125;, // 初始化组件 components: &#123; Main &#125; &#125;&lt;/script&gt;// 子组件通过 props 方法接受数据&lt;template&gt; &lt;div&gt;&#123;&#123; data &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "son", // 接受父组件传值 props: ["data"] &#125;&lt;/script&gt; 子组件向父组件传递数据（子组件通过\$emit 方法传递参数） 子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件 将需要传的值作为\$emit 的第二个参数，该值将作为实参传给响应自定义事件的方法 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;Main v-bind:message="parentMessage" v-on:listenToChildEvent="showMsgFromChild"&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt; // 引入子组件 import Main form "./main" export default &#123; name: "parent", data() &#123; return &#123; parentMessage: "hello" &#125; &#125;, methods: &#123; showMsgFromChild: function(data) &#123; console.log(data) &#125; &#125; &#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;button v-on:click="sendMsgToParent"&gt;向父组件传值&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "son", props: ["message"], methods: &#123; sendMsgToParent: function() &#123; this.$emit("listenToChildEvent", "this message is from child") &#125; &#125; &#125;&lt;/script&gt; 六、 active-class 是哪个组件的属性vue-router 模块的 router-link 组件。 七、嵌套路由怎么定义在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。index.html 只有一个路由出口。 1234&lt;div id="app"&gt; &lt;!-- router-view 路由出口 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; main.js 路由的重定向，就会在页面一加载的时候，就会将 home 组件显示出来，因为重定向指向了 home 组件， redirect 的指向与 path 的必须一致。 children 里面是子路由，当然子路由里面还可以继续嵌套子路由。 12345678910111213141516171819202122232425262728293031323334import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter);// 引入两个组件import home from './home.vue';import game from './game.vue';// 定义路由const routes = [ &#123; path: '/', redirect: '/home' // 重定向 指向了 home 组件 &#125;, &#123; path: '/home', component: home, children: [ &#123; path: '/home/game', component: game &#125; ] &#125;];// 创建路由实例const router = new VueRouter(&#123; routes &#125;);new Vue(&#123; el: '#app', router&#125;); home.vue 点击显示就会将子路由显示出来，子路由的出口必须在父路由里面，否则子路由无法显示。 八、路由之间跳转 声明式（标签跳转） &lt;router-link :to=&quot;index&quot;&gt; 编程式（js 跳转）router.push(&#39;index&#39;) 九、懒加载（按需加载路由）webpack 中提供了 require.ensure() 来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。 不进行页面按需加载引入方式： 1import home from '../../common/home.vue'; 进行页面按需加载的引入方式： 1const home = r =&gt; require.ensure([], () =&gt; r(require('../../common.vue'))); 十、vuex 是什么 怎么使用 哪种功能场景使用它vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store， … export。场景有： 单面应用中，组件之间的状态。音乐播放、登录状态、加入购物车。 12345678910111213// 新建 store.jsimport vue from 'vue'import vuex from 'vuex'vue.use(vuex)export default new vuex.store(&#123; // ...code&#125;)// main.jsimport store from './store'... 十一、vue-router 有哪几种导航钩子三种 全局导航钩子 router.beforeEach(to, from, next), router.beforeResolve(to, from, next), router.afterEach(to, from, next) 组件内钩子 beforeRouteEnter beforeRouteUpdate beforeRouteLeave 单独路由独享组件 beforeEnter 十二、自定义指令（v-check, v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数 全局定义指令： 在 vue 对象的 directive 方法里面有两个参数，一个是指令名称，另一个是函数。 组件内定义指令：directives 钩子函数：bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新) 钩子函数参数：el、binding 十三、说出至少 4 种 vue 当中的指令和它的用法v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定) ##]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 配置]]></title>
    <url>%2F2019%2F03%2F04%2Fwebpack%2Fwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack 配置学习一. 入口[entry] 介绍 指示 webpack 应该使用哪个模块，来作为构建内部依赖图的开始 每个依赖项都被处理，最后输出到 bundles 文件中 入口可指定一个或多个，默认值为 ./src 配置 单个入口 多个入口 123module.exports = &#123; entry: './src/index.js'&#125;; 123456module.exports = &#123; entry: &#123; index: './src/index.js', vendors: './src/vendors.js' &#125;&#125;; 二. 出口[output] 介绍 告诉 wepback 在哪里输出所创建的 bundles ，以及如何命名这些文件，默认值为 ./dist 整个应用程序结构，都会被编译到所指定的输出路径的文件夹中 output.filename 属性配置输出文件名，output.path 属性配置输出文件路径 配置 单个入口对应出口配置 多个入口对应出口配置（可配置 hash，避免缓存；publicPath 可配置静态资源 CDN 或者服务器访问地址，也可不配置） 123456module.exports = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;; 12345678910111213module.exports = &#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, './dist'), publicPath: '' &#125;&#125;;// 写入到硬盘：./dist/app.js, ./dist/search.js 三. loader 介绍 loader 让 webpack 能够去处理那些非 javascript 文件 定义在 module.rules 中 test 属性，设置应该被对应的 loader 进行转换的某个或某些文件 use 属性，设置对应的 loader 四. 插件[plugins] 介绍 插件功能相当强大 可解决打包优化和压缩优化等 定义在 plugins 中 在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例 五. 模式 介绍 mode 有 development 和 production 两种模式，分别用于开发环境和生产环境 可设置对应模式下的相关 webpack 配置 使用 webpack 配置中使用 mode 可从 CLI 参数中传递 注意 development: 会将 process.env.NODE_ENV 的值设为 development；并启用 NamedChunksPlugin 和 NamedModulesPlugin。 production: 会将 process.env.NODE_ENV 的值设为 production； 并启用 FlagDependencyUsagePlugin , FlagIncludedChunksPlugin , ModuleConcatenationPlugin , NoEmitOnErrorsPlugin , OccurrenceOrderPlugin , SideEffectsFlagPlugin , UglifyJsPlugin 。 只设置 NODE_ENV ，则不会自动设置 mode 。 123module.exports = &#123; mode: 'production' // development production&#125;; 1webpack --mode=production]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
