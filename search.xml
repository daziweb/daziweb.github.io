<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[markdown 学习语法]]></title>
    <url>%2F2019%2F03%2F27%2Fmarkdown%2F01%20%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[markdown 学习语法1. 标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 2. 字体 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 3. 引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 4. 分割线 三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 5. 图片 语法 1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 1![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 6. 超链接 语法 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 注：Markdown 本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用 html 语言的 a 标签代替。 7. 列表 语法 无序列表 用 - + * 任何一种都可以 1234- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 有序列表 用数字加点 12341.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 8. 表格 语法 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 9. 流程图 示例： 123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从 URL 输入到页面展示]]></title>
    <url>%2F2019%2F03%2F27%2Finterview%2F%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[从 URL 输入到页面展示打开浏览器输入 url 的过程中，背后到底发生了哪些事情？从下面两张图来开始说。 可以分为如下几个过程： DNS 解析: 将域名(domain)解析成 IP 地址 TCP 连接: TCP 三次握手 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 断开连接: TCP 四次挥手 一、URL 到底是啥URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上的资源。结构如下:scheme://host.domain:port/path/filenamescheme - 定义因特网服务类型。有 http， https，ftp，file 等，最常见的类型是 http，而 https 则是进行加密的网络传输，安全性更高。host - 定义域主机(http 的默认主机是 WWW)domain - 定义域名(常见有 .com .cn .net 现在还有中文域名)port - 定义主机上的端口 http 默认端口 80(tcp)，https 默认端口 443(tcp,udp)path - 定义服务器上的路径filename - 定义文档/资源的名称 二、域名解析（DNS）在浏览器输入网址后，首页要经过域名解析，浏览器不能直接通过域名找到对应的服务器，需通过 IP 地址。 IP 地址（IP Address）ip 地址是指互联网协议地址，是 ip 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽设备物理地址的差异。IPv4 为一个 32 位的二进制数， IPv6 为 128 位的十六进制数 域名解析DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。 浏览器如何通过域名去查询 URL 对应的 IP 浏览器缓存: 浏览器会按照一定的频率缓存 DNS 记录。 操作系统缓存: 如果浏览器缓存中找不到需要的记录，会去操作系统中找。 路由缓存: 路由器也可缓存 DNS 记录。 ISP 的 DNS 服务器: ISP 指互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。 根服务器: 递归查询。 小结浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。 三、TCP 三次握手在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。 TCP 三次握手的过程如下: 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了） 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧） 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧） 为啥需要三次握手 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 四、发送 HTTP 请求 TCP 三次握手结束后，开始发送 HTTP 请求报文。 请求报文由请求行(request line)、请求头(header)、 请求体四个部分组成，如图所示: 请求行包含请求方法、URL、协议版本 请求方法包含: GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 URL 即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt;组成。 协议版本即 http 版本号。1POST /chapter17/user.html HTTP/1.1 以上代码中POST代表请求方法，/chapter17/user.html表示 URL，HTTP/1.1代表协议和协议的版本。 请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号分隔。 请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如: Host 表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent,请求发出者，兼容性以及定制化需求。 请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。 1name=tom&amp;password=1234&amp;realName=tomson 上面代码，承载着 name、password、realName 三个请求参数。 五、服务器处理请求并返回 HTTP 报文 服务器 服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机(客户机)提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache 、nginx 、IIS 等。 web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理(例如 CGL 脚本，JSP 脚本，servlets，ASP 脚本，服务端 JavaScript，或者一些其它的服务器端技术等)，然后返回后台程序处理产生的结果作为响应。 MVC 后台处理阶段 后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。 MVC 是一个设计模式，将应用程序分成三个核心部件: 模型（model）- 视图（view）- 控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。 视图（view）它是提供给用户的操作界面，是程序的外壳。 模型（model）模型主要负责数据交互。 在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。 控制器（controller）它负责根据用户从视图层输入的指令，选取模型层中的数据，然后对其进行相应的操作，产生最终结果。 控制器属于管理者角色，从视图接收请求并决定调用哪 个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。 这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口，供上面一层调用。首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。 http 响应报文 响应报文由响应行（response line）、响应头部（header）、响应主体三个部分组成。如下图所示： 响应行包含: 协议版本、状态码状态码规则如下：1xx：指示信息 - 表示请求已接收，继续处理。2xx：成功 - 表示请求已被成功接收、理解、接受。3xx：重定向 - 要完成请求必须进行更进一步的操作。4xx：客户端错误 - 请求有语法错误或请求无法实现。5xx：服务器端错误 - 服务器未能实现合法的请求。 响应头部包含响应报文的附加信息，由 名/值 对组成 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据 六、浏览器解析渲染页面浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制 浏览器解析渲染页面分为五个步骤： 根据 HTML 解析出 DOM 树 根据 CSS 解析生成 CSS 规则树 结合 DOM 树和 CSS 规则树，生成渲染树 根据渲染树计算每一个节点的信息 根据计算好的信息绘制页面 根据 HTML 解析 DOM 树 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优选遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。 根据 CSS 解析生成 CSS 规则树 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。 浏览器在 CSS 规则树生成之前不会进行渲染。 结合 DOM 树和 CSS 规则树，生成渲染树 DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。 根据渲染树计算每一个节点的信息(布局) 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 根据计算好的信息绘制页面 绘制阶段，系统会遍历呈现树，并调用呈现器的paint方法，将呈现器的内容显示在屏幕上。 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。 回流：某个元素的尺寸发生了变化，则需要重新计算渲染树，重新渲染。 七、断开连接当数据传送完毕，需要断开 TCP 连接，此时发起 TCP 四次挥手。 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。（第一次挥手由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧） 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧) 被动方向发起发送报文段，Fin、Ack、Seq 请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧) 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也关闭吧)]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 常见知识点]]></title>
    <url>%2F2019%2F03%2F27%2Finterview%2Fvue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Vue 常见知识点一、什么是 mvvmMVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。 Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来， ViewModel 是一个同步 View 和 Model 的对象。 在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因些 View 数据的变化会同步到 Model 中，而且 Model 数据的变化也会立即反应到 View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而且 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 二、mvvm 和 mvc 区别？mvc 和 mvvm 其实区别不大。 都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 ViewModel。 mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 model 频繁发生变化，开发者需要主动更新到 View。 三、vue 的优点是什么？ 低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的VIew上，当 View 变化的时候 Model 可以不变， 当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。 独立开发。 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 四、vue 生命周期的理解总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后: 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。 载入前/后: 在 beforeMount 阶段，vue 实例的 \$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点， data.message 还未替换。在 mounted 阶段， vue 实例挂载完成，data.message 成功渲染。 更新前/后: 当 data 变化时，会触发 beforeUpdate 和 updated 方法。 销毁前/后: 在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。 五、组件之间的传值 父组件与子组件传值（父组件通过标签上面定义传值） 子组件在 props 中创建一个属性，用以接收父组件传过来的值 父组件中注册子组件 在子组件标签中添加子组件 props 中创建的属性 把需要传给子组件的值赋给该属性 123456789101112131415161718192021222324252627282930313233343536// 父组件通过标签上面定义传值&lt;template&gt; &lt;Main :obj="data"&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt; // 引入子组件 import Main form "./main" export default &#123; name: "parent", data() &#123; return &#123; data: "我要向子组件传递的数据" &#125; &#125;, // 初始化组件 components: &#123; Main &#125; &#125;&lt;/script&gt;// 子组件通过 props 方法接受数据&lt;template&gt; &lt;div&gt;&#123;&#123; data &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "son", // 接受父组件传值 props: ["data"] &#125;&lt;/script&gt; 子组件向父组件传递数据（子组件通过\$emit 方法传递参数） 子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件 将需要传的值作为\$emit 的第二个参数，该值将作为实参传给响应自定义事件的方法 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;Main v-bind:message="parentMessage" v-on:listenToChildEvent="showMsgFromChild"&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt; // 引入子组件 import Main form "./main" export default &#123; name: "parent", data() &#123; return &#123; parentMessage: "hello" &#125; &#125;, methods: &#123; showMsgFromChild: function(data) &#123; console.log(data) &#125; &#125; &#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &lt;button v-on:click="sendMsgToParent"&gt;向父组件传值&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: "son", props: ["message"], methods: &#123; sendMsgToParent: function() &#123; this.$emit("listenToChildEvent", "this message is from child") &#125; &#125; &#125;&lt;/script&gt; 六、 active-class 是哪个组件的属性vue-router 模块的 router-link 组件。 七、嵌套路由怎么定义在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。index.html 只有一个路由出口。 1234&lt;div id="app"&gt; &lt;!-- router-view 路由出口 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; main.js 路由的重定向，就会在页面一加载的时候，就会将 home 组件显示出来，因为重定向指向了 home 组件， redirect 的指向与 path 的必须一致。 children 里面是子路由，当然子路由里面还可以继续嵌套子路由。 12345678910111213141516171819202122232425262728293031323334import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter);// 引入两个组件import home from './home.vue';import game from './game.vue';// 定义路由const routes = [ &#123; path: '/', redirect: '/home' // 重定向 指向了 home 组件 &#125;, &#123; path: '/home', component: home, children: [ &#123; path: '/home/game', component: game &#125; ] &#125;];// 创建路由实例const router = new VueRouter(&#123; routes &#125;);new Vue(&#123; el: '#app', router&#125;); home.vue 点击显示就会将子路由显示出来，子路由的出口必须在父路由里面，否则子路由无法显示。 八、路由之间跳转 声明式（标签跳转） &lt;router-link :to=&quot;index&quot;&gt; 编程式（js 跳转）router.push(&#39;index&#39;) 九、懒加载（按需加载路由）webpack 中提供了 require.ensure() 来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。 不进行页面按需加载引入方式： 1import home from '../../common/home.vue'; 进行页面按需加载的引入方式： 1const home = r =&gt; require.ensure([], () =&gt; r(require('../../common.vue'))); 十、vuex 是什么 怎么使用 哪种功能场景使用它vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store， … export。场景有： 单面应用中，组件之间的状态。音乐播放、登录状态、加入购物车。 12345678910111213// 新建 store.jsimport vue from 'vue'import vuex from 'vuex'vue.use(vuex)export default new vuex.store(&#123; // ...code&#125;)// main.jsimport store from './store'... 十一、vue-router 有哪几种导航钩子三种 全局导航钩子 router.beforeEach(to, from, next), router.beforeResolve(to, from, next), router.afterEach(to, from, next) 组件内钩子 beforeRouteEnter beforeRouteUpdate beforeRouteLeave 单独路由独享组件 beforeEnter 十二、自定义指令（v-check, v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数 全局定义指令： 在 vue 对象的 directive 方法里面有两个参数，一个是指令名称，另一个是函数。 组件内定义指令：directives 钩子函数：bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新) 钩子函数参数：el、binding 十三、说出至少 4 种 vue 当中的指令和它的用法v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定) ##]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 配置]]></title>
    <url>%2F2019%2F03%2F04%2Fwebpack%2Fwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack 配置学习一. 入口[entry] 介绍 指示 webpack 应该使用哪个模块，来作为构建内部依赖图的开始 每个依赖项都被处理，最后输出到 bundles 文件中 入口可指定一个或多个，默认值为 ./src 配置 单个入口 多个入口 123module.exports = &#123; entry: './src/index.js'&#125;; 123456module.exports = &#123; entry: &#123; index: './src/index.js', vendors: './src/vendors.js' &#125;&#125;; 二. 出口[output] 介绍 告诉 wepback 在哪里输出所创建的 bundles ，以及如何命名这些文件，默认值为 ./dist 整个应用程序结构，都会被编译到所指定的输出路径的文件夹中 output.filename 属性配置输出文件名，output.path 属性配置输出文件路径 配置 单个入口对应出口配置 多个入口对应出口配置（可配置 hash，避免缓存；publicPath 可配置静态资源 CDN 或者服务器访问地址，也可不配置） 123456module.exports = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;; 12345678910111213module.exports = &#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, './dist'), publicPath: '' &#125;&#125;;// 写入到硬盘：./dist/app.js, ./dist/search.js 三. loader 介绍 loader 让 webpack 能够去处理那些非 javascript 文件 定义在 module.rules 中 test 属性，设置应该被对应的 loader 进行转换的某个或某些文件 use 属性，设置对应的 loader 四. 插件[plugins] 介绍 插件功能相当强大 可解决打包优化和压缩优化等 定义在 plugins 中 在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例 五. 模式 介绍 mode 有 development 和 production 两种模式，分别用于开发环境和生产环境 可设置对应模式下的相关 webpack 配置 使用 webpack 配置中使用 mode 可从 CLI 参数中传递 注意 development: 会将 process.env.NODE_ENV 的值设为 development；并启用 NamedChunksPlugin 和 NamedModulesPlugin。 production: 会将 process.env.NODE_ENV 的值设为 production； 并启用 FlagDependencyUsagePlugin , FlagIncludedChunksPlugin , ModuleConcatenationPlugin , NoEmitOnErrorsPlugin , OccurrenceOrderPlugin , SideEffectsFlagPlugin , UglifyJsPlugin 。 只设置 NODE_ENV ，则不会自动设置 mode 。 123module.exports = &#123; mode: 'production' // development production&#125;; 1webpack --mode=production]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
