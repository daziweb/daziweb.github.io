<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dazi-World</title>
  
  <subtitle>黄昏恬静到三更</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://daziweb.github.io/"/>
  <updated>2019-05-22T09:26:22.941Z</updated>
  <id>https://daziweb.github.io/</id>
  
  <author>
    <name>Dazi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML5与HTML4的区别</title>
    <link href="https://daziweb.github.io/2019/05/22/books/HTML5%E4%B8%8ECSS3%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC%E4%B8%89%E7%89%88%20%E4%B8%8A%E5%86%8C)/HTML5%E4%B8%8EHTML4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://daziweb.github.io/2019/05/22/books/HTML5与CSS3权威指南(第三版 上册)/HTML5与HTML4的区别/</id>
    <published>2019-05-22T03:39:07.859Z</published>
    <updated>2019-05-22T09:26:22.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="迎接新的-Web-时代"><a href="#迎接新的-Web-时代" class="headerlink" title="迎接新的 Web 时代"></a>迎接新的 Web 时代</h2><h3 id="HTML5-的目标"><a href="#HTML5-的目标" class="headerlink" title="HTML5 的目标"></a>HTML5 的目标</h3><p>为了能够创建更简单的 Web 程序，书写出更简洁的 HTML 代码。提供了很多新的 API，开发了新的属性、新的元素，使得页面变得非常清楚直观、容易理解。</p><a id="more"></a><h2 id="HTML5-与-HTML4-的区别"><a href="#HTML5-与-HTML4-的区别" class="headerlink" title="HTML5 与 HTML4 的区别"></a>HTML5 与 HTML4 的区别</h2><h3 id="HTML5-中的标记方法"><a href="#HTML5-中的标记方法" class="headerlink" title="HTML5 中的标记方法"></a>HTML5 中的标记方法</h3><ul><li><strong>内容类型(ContentType)</strong></li></ul><p>HTML5 的文件扩展符与内容类型保持不变。扩展符仍然为<code>.html</code>或<code>.htm</code>，内容类型(ContentType)仍然为<code>text/html</code>。</p><ul><li><strong>DOCTYPE 声明</strong></li></ul><p>要建立符合标准的网页，DOCTYPE 声明是必不可少的关键组成部分，位于文件第一行。DOCTYPE 是 document type（文档类型）的简写，用来说明你用的 XMHTML 或者 HTML 是什么版本。缺少或错误的 document 将会造成 css 失效或半失效。</p><p>在 HTML5 中，刻意不使用版本声明，一份文档将会适用所有版本的 HTML。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML4</span></span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML5 不区分大小写 不区分单双引号</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure><ul><li>指定字符编码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML4</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML5</span></span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br></pre></td></tr></table></figure><p>两种写法都有效，但是不能同时混合使用两种方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span> http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：此写法为错误写法。</strong><br><strong>建议：从 HTML5 开始，对于文件的字符编码推荐使用 UTF-8。</strong></p><h3 id="HTML5-确保的兼容性"><a href="#HTML5-确保的兼容性" class="headerlink" title="HTML5 确保的兼容性"></a>HTML5 确保的兼容性</h3><ul><li><p>可以省略标记的元素</p><ul><li><p>不允许写结束标签的元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr。</p></li><li><p>可以省略结束标记的元素有：li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、tfoot、tr、td、th。</p></li><li><p>可以省略全部标记的元素有：html、head、body、colgroup、tbody。</p></li></ul></li><li><p>具有 boolean 值的属性</p><ul><li>对于具有 boolean 值的属性，当只写属性而不指定属性值时，表示属性值为 true，如果想要将属性值设为 false，则可以不使用该属性。如果想将属性值设定为 true 时，可以将属性名设定为属性值，或将空字符串设定为属性值。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"checkbox"</span> checked&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;迎接新的-Web-时代&quot;&gt;&lt;a href=&quot;#迎接新的-Web-时代&quot; class=&quot;headerlink&quot; title=&quot;迎接新的 Web 时代&quot;&gt;&lt;/a&gt;迎接新的 Web 时代&lt;/h2&gt;&lt;h3 id=&quot;HTML5-的目标&quot;&gt;&lt;a href=&quot;#HTML5-的目标&quot; class=&quot;headerlink&quot; title=&quot;HTML5 的目标&quot;&gt;&lt;/a&gt;HTML5 的目标&lt;/h3&gt;&lt;p&gt;为了能够创建更简单的 Web 程序，书写出更简洁的 HTML 代码。提供了很多新的 API，开发了新的属性、新的元素，使得页面变得非常清楚直观、容易理解。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍阅读" scheme="https://daziweb.github.io/categories/%E4%B9%A6%E7%B1%8D%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="CSS HTML" scheme="https://daziweb.github.io/tags/CSS-HTML/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 基础控件</title>
    <link href="https://daziweb.github.io/2019/05/14/flutter/%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6/"/>
    <id>https://daziweb.github.io/2019/05/14/flutter/基础控件/</id>
    <published>2019-05-14T06:59:15.691Z</published>
    <updated>2019-05-14T08:08:02.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础控件"><a href="#基础控件" class="headerlink" title="基础控件"></a>基础控件</h2><h3 id="Tabbar-控件实现"><a href="#Tabbar-控件实现" class="headerlink" title="Tabbar 控件实现"></a>Tabbar 控件实现</h3><p>Tabbar 页面是常有需求，而在 Flutter 中：<strong>Scaffold、AppBar、Tabbar、TabbarView</strong> 是 Tabbar 页面的最简单实现。</p><p>下面代码为一个 Tabbar Widget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GSYTabBarState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">GSYTabBarWidget</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略非关键代码</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 初始化时创建控制器</span></span><br><span class="line">    <span class="comment">// 通过 with SingleTickerProviderStateMixin 实现动画效果</span></span><br><span class="line">    _tabController = <span class="keyword">new</span> TabController(vsync: <span class="keyword">this</span>, length: _tabItems.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    _tabController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 底部 Tabbar 模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      <span class="comment">// 设置侧边滑出 drawer 不需要可以不设置</span></span><br><span class="line">      drawer: _drawer,</span><br><span class="line">      <span class="comment">// 设置悬浮按键 不需要可以不设置</span></span><br><span class="line">      floatingActionButton: _floatingActionButton,</span><br><span class="line">      <span class="comment">// 标题栏</span></span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        backgroundColor: _backgroundColor,</span><br><span class="line">        title: _title,</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 页面主体 PageView 用于承载 Tab 对应的页面</span></span><br><span class="line">      body: <span class="keyword">new</span> PageView(</span><br><span class="line">        <span class="comment">// 必须有的控制器 与 tabBar 的控制器同步</span></span><br><span class="line">        controller: _pageController,</span><br><span class="line">        <span class="comment">// 每一个 tab 对应的页面主体 是一个 List&lt;Widget&gt;</span></span><br><span class="line">        children: _tabViews,</span><br><span class="line">        onPageChanged: (index) &#123;</span><br><span class="line">          <span class="comment">// 页面触摸作用滑动回调 用于同步 tab 选中状态</span></span><br><span class="line">          _tabController.animateTo(index);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// 底部导航栏 也就是 tab 栏</span></span><br><span class="line">      bottomNavigationBar: <span class="keyword">new</span> Material(</span><br><span class="line">        color: _backgroundColor,</span><br><span class="line">        <span class="comment">// tabbar 控件</span></span><br><span class="line">        child: <span class="keyword">new</span> TabBar(</span><br><span class="line">          <span class="comment">// 必须有的控制器 与 pageView 的控制器同步</span></span><br><span class="line">          controller: _tabController,</span><br><span class="line">          <span class="comment">// 每一个 tab item 是一个 List&lt;Widget&gt;</span></span><br><span class="line">          tabs: _tabItems,</span><br><span class="line">          <span class="comment">// tab 底部选中条颜色</span></span><br><span class="line">          indicatorColor: _indicatorColor,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，这是一个 <em>底部 TabBar</em> 的页面效果。TabBar 和 PageView 之间通过 <code>_pageController</code> 和 <code>_tabController</code> 实现 Tab 和页面的同步，通过 <code>SingleTickerProviderStateMixin</code> 实现 Tab 的动画切换效果：</p><ul><li><p>手动左右滑动 <code>PageView</code> 时，通过 <code>onPageChanged</code> 回调使用 <code>_tabController.animateTo(index);</code> 同步 TabBar 状态。</p></li><li><p><code>_tabItems</code> 中，监听每个 TabBarItem 的点击，通过 <code>_pageController</code> 实现 PageView 的状态同步。</p></li></ul><p>而上面代码还缺少了 TabBarItem 的点击，因为这块被放到了外部实现。当然你也可以直接在内部封装好控件，直接传递配置数据显示，这个可以根据个人需要封装。</p><p>外部调用代码如下：每个 Tabbar 点击时，通过 <code>pageController.jumpTo</code> 跳转页面，每个页面需要跳转坐标为：<strong>当前屏幕大小乘以索引 index</strong>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TabBarBottomPageWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TabBarBottomPageWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> PageController pageController = <span class="keyword">new</span> PageController();</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; tab = [<span class="string">'动态'</span>, <span class="string">'趋势'</span>, <span class="string">'我的'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染底部Tab</span></span><br><span class="line">  _renderTab() &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; list = <span class="keyword">new</span> <span class="built_in">List</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++) &#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> FlatButton(onPressed: () &#123;</span><br><span class="line">        <span class="comment">// 每个 Tabbar 点击时，通过jumpTo 跳转页面</span></span><br><span class="line">        <span class="comment">// 每个页面需要跳转坐标为：当前屏幕大小 * 索引index。</span></span><br><span class="line">        topPageControl.jumpTo(MediaQuery.of(context).size.width * i);</span><br><span class="line">      &#125;, child: <span class="keyword">new</span> Text(</span><br><span class="line">        tab[i],</span><br><span class="line">        maxLines: <span class="number">1</span>,</span><br><span class="line">      )));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染Tab 对应页面</span></span><br><span class="line">  _renderPage() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="keyword">new</span> TabBarPageFirst(),</span><br><span class="line">      <span class="keyword">new</span> TabBarPageSecond(),</span><br><span class="line">      <span class="keyword">new</span> TabBarPageThree(),</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 带 Scaffold 的 Tabbar 页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GSYTabBarWidget(</span><br><span class="line">      type: GSYTabBarWidget.BOTTOM_TAB,</span><br><span class="line">      <span class="comment">// 渲染tab</span></span><br><span class="line">      tabItems: _renderTab(),</span><br><span class="line">      <span class="comment">// 渲染页面</span></span><br><span class="line">      tabViews: _renderPage(),</span><br><span class="line">      topPageControl: pageController,</span><br><span class="line">      backgroundColor: Colors.black45,</span><br><span class="line">      indicatorColor: Colors.white,</span><br><span class="line">      title: <span class="keyword">new</span> Text(<span class="string">"Flutter Demo"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果到此结束，你会发现页面点击切换时，<code>StatefulWidget</code> 的子页面每次都会重新调用 <code>initState</code>。这肯定不是我们想要的，所以这时你就需要 <code>AutomaticKeepAliveClientMixin</code>。</p><p>每个 Tab 对应的 <code>StatefulWidget</code> 的 State ，需要通过 <code>with AutomaticKeepAliveClientMixin</code>，然后重写 <code>@override bool get wantKeepAlive =&gt; true;</code>，就可以实不重新构建的效果。</p><p>既然底部 Tab 页面都实现了，干脆顶部 tab 页面也一起完成。如下代码，和底部 Tab 页的区别在于：</p><ul><li>底部 tab 是放在了 <code>Scaffold</code> 的 <code>bottomNavigationBar</code> 中。</li><li>顶部 tab 是放在 <code>AppBar</code> 的 <code>bottom</code> 中，也就是标题栏之下。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">  <span class="comment">// 设置侧边滑出 drawer，不需要可以不设置</span></span><br><span class="line">  drawer: _drawer,</span><br><span class="line">  <span class="comment">// 设置悬浮按键，不需要可以不设置</span></span><br><span class="line">  floatingActionButton: _floatingActionButton,</span><br><span class="line">  <span class="comment">// 标题栏</span></span><br><span class="line">  appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">    backgroundColor: _backgroundColor,</span><br><span class="line">    title: _title,</span><br><span class="line">    <span class="comment">// tabBar控件</span></span><br><span class="line">    bottom: <span class="keyword">new</span> TabBar(</span><br><span class="line">      <span class="comment">// 顶部时，tabBar为可以滑动的模式</span></span><br><span class="line">      isScrollable: <span class="keyword">true</span>,</span><br><span class="line">      <span class="comment">// 必须有的控制器，与pageView的控制器同步</span></span><br><span class="line">      controller: _tabController,</span><br><span class="line">      <span class="comment">// 每一个tab item，是一个List&lt;Widget&gt;</span></span><br><span class="line">      tabs: _tabItems,</span><br><span class="line">      <span class="comment">// tab底部选中条颜色</span></span><br><span class="line">      indicatorColor: _indicatorColor,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">// 页面主体，PageView，用于承载Tab对应的页面</span></span><br><span class="line">  body: <span class="keyword">new</span> PageView(</span><br><span class="line">    <span class="comment">// 必须有的控制器，与tabBar的控制器同步</span></span><br><span class="line">    controller: _pageController,</span><br><span class="line">    <span class="comment">// 每一个 tab 对应的页面主体，是一个List&lt;Widget&gt;</span></span><br><span class="line">    children: _tabViews,</span><br><span class="line">    <span class="comment">// 页面触摸作用滑动回调，用于同步tab选中状态</span></span><br><span class="line">    onPageChanged: (index) &#123;</span><br><span class="line">      _tabController.animateTo(index);</span><br><span class="line">    &#125;,</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 TabBar 页面中，一般还会出现：<strong>父页面需要控制 PageView 中子页的需求</strong>。这时候就需要用到 <code>GlobalKey</code> 了。比如 <code>GlobalKey&lt;PageOneState&gt; stateOne = new GlobalKey&lt;PageOneState&gt;();</code>，通过 <code>globalKey.currentState</code> 对象，你就可以调用到 <code>PageOneState</code> 中的公开方法。这里需要注意 <code>GlobalKey</code> 需要全局唯一，一般可以在 <code>build</code> 方法中创建。</p><h3 id="上下刷新列表"><a href="#上下刷新列表" class="headerlink" title="上下刷新列表"></a>上下刷新列表</h3><p>毫无争议，必备控件。Flutter 中 为我们提供了 <code>RefreshIndicator</code> 作为内置下拉刷新控件；同时我们通过给 <code>ListView</code> 添加 <code>ScrollController</code> 做滑动监听，在最后增加一个 Item， 作为上滑加载更多的 Loading 显示。</p><p>如下代码所示，通过 <code>RefreshIndicator</code> 控件可以简单完成下拉刷新工作。这里需要注意一点是：<strong>可以利用 <code>GlobalKey&lt;RefreshIndicatorState&gt;</code> 对外提供 <code>RefreshIndicator</code> 的 <code>RefreshIndicatorState</code>，这样外部就 可以通过 <code>GlobalKey</code> 调用 <code>globalKey.currentState.show();</code>，主动显示刷新状态并触发 <code>onRefresh</code></strong> 。</p><p>上拉加载更多在代码中是通过 <code>_getListCount()</code> 方法，在原本的数据基础上，增加实际需要渲染的 item 数量给 ListView 实现的，最后通过 <code>ScrollController</code> 监听到底部，触发 <code>onLoadMore</code>。</p><p>如下代码所示，通过 <code>_getListCount()</code> 方法，还可以配置空页面，头部等常用效果。其实就是<strong>在内部通过改变实际 item 数量与渲染 Item，以实现更多配置效果</strong>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_GSYPullLoadWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">GSYPullLoadWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">  <span class="keyword">final</span> ScrollController _scrollController = <span class="keyword">new</span> ScrollController();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="comment">// 增加滑动监听</span></span><br><span class="line">    _scrollController.addListener(() &#123;</span><br><span class="line">      <span class="comment">// 判断当前滑动位置是不是到达底部，触发加载更多回调</span></span><br><span class="line">      <span class="keyword">if</span> (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.onLoadMore != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.control.needLoadMore) &#123;</span><br><span class="line">          <span class="keyword">this</span>.onLoadMore();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据配置状态返回实际列表数量</span></span><br><span class="line">  <span class="comment">// 实际上这里可以根据你的需要做更多的处理</span></span><br><span class="line">  <span class="comment">// 比如多个头部，是否需要空页面，是否需要显示加载更多。</span></span><br><span class="line">  _getListCount() &#123;</span><br><span class="line">    <span class="comment">// 是否需要头部</span></span><br><span class="line">    <span class="keyword">if</span> (control.needHeader) &#123;</span><br><span class="line">      <span class="comment">// 如果需要头部，用Item 0 的 Widget 作为ListView的头部</span></span><br><span class="line">      <span class="comment">// 列表数量大于0时，因为头部和底部加载更多选项，需要对列表数据总数+2</span></span><br><span class="line">      <span class="keyword">return</span> (control.dataList.length &gt; <span class="number">0</span>) ? control.dataList.length + <span class="number">2</span> : control.dataList.length + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不需要头部，在没有数据时，固定返回数量1用于空页面呈现</span></span><br><span class="line">      <span class="keyword">if</span> (control.dataList.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果有数据,因为不加载更多选项，需要对列表数据总数+1</span></span><br><span class="line">      <span class="keyword">return</span> (control.dataList.length &gt; <span class="number">0</span>) ? control.dataList.length + <span class="number">1</span> : control.dataList.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据配置状态返回实际列表渲染Item</span></span><br><span class="line">  _getItem(<span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!control.needHeader &amp;&amp; index == control.dataList.length &amp;&amp; control.dataList.length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不需要头部，并且数据不为0，当index等于数据长度时，渲染加载更多Item（因为index是从0开始）</span></span><br><span class="line">      <span class="keyword">return</span> _buildProgressIndicator();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (control.needHeader &amp;&amp; index == _getListCount() - <span class="number">1</span> &amp;&amp; control.dataList.length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果需要头部，并且数据不为0，当index等于实际渲染长度 - 1时，渲染加载更多Item（因为index是从0开始）</span></span><br><span class="line">      <span class="keyword">return</span> _buildProgressIndicator();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!control.needHeader &amp;&amp; control.dataList.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不需要头部，并且数据为0，渲染空页面</span></span><br><span class="line">      <span class="keyword">return</span> _buildEmpty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 回调外部正常渲染Item，如果这里有需要，可以直接返回相对位置的index</span></span><br><span class="line">      <span class="keyword">return</span> itemBuilder(context, index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RefreshIndicator(</span><br><span class="line">      <span class="comment">// GlobalKey，用户外部获取RefreshIndicator的State，做显示刷新</span></span><br><span class="line">      key: refreshKey,</span><br><span class="line">      <span class="comment">// 下拉刷新触发，返回的是一个Future</span></span><br><span class="line">      onRefresh: onRefresh,</span><br><span class="line">      child: <span class="keyword">new</span> ListView.builder(</span><br><span class="line">        <span class="comment">// 保持ListView任何情况都能滚动，解决在RefreshIndicator的兼容问题。</span></span><br><span class="line">        physics: <span class="keyword">const</span> AlwaysScrollableScrollPhysics(),</span><br><span class="line">        <span class="comment">// 根据状态返回子孔健</span></span><br><span class="line">        itemBuilder: (context, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> _getItem(index);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 根据状态返回数量</span></span><br><span class="line">        itemCount: _getListCount(),</span><br><span class="line">        <span class="comment">// 滑动监听</span></span><br><span class="line">        controller: _scrollController,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 空页面</span></span><br><span class="line">  Widget _buildEmpty() &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上拉加载更多</span></span><br><span class="line">  Widget _buildProgressIndicator() &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><h3 id="矢量图标库"><a href="#矢量图标库" class="headerlink" title="矢量图标库"></a>矢量图标库</h3><h3 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h3><h2 id="数据模块"><a href="#数据模块" class="headerlink" title="数据模块"></a>数据模块</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础控件&quot;&gt;&lt;a href=&quot;#基础控件&quot; class=&quot;headerlink&quot; title=&quot;基础控件&quot;&gt;&lt;/a&gt;基础控件&lt;/h2&gt;&lt;h3 id=&quot;Tabbar-控件实现&quot;&gt;&lt;a href=&quot;#Tabbar-控件实现&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="flutter" scheme="https://daziweb.github.io/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://daziweb.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 基础</title>
    <link href="https://daziweb.github.io/2019/05/13/flutter/dart%E3%80%81flutter%E5%9F%BA%E7%A1%80/"/>
    <id>https://daziweb.github.io/2019/05/13/flutter/dart、flutter基础/</id>
    <published>2019-05-13T05:59:14.388Z</published>
    <updated>2019-05-14T06:59:52.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dart-语言下的-flutter"><a href="#Dart-语言下的-flutter" class="headerlink" title="Dart 语言下的 flutter"></a>Dart 语言下的 flutter</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>var 可以定义变量，如 <code>var tag = &#39;666&#39;</code>，这和 JavaScript 语言类似，同时 Dart 属于动态类型语言，支持闭包。</p><p>Dart 中 number 类型分为 <code>int</code> 和 <code>double</code>，其中 Java 中的 long 对应的也是 Dart 中的 int 类型。Dart 中没有 float 类型。</p><p>Dart 下只有 bool 类型可以用于 if 等判断，不同于 JavaScript 这种使用方式是不合法的 <code>var g = &#39;null&#39;; if(g) {};</code>。</p><p>Dart 中，switch 支持 String 类型。</p><a id="more"></a><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Dart 不需要给变量设置 <code>setter getter</code> 方法。Dart 中所有的基础类型、类等都继承 Object，默认值是 NULL，自带 getter 和 setter，而如果是 final 或者 const 的话，那么它只有一个 getter 方法。</p><p>Dart 中 final 和 const 表示常量，比如 <code>final name = &#39;GSY&#39;; const value = 10000;</code> 同时 <code>static const</code> 组合代表了静态常量。其中 const 的值在编译期确定，final 的值要到运行时才确定。</p><p>Dart 下的数值，在作为字符串使用时，是需要显式指定的。比如: <code>int i = 0; print(&#39;111&#39; + i);</code> 这样是不支持的，需要 <code>print(&#39;111&#39; + i.toString());</code> 这样使用。<br><strong>所以在使用动态类型时，需要注意不要把 number 类型当做 String 使用。</strong></p><p>Dart 中数组等于列表，所以 <code>var list = [];</code> 和 <code>List list = new List();</code> 可以简单看做一样。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Dart 下 <code>??</code>、<code>??=</code> 属于操作符，如：<code>AA ?? &quot;999&quot;</code> 表示如果 AA 为空，返回 999；<code>AA ??= &quot;999&quot;</code> 表示如果 AA 为空，给 AA 设置成 999。</p><p>Dart 方法可以设置 <em>参数默认值</em> 和 <em>指定名称</em>。比如：<code>getDetail(String userName, resposeName, {branch = &#39;master&#39;}){}</code> 方法，这里 branch 不设置的话，默认是 “master”。<em>参数类型</em> 可以指定或者不指定。调用效果：<code>getRepositoryDetailDao(&#39;aa&#39;, &#39;bb&#39;, branch: &#39;dev&#39;);</code></p><p>Dart 不像 Java，没有关键词 public、private 等修饰符，<code>_</code> 下划线直接代表 private，但是有 <code>@protected</code> 注解。</p><p>Dart 中的构造函数，可以通过如下代码实现的。默认构造方法只能有一个，而通过 <code>Model.empty()</code> 方法可以创建一个空参数的类，其实方法名称随你喜欢。而变量初始化值时，只需要通过 <code>this.name</code> 在构造方法中指定即可：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">String</span> tag;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认构造方法 赋值给 name 和 tag</span></span><br><span class="line">  ModelA(<span class="keyword">this</span>.name, <span class="keyword">this</span>,tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个空的 ModelA</span></span><br><span class="line">  ModelA.empty();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个设置了 name 的 ModelA</span></span><br><span class="line">  ModelA.forName(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p>Flutter 中支持 <code>async</code>/<code>await</code>。这一点和 ES7 很像，如下代码所示，只是定义的位置不同。同时异步操作也和 ES6 中的 <code>Promise</code> 很像，只是 Flutter 中返回的是 <code>Future</code> 对象，通过 <code>then</code> 可以执行下一步。如果返回的还是 <code>Future</code> 便可以 <code>then().then()</code> 的流式操作。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟等待两秒 返回 ok</span></span><br><span class="line">request() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ok'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 'ok' 后 将 'ok' 修改为 'ok from request'</span></span><br><span class="line">doSomeThing() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> data = <span class="keyword">await</span> request();</span><br><span class="line">  data = <span class="string">'ok from request'</span>;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">renderSome() &#123;</span><br><span class="line">  doSomeThing().then((value) &#123;</span><br><span class="line">    <span class="built_in">print</span>(value); <span class="comment">// 输出 'ok from request'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flutter 中一切皆 Widget 呈现，通过 <code>build</code> 方法返回 Widget，这也是和 React Native 中，通过 <code>render</code> 函数返回需要渲染的 component 一样的模式。</p><h2 id="Flutter-Widget"><a href="#Flutter-Widget" class="headerlink" title="Flutter Widget"></a>Flutter Widget</h2><p>在 Flutter 中，一切的显示都是 Widget。Widget 是一切的基础，作为响应式的渲染，属于 MVVM 的实现机制。我们可以通过修改数据，再用 <code>setState</code> 设置数据，Flutter 会自动通过绑定的数据更新 Widget。<strong>所以你需要做的就是实现 Widget 界面，并且和数据绑定起来。</strong></p><p>Widget 分为 <em>有状态</em> 和 <em>无状态</em> 两种，在 Flutter 中每个页面都是一帧。无状态就是保持在那一帧。而有状态的 Widget 当数据更新时，其实是绘制了新的 Widget，只是 State 实现了跨帧的数据同步保存。</p><blockquote><p>这里有个小 Tip，当代码框里输入 <code>stl</code> 的时候，可以自动弹出创建&gt; 无状态控件的模板选项，而输入 <code>stf</code> 的时候，就会弹出创建有状 态 Widget 的模板选项。<br>代码格式化的时候，括号内外的逗号都会影响格式化时换行的位置。</p></blockquote><h3 id="无状态-StatelessWidget"><a href="#无状态-StatelessWidget" class="headerlink" title="无状态 StatelessWidget"></a>无状态 StatelessWidget</h3><p><strong>继承 StatelessWidget，通过 <code>build</code> 方法返回一个布局好的控件。</strong></p><p>Widget 和 Widget 之间通过 <code>child</code> 进行嵌套。其中有的 Widget 只能有一个 child，比如下方的 <code>Container</code>；有的 Widget 可以多个 child，也就是 <code>children</code>，比如 Column 布局。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/meterial.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DEMOWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据可以通过构造方法传递进去</span></span><br><span class="line">  DEMOWidget(<span class="keyword">this</span>.text);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 这里返回你需要的控件</span></span><br><span class="line">    <span class="comment">// 这里末尾有没有的逗号 对于格式化代码而已 是不一样的</span></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.white,</span><br><span class="line">      child: Text(text ?? <span class="string">'这就是无状态 demo'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有状态-StatefulWidget"><a href="#有状态-StatefulWidget" class="headerlink" title="有状态 StatefulWidget"></a>有状态 StatefulWidget</h3><p>你需要创建管理的是主要是 <code>State</code>，通过 State 的 <code>build</code> 方法去构建控件。在 State 中，你可以动态改变数据，这类似 MVVM 实现，在 <code>setState</code> 之后，改变的数据会触发 Widget 重新构建刷新。而下方代码中，是通过延两秒之后，让文本显示为 <em>“这就变了数值”</em>。</p><p>如下代码还可以看出，State 中主要的声明周期有:</p><ul><li>initState: 初始化，理论上只有初始化一次。</li><li>didChangeDependencies: 在 initState 之后调用，此时可以获取其他 State。‘</li><li>dispose: 销毁，只会调用一次。</li></ul><p><strong>你需要的就是在 <code>build</code> 中堆积你的布局，然后把数据添加到 Widget 中，最后通过 <code>setStae</code> 改变数据，从而实现画面变化。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoStateWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  DemoStateWidget(<span class="keyword">this</span>.text);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _DemoStateWidgetState createState() =&gt; _DemoStateWidgetState(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoStateWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DemoStateWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  _DemoStateWidgetState(<span class="keyword">this</span>.text);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        text = <span class="string">'这就变了数值'</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(text ?? <span class="string">'这就是有状态 demo'</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flutter-布局"><a href="#Flutter-布局" class="headerlink" title="Flutter 布局"></a>Flutter 布局</h2><table><thead><tr><th>类型</th><th style="text-align:center">作用特点</th></tr></thead><tbody><tr><td>Container</td><td style="text-align:center">只有一个子 Widget。默认充满，包含了 padding、margin、color、宽高、decoration 等配置。</td></tr><tr><td>Padding</td><td style="text-align:center">只有一个子 Widget。只用于设置 Padding，常用于嵌套 child，给 child 设置 padding。</td></tr><tr><td>Center</td><td style="text-align:center">只有一个子 Widget。只用于居中显示，常用于嵌套 child，给 child 设置居中。</td></tr><tr><td>Stack</td><td style="text-align:center">可以有多个子 Widget。 子 Widget 堆叠在一起。</td></tr><tr><td>Column</td><td style="text-align:center">可以有多个子 Widget。垂直布局。</td></tr><tr><td>Row</td><td style="text-align:center">可以有多个子 Widget。水平布局。</td></tr><tr><td>Expanded</td><td style="text-align:center">只有一个子 Widget。在 Column 和 Row 中充满。</td></tr><tr><td>ListView</td><td style="text-align:center">可以有多个子 Widget。</td></tr></tbody></table><ul><li>Container: 最常用的默认布局。只能包含一个 <code>child</code>，支持配置 <em>padding</em>，<em>margin</em>，<em>color</em>，_宽高_，<em>decoration</em>(一般配置边框和阴影)等配置。在 Flutter 中，不是所有的控件都有 _宽高_、<em>padding</em>、<em>margin</em>、<em>color</em>等属性，所以才会有 Padding、 Center 等 Widget 的存在。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Container(</span><br><span class="line">  margin: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">  height: <span class="number">120.0</span>,</span><br><span class="line">  width: <span class="number">500.0</span>,</span><br><span class="line">  decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">    borderRadius: BorderRadius.all(Radius.circular(<span class="number">4.0</span>)),</span><br><span class="line">    color: Colors.black,</span><br><span class="line">    border: <span class="keyword">new</span> Border.all(</span><br><span class="line">      color: Color(GSYColors.subTextColor),</span><br><span class="line">      width: <span class="number">0.3</span>,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  child: Text(<span class="string">'1111'</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>Column、Row 绝对是必备布局，横竖布局也是日常中最常见的场景。如下方所示，它们常用的有这些属性配置：主轴方向是 start 或 center 等；副轴方向是 start 或 center 等；mainAxisSize 是充满最大尺寸，或者只根据子 Widget 显示最小尺寸。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主轴方向 Column 的竖向 Row 的横向</span></span><br><span class="line">mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line"><span class="comment">// 默认是最大充满 还是根据 child 显示最小大小</span></span><br><span class="line">mainAxisSize: MainAxisSize.max,</span><br><span class="line"><span class="comment">// 副轴方向 Column 的横向 Row 的竖向</span></span><br><span class="line">crossAxisAlignment: CrossAxisAlignment.center,</span><br></pre></td></tr></table></figure><ul><li>Expanded 在 Column 和 Row 中代表着平均充满，当有两个存在的时候默认均分充满。同时页面可以设置 <code>flex</code> 属性决定比例。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Colunm(</span><br><span class="line">  <span class="comment">// 主轴居中 即是竖直向居中</span></span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  <span class="comment">// 大小按照最小显示</span></span><br><span class="line">  mainAxisSize: MainAxisSize.min,</span><br><span class="line">  <span class="comment">// 横向也居中</span></span><br><span class="line">  crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    <span class="comment">// flex 默认为 1</span></span><br><span class="line">    <span class="keyword">new</span> Expanded(</span><br><span class="line">      child: <span class="keyword">new</span> Text(<span class="string">'111'</span>,</span><br><span class="line">        flex: <span class="number">2</span>,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> Expanded(</span><br><span class="line">      child: <span class="keyword">new</span> Text(<span class="string">'222'</span>),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来我们来写一个复杂一些的控件。首先我们创建一个私有方法 <code>_getBottomItem</code>，返回一个 <code>Expanded Widget</code>，因为后面我们需要将这个方法返回的 Widget 在 Row 下平均充满。</p><p>如代码中注释，布局内主要是现实一个居中的 Icon 图标和文本，中间间隔 5.0 的 padding :</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">_getBottomItem(IconData icon, <span class="built_in">String</span> text) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Expanded(</span><br><span class="line">    flex: <span class="number">1</span>,</span><br><span class="line">    child: <span class="keyword">new</span> Center(</span><br><span class="line">      child: <span class="keyword">new</span> Row(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        mainAxisSize : MainAxisSize.max,</span><br><span class="line">        crossAxisAlignment : CrossAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="keyword">new</span> Icon(</span><br><span class="line">            icon,</span><br><span class="line">            size: <span class="number">16.0</span>,</span><br><span class="line">            color: Colors.grey,</span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">new</span> Padding(</span><br><span class="line">            padding: <span class="keyword">new</span> EdgeInsets.only(</span><br><span class="line">              left: <span class="number">5.0</span>,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">new</span> Text(</span><br><span class="line">            text,</span><br><span class="line">            style: <span class="keyword">new</span> TextStyle(</span><br><span class="line">              color: Colors.grey,</span><br><span class="line">              fontSize: <span class="number">14.0</span>,</span><br><span class="line">            ),</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            maxLines: <span class="number">1</span>,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">    child: <span class="keyword">new</span> Card(</span><br><span class="line">      child: <span class="keyword">new</span> FlatButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">'点击事件'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: <span class="keyword">new</span> Padding(</span><br><span class="line">          padding: <span class="keyword">new</span> EdgeInsets.only(</span><br><span class="line">            left: <span class="number">0.0</span>,</span><br><span class="line">            top: <span class="number">10.0</span>,</span><br><span class="line">            right: <span class="number">10.0</span>,</span><br><span class="line">            bottom: <span class="number">10.0</span>,</span><br><span class="line">          ),</span><br><span class="line">          child: <span class="keyword">new</span> Column(</span><br><span class="line">            mainAxisSize: MainAxisSize.min,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              <span class="keyword">new</span> Container(</span><br><span class="line">                child: <span class="keyword">new</span> Text(</span><br><span class="line">                  <span class="string">'这是一点描述'</span>,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                    color: Color(GSYColors.subTextColor),</span><br><span class="line">                    fontSize: <span class="number">14.0</span>,</span><br><span class="line">                  ),</span><br><span class="line">                  maxLines: <span class="number">3</span>,</span><br><span class="line">                  overflow: TextOverflow.ellipsis,</span><br><span class="line">                ),</span><br><span class="line">                margin: <span class="keyword">new</span> EdgeInsets.only(</span><br><span class="line">                  top: <span class="number">6.0</span>,</span><br><span class="line">                  bottom: <span class="number">2.0</span>,</span><br><span class="line">                ),</span><br><span class="line">                alignment: Alignment.topLeft,</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> Padding(</span><br><span class="line">                padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> Row(</span><br><span class="line">                crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  _getBottomItem(Icons.star, <span class="string">'1000'</span>),</span><br><span class="line">                  _getBottomItem(Icons.link, <span class="string">'1000'</span>),</span><br><span class="line">                  _getBottomItem(Icons.subject, <span class="string">'1000'</span>),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flutter-页面"><a href="#Flutter-页面" class="headerlink" title="Flutter 页面"></a>Flutter 页面</h2><table><thead><tr><th>类型</th><th style="text-align:center">作用特点</th></tr></thead><tbody><tr><td>MaterialApp</td><td style="text-align:center">一般作为 APP 顶层的主页入口，可配置主题，多语言，路由等</td></tr><tr><td>Scaffold</td><td style="text-align:center">一般用户页面的承载 Widget，包含 appbar、snackbar、drawer 等 material design 的设定。</td></tr><tr><td>Appbar</td><td style="text-align:center">一般用于 Scaffold 的 appbar ，内有标题，二级页面返回按键等，当然不止这些，tabbar 等也会需要它 。</td></tr><tr><td>Text</td><td style="text-align:center">显示文本，几乎都会用到，主要是通过 style 设置 TextStyle 来设置字体样式等。</td></tr><tr><td>RichText</td><td style="text-align:center">富文本，通过设置 <code>TextSpan</code>，可以拼接出富文本场景。</td></tr><tr><td>TextField</td><td style="text-align:center">文本输入框 ：<code>new TextField(controller: //文本控制器, obscureText: &quot;hint 文本&quot;);</code></td></tr><tr><td>Image</td><td style="text-align:center">图片加载: <code>new FadeInImage.assetNetwork( placeholder: &quot;预览图&quot;, fit: BoxFit.fitWidth, image: &quot;url&quot;);</code></td></tr><tr><td>FlatButton</td><td style="text-align:center">按键点击: <code>new FlatButton(onPressed: () {},child: new Container());</code></td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:gsy_github_app_flutter/test/DemoItem.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _DemoPageState createState() =&gt; _DemoPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">DemoPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">///一个页面的开始</span></span><br><span class="line">    <span class="comment">///如果是新页面，会自带返回按键</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      <span class="comment">///背景样式</span></span><br><span class="line">      backgroundColor: Colors.blue,</span><br><span class="line">      <span class="comment">///标题栏，当然不仅仅是标题栏</span></span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        <span class="comment">///这个title是一个Widget</span></span><br><span class="line">        title: <span class="keyword">new</span> Text(<span class="string">"Title"</span>),</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">///正式的页面开始</span></span><br><span class="line">      <span class="comment">///一个ListView，20个Item</span></span><br><span class="line">      body: <span class="keyword">new</span> ListView.builder(</span><br><span class="line">        itemBuilder: (context, index) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> DemoItem();</span><br><span class="line">        &#125;,</span><br><span class="line">        itemCount: <span class="number">20</span>,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:gsy_github_app_flutter/test/DemoPage.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(<span class="keyword">new</span> DemoApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  DemoApp(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(home: DemoPage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dart-语言下的-flutter&quot;&gt;&lt;a href=&quot;#Dart-语言下的-flutter&quot; class=&quot;headerlink&quot; title=&quot;Dart 语言下的 flutter&quot;&gt;&lt;/a&gt;Dart 语言下的 flutter&lt;/h2&gt;&lt;h3 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h3&gt;&lt;p&gt;var 可以定义变量，如 &lt;code&gt;var tag = &amp;#39;666&amp;#39;&lt;/code&gt;，这和 JavaScript 语言类似，同时 Dart 属于动态类型语言，支持闭包。&lt;/p&gt;
&lt;p&gt;Dart 中 number 类型分为 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt;，其中 Java 中的 long 对应的也是 Dart 中的 int 类型。Dart 中没有 float 类型。&lt;/p&gt;
&lt;p&gt;Dart 下只有 bool 类型可以用于 if 等判断，不同于 JavaScript 这种使用方式是不合法的 &lt;code&gt;var g = &amp;#39;null&amp;#39;; if(g) {};&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Dart 中，switch 支持 String 类型。&lt;/p&gt;
    
    </summary>
    
      <category term="flutter" scheme="https://daziweb.github.io/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://daziweb.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 this、call 和 apply</title>
    <link href="https://daziweb.github.io/2019/05/09/javascript/this%E3%80%81call%E5%92%8Capply/"/>
    <id>https://daziweb.github.io/2019/05/09/javascript/this、call和apply/</id>
    <published>2019-05-09T09:55:04.585Z</published>
    <updated>2019-05-13T05:51:40.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>JavaScript 的 this 指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。</p><h3 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h3><p><code>this</code> 的指向大致可以分为以下 4 种。</p><ul><li>作为对象的方法调用</li><li>作为普通函数调用</li><li>构造器调用</li><li>Function.prototype.call 或 Function.prototype.apply 调用</li></ul><a id="more"></a><h4 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h4><p>当函数作为对象的方法被调用时，this 指向该对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span> === obj); <span class="comment">// 输出 true</span></span><br><span class="line">    alert(<span class="keyword">this</span>.a); <span class="comment">// 输出 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure><h4 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h4><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getName()); <span class="comment">// 输出 golbalName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  name: <span class="string">'sven'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = myObject.getName;</span><br><span class="line"><span class="built_in">console</span>.log(getName()); <span class="comment">// globalName</span></span><br></pre></td></tr></table></figure><p>有时候我们会遇到一些困扰，比如在 <code>div</code> 节点的事件函数内部，有一个局部的 <code>callback</code> 方法， <code>callback</code> 被作为普通函数调用时，<code>callback</code> 内部的 this 指向了 window，但我们往往是想让它指向该 <code>div</code> 节点，见如下代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>我是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.id = <span class="string">'window'</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="keyword">this</span>.id); <span class="comment">// 输出 div1</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="keyword">this</span>.id); <span class="comment">// 输出 window</span></span></span><br><span class="line"><span class="undefined">      &#125;;</span></span><br><span class="line"><span class="undefined">      callback();</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时有一种简单的解决方案，可以用一个变量保存 <code>div</code> 节点的引用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(that.id); <span class="comment">// 输出 div1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  callback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 ES6 的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  alert(<span class="keyword">this</span>); <span class="comment">// 输出 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><h4 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用"></a>构造器调用</h4><p>JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。</p><p>除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外表跟普通函数一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'sevn'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">alert(obj.name); <span class="comment">// sevn</span></span><br></pre></td></tr></table></figure><p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'sevn'</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">'lili'</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">alert(obj.name); <span class="comment">// lili</span></span><br></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'sevn'</span>;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'lili'</span>; <span class="comment">// 返回其他类型的数据 string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">alert(obj.name); <span class="comment">// sevn</span></span><br></pre></td></tr></table></figure><h4 id="Function-prototype-call-或-Function-prototype-apply-调用"><a href="#Function-prototype-call-或-Function-prototype-apply-调用" class="headerlink" title="Function.prototype.call 或 Function.prototype.apply 调用"></a>Function.prototype.call 或 Function.prototype.apply 调用</h4><p>跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'sevn'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'lili'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName()); <span class="comment">// sevn</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName.call(obj2)); <span class="comment">// lili</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.getName.apply(obj2)); <span class="comment">// lili</span></span><br></pre></td></tr></table></figure><p>call 和 apply 方法能很好地体现 JavaScript 的函数式语言特性，在 JavaScript 中，几乎第一次编写函数式语言风格的代码，都离不开 call 和 apply 。在 JavaScript 诸多版本的设计模式中，也用到了 call 和 apply 。</p><h3 id="丢失的-this"><a href="#丢失的-this" class="headerlink" title="丢失的 this"></a>丢失的 this</h3><p>这是一个经常遇到的问题，我们来看下面的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  myName: <span class="string">'lili'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.myName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">// lili</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName2 = obj.getName;</span><br><span class="line"><span class="built_in">console</span>.log(getName2()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>当调用 <code>obj.getName</code> 时，<code>getName</code> 方法是作为 <code>obj</code> 对象的属性被调用的，此时的 this 指向 <strong>obj</strong> 对象，所以 <code>obj.getName()</code> 输出 <code>lili</code> 。</p><p>当用另外一个变量 <code>getName2</code> 来引用 <code>obj.getName</code>，并且调用 <code>getName2</code> 时，此时是普通函数调用方式，this 是指向全局 window 的，所以程序的执行结果是 undefined。</p><p>再看另一个例子，<code>document.getElementById</code> 这个方法名实在有点过长，我们大概尝试过用一个短的函数来代替它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getId = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getId(<span class="string">'div1'</span>);</span><br></pre></td></tr></table></figure><p>我们也许思考过为什么不能用下面这种更简单的方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line">getId(<span class="string">'div1'</span>);</span><br></pre></td></tr></table></figure><p>现在不妨花 1 分钟时间，让这段代码在浏览器中运行一次:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>我是一个 div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span></span><br><span class="line"><span class="javascript">    getId(<span class="string">'div1'</span>);</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在浏览器中执行过后就会发现，这段代码抛出了一个异常。这是因为许多引擎的 <code>document.getElementById</code> 方法的内部实现中需要用到 this 。这个 this 本来被期望指向 document，当 <code>getElementById</code> 方法作为 document 对象的属性被调用时，方法内部的 this 确实是指向 document 的。</p><p>但当用 <code>getId</code> 来引用 <code>document.getElementById</code> 之后，再调用 <code>getId</code>，此时就成了普通函数调用，函数内部的 this 指向了 window，而不是原来的 document。</p><p>我们可以尝试利用 apply 把 document 当作 this 传入 <code>getId</code> 函数，帮助”修正” this :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getELementById = (<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="built_in">document</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="built_in">document</span>.getElementById);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="keyword">var</span> div = getId(<span class="string">'div1'</span>);</span><br><span class="line"></span><br><span class="line">alert(div.id); <span class="comment">// div1</span></span><br></pre></td></tr></table></figure><h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h2><p>ECMAScript 3 给 Function 的原型定义了两个方法，它们是 Function.prototype.call 和 Function.prototype.apply。在实际开发中，特别是在一些函数式风格的代码编写中，call 和 apply 方法尤为有用。在 JavaScript 版本的设计模式中，这两个方法的应用也非常广泛，能熟练运用这两个方法，是我们真正成为一句 JavaScript 程序员的重要一步。</p><h3 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h3><p>Function.prototype.call 和 Function.prototype.apply 都是非常常用的方法。它们的作用是一样的，区别仅在于传入参数形式的不同。</p><p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  alert([a, b, c]); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>在这段代码中，参数 1，2，3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列表中的 a、b、c。</p><p>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  alert([a, b, c]); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript 的参数在内部就是用一个数组来表示的。从这个意义上说，apply 比 call 的使用率更高，我们不必关心具体有多少参数被传入函数，只要用 apply 一股脑地推过去就可以了。</p><p>call 是包装在 apply 上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call 来传送参数。</p><p>当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// 输出 true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>但如果是在严格格式下，函数体内的 this 还是为 null :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="literal">null</span>); <span class="comment">// 输出 true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>我们有时候使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure><h3 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h3><p>能够熟练使用 call 和 apply，是我们真正成为一名 JavaScript 程序员的重要一步。</p><h4 id="改变-this-指向"><a href="#改变-this-指向" class="headerlink" title="改变 this 指向"></a>改变 this 指向</h4><p>call 和 apply 最常见的用途是改变函数内部的 this 指向，我们来看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'sevn'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'lili'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getName(); <span class="comment">// 输出 window</span></span><br><span class="line">getName.call(obj1); <span class="comment">// 输出 sevn</span></span><br><span class="line">getName.call(obj2); <span class="comment">// 输出 lili</span></span><br></pre></td></tr></table></figure><p>当执行 <code>getName.call(obj1)</code> 这句代码时，getName 函数体内的 this 就指向 obj2 对象，所以此处的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际相当于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(obj1.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在实际开发中，经常会遇到 this 指向被不经意改变的场景，比如有一个 div 节点， div 节点的 onclick 事件中的 this 本来是指向这个 div 的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假如该事件函数中有一个内部函数 func，在事件内部调用 func 函数时，func 函数体内的 this 就指向了 window，而不是我们预期的 div，见如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id); <span class="comment">// 输出 div1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id); <span class="comment">// 输出 undefined</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  func();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候我们用 call 来修正 func 函数内的 this，使其依然指向 div:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id); <span class="comment">// 输出 div1</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  func.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 call 来修正 this 的场景，我们并非第一次遇到，我们曾经修正过 document.getElementById 函数内部 “丢失” 的 this，代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="built_in">document</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="built_in">document</span>.getElementById);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</span><br><span class="line"><span class="keyword">var</span> div = getId(<span class="string">'div1'</span>);</span><br><span class="line">alert(div.id); <span class="comment">// 输出 div1</span></span><br></pre></td></tr></table></figure><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h3><p>大部分高级浏览器都实现了内置的 Function.prototype.bind，用来指定函数内部的 this 指向，即使没有原生的 Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 保存原函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个新的函数</span></span><br><span class="line">    <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>); <span class="comment">// 执行新的函数的时候 会把之前传入的 context 当作新函数体内的 this</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'lili'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name); <span class="comment">// 输出 lili</span></span><br><span class="line">&#125;.bind(obj);</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>我们通过 Function.prototype.bind 来 “包装” func 函数，并且传入一个对象 context 当作参数，这个 context 对象就是我们想修正的 this 对象。</p><p>在 Function.prototype.bind 的内部实现中，我们先把 func 函数的引用保存起来，然后返回一个新的函数。当我们在将来执行 func 函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，<code>self.apply(context, arguments)</code> 这句代码才是执行原来的 func 函数，并且指定 context 对象为 func 函数体内的 this。</p><p>这是一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一点，使得可以往 func 函数中预先填入一些参数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>, <span class="comment">// 保存原函数</span></span><br><span class="line">    context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 需要绑定的 this 上下文</span></span><br><span class="line">    args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// 剩余的参数转成数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个新的函数</span></span><br><span class="line">    <span class="keyword">return</span> self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    <span class="comment">// 执行新的函数的时候 会把之前传入的 context 当作新函数体内的 this</span></span><br><span class="line">    <span class="comment">// 并且组合两次分别传入的参数 作为新函数的参数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'lili'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name); <span class="comment">// 输出 lili</span></span><br><span class="line">  alert([a, b, c, d]); <span class="comment">// 输出 [1, 2, 3, 4]</span></span><br><span class="line">&#125;.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="headerlink" title="借用其他对象的方法"></a>借用其他对象的方法</h3><p>在 JavaScript 中也存在类似的借用对象。</p><p>借用方法的第一种场景是”借用构造函数”，通过这种技术，可以实现一些类似继承的效果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">'lili'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.getName()); <span class="comment">// 输出 lili</span></span><br></pre></td></tr></table></figure><p>借用方法的第二种运用场景跟我们的关系更加密切。</p><p>函数的参数列表 arguments 是一个类数组对象，虽然它也有”下标”，但它并非真正的数组，所以也不能像数组一样，进行排序或者往集合里添加一个新的元素。在这种情况下，我们常常常常会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用 Array.prototype.push :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// 输出 [1 2 3]</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;p&gt;JavaScript 的 this 指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。&lt;/p&gt;
&lt;h3 id=&quot;this-的指向&quot;&gt;&lt;a href=&quot;#this-的指向&quot; class=&quot;headerlink&quot; title=&quot;this 的指向&quot;&gt;&lt;/a&gt;this 的指向&lt;/h3&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 的指向大致可以分为以下 4 种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为对象的方法调用&lt;/li&gt;
&lt;li&gt;作为普通函数调用&lt;/li&gt;
&lt;li&gt;构造器调用&lt;/li&gt;
&lt;li&gt;Function.prototype.call 或 Function.prototype.apply 调用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://daziweb.github.io/categories/javascript/"/>
    
    
      <category term="this, call, apply" scheme="https://daziweb.github.io/tags/this-call-apply/"/>
    
  </entry>
  
  <entry>
    <title>mongodb 常用语法教程</title>
    <link href="https://daziweb.github.io/2019/04/17/mongodb/mongodb%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/"/>
    <id>https://daziweb.github.io/2019/04/17/mongodb/mongodb 常用语法教程/</id>
    <published>2019-04-17T01:35:58.281Z</published>
    <updated>2019-04-17T03:26:25.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>MongoDB use DATABASE_NAME 用于创建数据库。该命令如果数据库不存在，将创建一个新的数据库， 否则将返回现有的数据库。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>use DATABASE语句的基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use DATABASE_NAME</span><br></pre></td></tr></table></figure><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><p>如果想创建一个数据库名称为 <strong>\<mydb></mydb></strong>， 那么 <strong>use DATABASE</strong> 语句应该如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br></pre></td></tr></table></figure><p>要检查当前选择的数据库使用命令 <strong>db</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db</span><br><span class="line">mydb</span><br></pre></td></tr></table></figure><p>如果想查询数据库列表，那么使用命令 <strong>show dbs</strong>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;show dbs</span><br><span class="line">local     <span class="number">0.78125</span>GB</span><br><span class="line">test      <span class="number">0.23012</span>GB</span><br></pre></td></tr></table></figure><p>所创建的数据库（mydb）不存在于列表中。要显示的数据库，需要至少插入一个文档进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.movie.insert(&#123;<span class="string">"name"</span>:<span class="string">"yiibai tutorials"</span>&#125;)</span><br><span class="line">&gt;show dbs</span><br><span class="line">local      <span class="number">0.78125</span>GB</span><br><span class="line">mydb       <span class="number">0.23012</span>GB</span><br><span class="line">test       <span class="number">0.23012</span>GB</span><br></pre></td></tr></table></figure><p><strong>MongoDB的默认数据库是test。 如果没有创建任何数据库，那么集合将被保存在测试数据库。</strong></p><a id="more"></a><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>MongoDB db.dropDatabase() 命令用于删除现有的数据库。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>dropDatabase()指令的基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><p>这将删除选定的数据库。如果没有选择任何数据库，那么它会删除默认的“test”数据库</p><h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><p>如果想删除新的数据库 <strong>\<mydb></mydb></strong>, 那么 <strong>dropDatabase()</strong> 命令将如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line">&gt;db.dropDatabase()</span><br><span class="line">&gt;&#123; <span class="string">"dropped"</span> : <span class="string">"mydb"</span>, <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>MongoDB 的 db.createCollection(name, options) 用于创建集合。 在命令中, name 是要创建集合的名称。 Options 是一个文档，用于指定集合的配置</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Name</td><td>String</td><td>要创建的集合的名称</td></tr><tr><td>OPtions</td><td>Document</td><td>（可选）指定有关内存大小和索引选项</td></tr></tbody></table><p>选项参数是可选的，所以需要指定集合的唯一名字。</p><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><p>createCollection()方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt;db.createCollection(<span class="string">"mycollection"</span>)</span><br><span class="line">&#123; <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>可以通过使用 <strong>show collections</strong> 命令来检查创建的集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;show collections</span><br><span class="line">mycollection</span><br><span class="line">system.indexes</span><br></pre></td></tr></table></figure><h5 id="选项列表"><a href="#选项列表" class="headerlink" title="选项列表"></a>选项列表</h5><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>capped</td><td>Boolean</td><td>（可选）如果为true，它启用上限集合。上限集合是一个固定大小的集合，当它达到其最大尺寸会自动覆盖最老的条目。 如果指定true，则还需要指定参数的大小。</td></tr><tr><td>autoIndexID</td><td>Boolean</td><td>（可选）如果为true，自动创建索引_id字段。默认的值是 false.</td></tr><tr><td>size</td><td>number</td><td>（可选）指定的上限集合字节的最大尺寸。如果capped 是true，那么还需要指定这个字段。</td></tr><tr><td>max</td><td>number</td><td>（可选）指定上限集合允许的最大文件数。</td></tr></tbody></table><p>尽管插入文档，MongoDB首先检查字段集合的上限大小，那么它会检查最大字段。</p><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法:"></a>语法:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.createCollection(<span class="string">"mycol"</span>, &#123; <span class="attr">capped</span> : <span class="literal">true</span>, <span class="attr">autoIndexID</span> : <span class="literal">true</span>, <span class="attr">size</span> : <span class="number">6142800</span>, <span class="attr">max</span> : <span class="number">10000</span> &#125; )</span><br><span class="line">&#123; <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>在MongoDB中并不需要创建集合。 当插入一些文档 MongoDB 会自动创建集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.yiibai.insert(&#123;<span class="string">"name"</span> : <span class="string">"yiibai"</span>&#125;)</span><br><span class="line">&gt;show collections</span><br><span class="line">mycol</span><br><span class="line">mycollection</span><br><span class="line">system.indexes</span><br><span class="line">yiibai</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><p>MongoDB 的 db.collection.drop() 用于从数据库中删除集合。</p><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><p>drop() 命令的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.COLLECTION_NAME.drop()</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 例子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面给出的例子将删除给定名称的集合：**mycollection**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line">&gt;db.mycollection.drop()</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><p>将数据插入到MongoDB集合，需要使用MongoDB 的 insert() 方法。</p><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><p>insert()命令的基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.insert(<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.insert(&#123;</span><br><span class="line">   _id: ObjectId(<span class="number">7</span>df78ad8902c),</span><br><span class="line">   title: <span class="string">'MongoDB Overview'</span>, </span><br><span class="line">   description: <span class="string">'MongoDB is no sql database'</span>,</span><br><span class="line">   by: <span class="string">'yiibai tutorials'</span>,</span><br><span class="line">   url: <span class="string">'http://www.yiibai.com'</span>,</span><br><span class="line">   tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   likes: <span class="number">100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里 mycol 是我们的集合名称，它是在之前的教程中创建。如果集合不存在于数据库中，那么MongoDB创建此集合，然后插入文档进去。</p><p>在如果我们不指定_id参数插入的文档，那么 MongoDB 将为文档分配一个唯一的ObjectId。</p><p>_id 是12个字节十六进制数在一个集合的每个文档是唯一的。 12个字节被划分如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_id: ObjectId(<span class="number">4</span> bytes timestamp, <span class="number">3</span> bytes machine id, <span class="number">2</span> bytes process id, <span class="number">3</span> bytes incrementer)</span><br></pre></td></tr></table></figure><p>要以单个查询插入多个文档，可以通过文档 insert() 命令的数组方式。</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.post.insert([</span><br><span class="line">&#123;</span><br><span class="line">   title: <span class="string">'MongoDB Overview'</span>, </span><br><span class="line">   description: <span class="string">'MongoDB is no sql database'</span>,</span><br><span class="line">   by: <span class="string">'yiibai tutorials'</span>,</span><br><span class="line">   url: <span class="string">'http://www.yiibai.com'</span>,</span><br><span class="line">   tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   likes: <span class="number">100</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   title: <span class="string">'NoSQL Database'</span>, </span><br><span class="line">   description: <span class="string">'NoSQL database doesn'</span>t have tables<span class="string">',</span></span><br><span class="line"><span class="string">   by: '</span>yiibai tutorials<span class="string">',</span></span><br><span class="line"><span class="string">   url: '</span>http:<span class="comment">//www.yiibai.com',</span></span><br><span class="line">   tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   likes: <span class="number">20</span>, </span><br><span class="line">   comments: [</span><br><span class="line">      &#123;</span><br><span class="line">         user:<span class="string">'user1'</span>,</span><br><span class="line">         message: <span class="string">'My first comment'</span>,</span><br><span class="line">         dateCreated: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">35</span>),</span><br><span class="line">         like: <span class="number">0</span> </span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>要从集合查询MongoDB数据，需要使用MongoDB的 find()方法。</p><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><p>find()方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.find()</span><br></pre></td></tr></table></figure><p>find() 方法将在非结构化的方式显示所有的文件。 如果显示结果是格式化的，那么可以用pretty() 方法。</p><h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find().pretty()</span><br></pre></td></tr></table></figure><h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_id"</span>: ObjectId(<span class="number">7</span>df78ad8902c),</span><br><span class="line">   <span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>, </span><br><span class="line">   <span class="string">"description"</span>: <span class="string">"MongoDB is no sql database"</span>,</span><br><span class="line">   <span class="string">"by"</span>: <span class="string">"yiibai tutorials"</span>,</span><br><span class="line">   <span class="string">"url"</span>: <span class="string">"http://www.yiibai.com"</span>,</span><br><span class="line">   <span class="string">"tags"</span>: [<span class="string">"mongodb"</span>, <span class="string">"database"</span>, <span class="string">"NoSQL"</span>],</span><br><span class="line">   <span class="string">"likes"</span>: <span class="string">"100"</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>除了find()方法还有findOne()方法，仅返回一个文档。</p><h5 id="RDBMS-Where子句等效于MongoDB"><a href="#RDBMS-Where子句等效于MongoDB" class="headerlink" title="RDBMS Where子句等效于MongoDB"></a>RDBMS Where子句等效于MongoDB</h5><p>查询文档在一些条件的基础上，可以使用下面的操作</p><table><thead><tr><th>操作</th><th>语法</th><th>示例</th><th>RDBMS等效语句</th></tr></thead><tbody><tr><td>Equality</td><td>{<key>:<value>}</value></key></td><td>db.mycol.find({“by”:”yiibai tutorials”}).pretty()</td><td>where by 等于 ‘yiibai tutorials’</td></tr><tr><td>Less Than</td><td><key>:{$lt:<value>}}</value></key></td><td>db.mycol.find({“likes”:{$lt:50}}).pretty()</td><td>where likes 小于 50</td></tr><tr><td>Less Than Equals</td><td>{<key>:{$lte:<value>}}</value></key></td><td>db.mycol.find({“likes”:{$lte:50}}).pretty()</td><td>where likes 小于等于 50</td></tr><tr><td>Greater Than</td><td>{<key>:{$gt:<value>}}</value></key></td><td>db.mycol.find({“likes”:{$gt:50}}).pretty()</td><td>where likes 大于 50</td></tr><tr><td>Greater Than Equals</td><td>{<key>:{$gte:<value>}}</value></key></td><td>db.mycol.find({“likes”:{$gte:50}}).pretty()</td><td>where likes 大于等于 50</td></tr><tr><td>Not Equals</td><td>{<key>:{$ne:<value>}}</value></key></td><td>db.mycol.find({“likes”:{$ne:50}}).pretty()</td><td>where likes 不等于 50</td></tr></tbody></table><h5 id="AND-在-MongoDB"><a href="#AND-在-MongoDB" class="headerlink" title="AND 在 MongoDB"></a>AND 在 MongoDB</h5><h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><p>在 find()方法，如果您传递多个键通过”,”将它们分开，那么MongoDB对待它就如AND条件一样。基本语法如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;<span class="attr">key1</span>:value1, <span class="attr">key2</span>:value2&#125;).pretty()</span><br></pre></td></tr></table></figure><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子将显示所有教程含“yiibai tutorials”和其标题是“MongoDB Overview”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;<span class="string">"by"</span>:<span class="string">"yiibai tutorials"</span>,<span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_id"</span>: ObjectId(<span class="number">7</span>df78ad8902c),</span><br><span class="line">   <span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>, </span><br><span class="line">   <span class="string">"description"</span>: <span class="string">"MongoDB is no sql database"</span>,</span><br><span class="line">   <span class="string">"by"</span>: <span class="string">"yiibai tutorials"</span>,</span><br><span class="line">   <span class="string">"url"</span>: <span class="string">"http://www.yiibai.com"</span>,</span><br><span class="line">   <span class="string">"tags"</span>: [<span class="string">"mongodb"</span>, <span class="string">"database"</span>, <span class="string">"NoSQL"</span>],</span><br><span class="line">   <span class="string">"likes"</span>: <span class="string">"100"</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>对于上面给出的例子相当于where子句：’ where by=’yiibai tutorials’ AND title=’MongoDB Overview’ ‘。可以传递任何数目的键-值对在find子句。</p><h5 id="OR-在-MongoDB"><a href="#OR-在-MongoDB" class="headerlink" title="OR 在 MongoDB"></a>OR 在 MongoDB</h5><h5 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h5><p>要查询基于OR条件的文件，需要使用$or关键字。OR的基本语法如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">     &#123;<span class="attr">key1</span>: value1&#125;, &#123;<span class="attr">key2</span>:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子将显示所有撰写含有 ‘yiibai tutorials’ 或是标题为 ‘MongoDB Overview’ 的教程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;<span class="attr">$or</span>:[&#123;<span class="string">"by"</span>:<span class="string">"tutorials point"</span>&#125;,&#123;<span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_id"</span>: ObjectId(<span class="number">7</span>df78ad8902c),</span><br><span class="line">   <span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>, </span><br><span class="line">   <span class="string">"description"</span>: <span class="string">"MongoDB is no sql database"</span>,</span><br><span class="line">   <span class="string">"by"</span>: <span class="string">"yiibai tutorials"</span>,</span><br><span class="line">   <span class="string">"url"</span>: <span class="string">"http://www.yiibai.com"</span>,</span><br><span class="line">   <span class="string">"tags"</span>: [<span class="string">"mongodb"</span>, <span class="string">"database"</span>, <span class="string">"NoSQL"</span>],</span><br><span class="line">   <span class="string">"likes"</span>: <span class="string">"100"</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h5 id="使用-AND-和-OR-在一起"><a href="#使用-AND-和-OR-在一起" class="headerlink" title="使用 AND 和 OR 在一起"></a>使用 AND 和 OR 在一起</h5><h5 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子显示有喜欢数大于100 的文档，其标题要么是 ‘MongoDB Overview’ 或 ‘yiibai tutorials’. 等效于SQL的where子句：<strong>‘where likes&gt;10 AND (by = ‘yiibai tutorials’ OR title = ‘MongoDB Overview’)’</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(<span class="string">"likes"</span>: &#123;<span class="attr">$gt</span>:<span class="number">10</span>&#125;, <span class="attr">$or</span>: [&#123;<span class="string">"by"</span>: <span class="string">"yiibai tutorials"</span>&#125;, &#123;<span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>&#125;] &#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"_id"</span>: ObjectId(<span class="number">7</span>df78ad8902c),</span><br><span class="line">   <span class="string">"title"</span>: <span class="string">"MongoDB Overview"</span>, </span><br><span class="line">   <span class="string">"description"</span>: <span class="string">"MongoDB is no sql database"</span>,</span><br><span class="line">   <span class="string">"by"</span>: <span class="string">"yiibai tutorials"</span>,</span><br><span class="line">   <span class="string">"url"</span>: <span class="string">"http://www.yiibai.com"</span>,</span><br><span class="line">   <span class="string">"tags"</span>: [<span class="string">"mongodb"</span>, <span class="string">"database"</span>, <span class="string">"NoSQL"</span>],</span><br><span class="line">   <span class="string">"likes"</span>: <span class="string">"100"</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><p>MongoDB的update()和save()方法用于更新文档到一个集合。 update()方法将现有的文档中的值更新，而save()方法使用传递到save()方法的文档替换现有的文档。</p><h5 id="MongoDB-Update-方法"><a href="#MongoDB-Update-方法" class="headerlink" title="MongoDB Update() 方法"></a>MongoDB Update() 方法</h5><h5 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h5><p>update()方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA)</span><br></pre></td></tr></table></figure><h5 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h5><p>考虑mycol集合有如下数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec5), <span class="string">"title"</span>:<span class="string">"MongoDB Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec6), <span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Yiibai Overview"</span>&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将设置其标题“MongoDB Overview”的文件为新标题为“New MongoDB Tutorial”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.update(&#123;<span class="string">'title'</span>:<span class="string">'MongoDB Overview'</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="string">'title'</span>:<span class="string">'New MongoDB Tutorial'</span>&#125;&#125;)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec5), <span class="string">"title"</span>:<span class="string">"New MongoDB Tutorial"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec6), <span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Tutorial Overview"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，MongoDB将只更新单一文件，更新多，需要一个参数 ‘multi’ 设置为 true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.update(&#123;<span class="string">'title'</span>:<span class="string">'MongoDB Overview'</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="string">'title'</span>:<span class="string">'New MongoDB Tutorial'</span>&#125;&#125;,&#123;<span class="attr">multi</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="MongoDB-Save-方法"><a href="#MongoDB-Save-方法" class="headerlink" title="MongoDB Save() 方法"></a>MongoDB Save() 方法</h5><p>save() 方法取代，通过新文档到 save()方法</p><h5 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h5><p>mongodb 的 save()方法如下所示的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.save(&#123;<span class="attr">_id</span>:ObjectId(),NEW_DATA&#125;)</span><br></pre></td></tr></table></figure><h5 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h5><p>下面的例子将替换该文件_id ‘5983548781331adf45ec7’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.save(</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Yiibai New Topic"</span>, <span class="string">"by"</span>:<span class="string">"Yiibai Yiibai"</span></span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec5), <span class="string">"title"</span>:<span class="string">"Yiibai Yiibai New Topic"</span>, <span class="string">"by"</span>:<span class="string">"Yiibai Yiibai"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec6), <span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Yiibai Overview"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>MongoDB 的 <strong>remove()</strong>方法用于从集合中删除文档。remove()方法接受两个参数。一个是标准缺失，第二是justOne标志</p><ul><li><strong>deletion criteria</strong> : 根据文件（可选）删除条件将被删除。</li><li><strong>justOne</strong> : （可选）如果设置为true或1，然后取出只有一个文档。</li></ul><h5 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h5><p><strong>remove()</strong>方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)</span><br></pre></td></tr></table></figure><h5 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h5><p>考虑mycol集合有如下数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec5), <span class="string">"title"</span>:<span class="string">"MongoDB Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec6), <span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Yiibai Overview"</span>&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将删除所有的文件，其标题为 ‘MongoDB Overview’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.remove(&#123;<span class="string">'title'</span>:<span class="string">'MongoDB Overview'</span>&#125;)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec6), <span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Toturials Overview"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h5 id="只删除一个"><a href="#只删除一个" class="headerlink" title="只删除一个"></a>只删除一个</h5><p>如果有多个记录，并要删除仅第一条记录，然后在 remove()方法设置参数 justOne 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="删除所有文件"><a href="#删除所有文件" class="headerlink" title="删除所有文件"></a>删除所有文件</h5><p>如果没有指定删除条件，则MongoDB将从集合中删除整个文件。这相当于SQL的 truncate 命令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.remove()</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h2 id="MongoDB投影"><a href="#MongoDB投影" class="headerlink" title="MongoDB投影"></a>MongoDB投影</h2><p>mongodb投影意义是只选择需要的数据，而不是选择整个一个文档的数据。如果一个文档有5个字段，只需要显示3个，只从中选择3个字段。</p><p>MongoDB的find()方法，解释了MongoDB中查询文档接收的第二个可选的参数是要检索的字段列表。在MongoDB中，当执行find()方法，那么它会显示一个文档的所有字段。要限制这一点，需要设置字段列表值为1或0。1是用来显示字段，而0被用来隐藏字段。</p><h5 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h5><p>find()方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.find(&#123;&#125;,&#123;<span class="attr">KEY</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="例子-9"><a href="#例子-9" class="headerlink" title="例子"></a>例子</h5><p>考虑集合 <strong>myycol</strong> 有下列数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec5), <span class="string">"title"</span>:<span class="string">"MongoDB Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec6), <span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Yiibai Overview"</span>&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将显示文档的标题，在查询文档时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;<span class="string">"title"</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;)</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"MongoDB Overview"</span>&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"Yiibai Yiibai Overview"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>请注意在执行find()方法时_id字段始终显示，如果不想要显示这个字段，那么需要将其设置为0</strong></p><h2 id="限制文档"><a href="#限制文档" class="headerlink" title="限制文档"></a>限制文档</h2><h5 id="MongoDB-Limit-方法"><a href="#MongoDB-Limit-方法" class="headerlink" title="MongoDB Limit() 方法"></a>MongoDB Limit() 方法</h5><p>要在MongoDB中限制记录，需要使用limit()方法。 limit() 方法接受一个数字类型的参数，这是要显示的文档数量。</p><h5 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h5><p>limit()方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.find().limit(NUMBER)</span><br></pre></td></tr></table></figure><h5 id="例子-10"><a href="#例子-10" class="headerlink" title="例子"></a>例子</h5><p>考虑集合 myycol 有下列数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec5), <span class="string">"title"</span>:<span class="string">"MongoDB Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec6), <span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Yiibai Overview"</span>&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将只显示2个文档，在查询文档时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;<span class="string">"title"</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;).limit(<span class="number">2</span>)</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"MongoDB Overview"</span>&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>如果不指定 <strong>limit()</strong> 方法的参数数量，然后它会显示集合中的所有文档。</p><h5 id="MongoDB-Skip-方法"><a href="#MongoDB-Skip-方法" class="headerlink" title="MongoDB Skip() 方法"></a>MongoDB Skip() 方法</h5><p>除了 <strong>limit()</strong> 方法还有一个方法 <strong>skip()</strong> 也接受数字类型参数并用于跳过文件数。</p><h5 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h5><p>skip() 方法的基础语法如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure><h5 id="例子-11"><a href="#例子-11" class="headerlink" title="例子"></a>例子</h5><p>下面的例子将仅显示第二个文档。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;<span class="string">"title"</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;).limit(<span class="number">1</span>).skip(<span class="number">1</span>)</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>请注意，skip() 方法的默认值是 0</strong></p><h2 id="文档排序"><a href="#文档排序" class="headerlink" title="文档排序"></a>文档排序</h2><p>要排序MongoDB中的文档，需要使用 sort()方法。 sort() 方法接受一个包含字段列表以及排序顺序的文档。 要使用1和-1指定排序顺序。1用于升序，而-1是用于降序。</p><h5 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h5><p>sort()方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.find().sort(&#123;<span class="attr">KEY</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="例子-12"><a href="#例子-12" class="headerlink" title="例子"></a>例子</h5><p>考虑集合 myycol 有如下数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec5), <span class="string">"title"</span>:<span class="string">"MongoDB Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec6), <span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="number">5983548781331</span>adf45ec7), <span class="string">"title"</span>:<span class="string">"Yiibai Yiibai Overview"</span>&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将显示的文件排序按标题降序排序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;<span class="string">"title"</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;).sort(&#123;<span class="string">"title"</span>:<span class="number">-1</span>&#125;)</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"Yiibai Yiibai Overview"</span>&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"NoSQL Overview"</span>&#125;</span><br><span class="line">&#123;<span class="string">"title"</span>:<span class="string">"MongoDB Overview"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>请注意，如果不指定排序类型，那么 sort() 方法将以升序排列文档。</strong></p><h2 id="MongoDB索引"><a href="#MongoDB索引" class="headerlink" title="MongoDB索引"></a>MongoDB索引</h2><p>索引支持查询高效率执行。如果没有索引，MongoDB必须扫描集合中的每一个文档，然后选择那些符合查询语句的文档。若需要 mongod 来处理大量数据，扫描是非常低效的。</p><p>索引是特殊的数据结构，存储在一个易于设置遍历形式的数据的一小部分。索引存储在索引中指定特定字段的值或一组字段，并排序字段的值。</p><p>要创建索引，需要使用MongoDB的ensureIndex()方法。</p><h5 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h5><p>ensureIndex()方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.ensureIndex(&#123;<span class="attr">KEY</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>这里键是要创建索引字段，1是按名称升序排序。若以按降序创建索引，需要使用 -1.</p><h5 id="例子-13"><a href="#例子-13" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.ensureIndex(&#123;<span class="string">"title"</span>:<span class="number">1</span>&#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>在 ensureIndex()方法，可以通过多个字段，来创建多个字段索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.ensureIndex(&#123;<span class="string">"title"</span>:<span class="number">1</span>,<span class="string">"description"</span>:<span class="number">-1</span>&#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>ensureIndex()</strong> 方法还接受选项列表（这是可选），其列表如下：</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>background</td><td>Boolean</td><td>构建索引在后台以便建立索引不阻止其它数据库活动。指定true时建立在后台。缺省值是false.</td></tr><tr><td>unique</td><td>Boolean</td><td>创建一个唯一的索引，以使集合将不接受插入的的文档，其中的索引关键字或键匹配索引的现有值。指定true以创建唯一索引。缺省值是 false.</td></tr><tr><td>name</td><td>string</td><td>索引的名称。如果未指定，MongoDB通过连接索引的字段和排序顺序的名称生成一个索引名。</td></tr><tr><td>dropDups</td><td>Boolean</td><td>创建一个字段唯一索引时可能会有重复。MongoDB索引键仅第一次出现，并从集合中删除包含该键后续出现的所有文档。指定true以创建唯一索引。缺省值是 false.</td></tr><tr><td>sparse</td><td>Boolean</td><td>如果为true，索引只引用与指定的字段的文档。这些索引使用更少的空间，但在某些情况下表现不同（特别是排序）。缺省值是 false.</td></tr><tr><td>expireAfterSeconds</td><td>integer</td><td>指定的值，以秒为单位，作为一个TTL控制MongoDB保留在此集合文件多久。</td></tr><tr><td>v</td><td>index version</td><td>索引版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td></tr><tr><td>weights</td><td>document</td><td>重量（weight ）是一个数字，它是从1至99,999的数字，表示字段相对于其它索引字段在得分方面的意义。</td></tr><tr><td>default_language</td><td>string</td><td>对于文本索引，并为词干分析器和标记生成器列表中的语言决定了停用词和规则。它的默认值： english.</td></tr><tr><td>language_override</td><td>string</td><td>对于一个文本索引，包含在文档中指定字段的名称，语言来覆盖默认语言。它的默认值：language.</td></tr></tbody></table><h2 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h2><p>聚合操作处理数据记录并返回计算结果。从多个文档聚合分组操作数值，并可以执行多种对分组数据业务返回一个结果。 在SQL中的count(*)，使用group by 与mongodb的聚合是等效的。 对于MongoDB的聚合，使用的是aggregate()方法。</p><h5 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h5><p>aggregate()方法的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</span><br></pre></td></tr></table></figure><h5 id="例子-14"><a href="#例子-14" class="headerlink" title="例子"></a>例子</h5><p>在集合中有以下数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(<span class="number">7</span>df78ad8902c)</span><br><span class="line">   title: <span class="string">'MongoDB Overview'</span>, </span><br><span class="line">   description: <span class="string">'MongoDB is no sql database'</span>,</span><br><span class="line">   by_user: <span class="string">'Yiibai Yiibai '</span>,</span><br><span class="line">   url: <span class="string">'http://www.yiibai.com'</span>,</span><br><span class="line">   tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   likes: <span class="number">100</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(<span class="number">7</span>df78ad8902d)</span><br><span class="line">   title: <span class="string">'NoSQL Overview'</span>, </span><br><span class="line">   description: <span class="string">'No sql database is very fast'</span>,</span><br><span class="line">   by_user: <span class="string">'Yiibai Yiibai'</span>,</span><br><span class="line">   url: <span class="string">'http://www.yiibai.com'</span>,</span><br><span class="line">   tags: [<span class="string">'mongodb'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   likes: <span class="number">10</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(<span class="number">7</span>df78ad8902e)</span><br><span class="line">   title: <span class="string">'Neo4j Overview'</span>, </span><br><span class="line">   description: <span class="string">'Neo4j is no sql database'</span>,</span><br><span class="line">   by_user: <span class="string">'Neo4j'</span>,</span><br><span class="line">   url: <span class="string">'http://www.neo4j.com'</span>,</span><br><span class="line">   tags: [<span class="string">'neo4j'</span>, <span class="string">'database'</span>, <span class="string">'NoSQL'</span>],</span><br><span class="line">   likes: <span class="number">750</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在从上面的集合，如果想知道每一个用户编写的教程是多少，那么使用aggregate()方法，如下图所示的列表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.mycol.aggregate([&#123;<span class="attr">$group</span> : &#123;<span class="attr">_id</span> : <span class="string">"$by_user"</span>, <span class="attr">num_tutorial</span> : &#123;<span class="attr">$sum</span> : <span class="number">1</span>&#125;&#125;&#125;])</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"result"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">"_id"</span> : <span class="string">"Yiibai Yiibai"</span>,</span><br><span class="line">         <span class="string">"num_tutorial"</span> : <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="string">"_id"</span> : <span class="string">"Neo4j"</span>,</span><br><span class="line">         <span class="string">"num_tutorial"</span> : <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>用于上述用途将等效于sql查询： select by_user, count(*) from mycol group by by_user</p><p>另外，在上述例子中，我们已经使用字段by_user进行分组并计算总和，也就是by_user 出现各个次数。一个列表中可用的聚集表达式。</p><table><thead><tr><th>表达式</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>$sum</td><td>从集合累加所有文档中的定义值</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</td></tr><tr><td>$avg</td><td>从集合中的所有文档计算所有给定值的平均值</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</td></tr><tr><td>$min</td><td>从集合中获取的所有文件的最小的相应值</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</td></tr><tr><td>$max</td><td>从集合中的所有文档中的相应值中获取最大值</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])</td></tr><tr><td>$push</td><td>插入数组值到文档中</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</td></tr><tr><td>$addToSet</td><td>插入值所产生的数组到文档中，但不会产生重复</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</td></tr><tr><td>$first</td><td>从源文件获取根据分组的头文件。通常，这使得只能意会再加上一些以前应用“$sort” -stage</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</td></tr><tr><td>$last</td><td>从源文件获取根据分组的最后文件。通常，这使得只能意会再加上一些以前应用 “$sort”-stage.</td><td>db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</td></tr></tbody></table><h2 id="MongoDB-复制"><a href="#MongoDB-复制" class="headerlink" title="MongoDB 复制"></a>MongoDB 复制</h2><p>复制是同步在多个服务器上的数据过程。复制提供了冗余和数据在不同的数据库服务器上的多个副本提高数据的可用性，复制防止在单个服务器上丢失数据库。 复制也可以从硬件故障和服务中断中恢复。带有数据的其他副本，可以选择其中一个灾难恢复，报告或备份。</p><p>为什么要复制？</p><ul><li>为了让数据安全</li><li>数据的高（24*7）可用性</li><li>灾难恢复</li><li>无停机维护（如备份，索引重建，压缩）</li><li>读取缩放（额外的副本来读取）</li><li>副本集是透明的应用</li></ul><h5 id="MongoDB复制的工作原理"><a href="#MongoDB复制的工作原理" class="headerlink" title="MongoDB复制的工作原理"></a>MongoDB复制的工作原理</h5><p>MongoDB通过使用副本集的复制来实现。副本集是一组承载同一个数据集的mongod实例。在副本的一个节点是接收所有的写操作主节点。所有的实例，次级，应用操作从主以便它们具有相同的数据集。副本集只能有一个主节点。</p><ul><li>副本集是一组两个或更多个节点（通常至少3节点是必需的）。</li><li>在副本集一个节点是主节点和其余的节点都是次要的。</li><li>所有的数据复制是从主到次节点。</li><li>在自动故障转移或维护时，选建立了主要和一个新的主节点被选择。</li><li>故障节点的恢复后，再次加入副本集，并可以作为一个辅助节点。</li></ul><p>mongodb复制的典型图如下图，其中客户端应用程序总是与主节点和主节点交互，然后将数据复制到辅助节点。</p><p><img src="http://ww1.sinaimg.cn/large/b3ad6cffly1g25gk1gxifj20dw0bd74v.jpg" alt></p><h5 id="副本集特征"><a href="#副本集特征" class="headerlink" title="副本集特征"></a>副本集特征</h5><ul><li>N个节点的集群</li><li>任何节点可为原发/主节点</li><li>所有的写操作进入到主节点</li><li>自动故障转移</li><li>自动恢复</li><li>协商一致选择主节点</li></ul><h5 id="建立一个副本集"><a href="#建立一个副本集" class="headerlink" title="建立一个副本集"></a>建立一个副本集</h5><p>在本教程中，我们将独立的 mongod 实例转换为副本集。 要转换为副本集，按照以下的步骤：</p><ul><li>关闭已经运行的 MongoDB 服务器。</li><li><p>现在，通过指定–replSet选项启动 MongoDB 服务器。–replSet 的基本语法如下：</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --port <span class="string">"PORT"</span> --dbpath <span class="string">"YOUR_DB_DATA_PATH"</span> --replSet <span class="string">"REPLICA_SET_INSTANCE_NAME"</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --port <span class="number">27017</span> --dbpath <span class="string">"D:\software\MongoDB\Server\3.0\mongodb\data"</span> --replSet rs0</span><br></pre></td></tr></table></figure></li><li><p>这将启动一个名为rs0的一个mongod实例，端口为： 27017</p></li><li>现在打开启动命令提示符，然后连接到mongod实例</li><li>在Mongo的客户端使用命令rs.initiate()来启动一个新的副本集</li><li>要检查副本设置配置，则使用命令rs.conf()</li><li>要检查副本集发行的状态，使用命令rs.status()</li></ul><h2 id="MongoDB创建备份"><a href="#MongoDB创建备份" class="headerlink" title="MongoDB创建备份"></a>MongoDB创建备份</h2><h5 id="MongoDB数据转储"><a href="#MongoDB数据转储" class="headerlink" title="MongoDB数据转储"></a>MongoDB数据转储</h5><p>要使用 mongodump 命令来执行 MongoDB 数据库备份。此命令将转储服务器的所有数据到转储目录。有许多可用的选项，通过它可以限制数据量或创建远程服务器备份。</p><h5 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h5><p>mongodump命令的基本语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mongodump</span><br></pre></td></tr></table></figure><h5 id="例子-15"><a href="#例子-15" class="headerlink" title="例子"></a>例子</h5><p>启动 mongod 服务器。假设 mongod 服务器运行在本地主机和端口 27017. 现在打开一个命令提示符，然后转到你的MongoDB实例的bin目录，然后输入命令mongodump。</p><p>考虑mycol集合有以下数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mongodump</span><br></pre></td></tr></table></figure><p>该命令将连接到服务器127.0.0.1和端口27017，并备份所有数据到服务器上的目录： /bin/dump/. 命令的输出如下所示：</p><p><img src="http://ww1.sinaimg.cn/large/b3ad6cffly1g25gpmm3kij20it08aaar.jpg" alt></p><p>以上是可用的选项能够与mongodump命令一起使用的列表。</p><p>此命令将只备份指定数据库到指定的路径</p><table><thead><tr><th>语法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>mongodump –host HOST_NAME –port PORT_NUMBER</td><td>这个命令将备份指定的mongod实例的所有数据库</td><td>mongodump –host yiibai.com –port 27017</td></tr><tr><td>mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY</td><td></td><td>mongodump –dbpath /data/db/ –out /data/backup/</td></tr><tr><td>mongodump –collection COLLECTION –db DB_NAME</td><td>此命令将仅备份指定的特定数据库集合</td><td>mongodump –collection mycol –db test</td></tr></tbody></table><h5 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h5><p>要恢复备份的MongoDB数据，则使用mongorestore命令。该命令将从备份目录恢复所有的数据。</p><h5 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h5><p>mongorestore命令的基本语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mongorestore</span><br></pre></td></tr></table></figure><p>这个命令的输出如下所示：</p><p><img src="http://ww1.sinaimg.cn/large/b3ad6cffly1g25gsbqq7cj20it0cq0tu.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建数据库&quot;&gt;&lt;a href=&quot;#创建数据库&quot; class=&quot;headerlink&quot; title=&quot;创建数据库&quot;&gt;&lt;/a&gt;创建数据库&lt;/h2&gt;&lt;p&gt;MongoDB use DATABASE_NAME 用于创建数据库。该命令如果数据库不存在，将创建一个新的数据库， 否则将返回现有的数据库。&lt;/p&gt;
&lt;h5 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h5&gt;&lt;p&gt;use DATABASE语句的基本语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;use DATABASE_NAME&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;例子：&quot;&gt;&lt;a href=&quot;#例子：&quot; class=&quot;headerlink&quot; title=&quot;例子：&quot;&gt;&lt;/a&gt;例子：&lt;/h5&gt;&lt;p&gt;如果想创建一个数据库名称为 &lt;strong&gt;\&lt;mydb&gt;&lt;/mydb&gt;&lt;/strong&gt;， 那么 &lt;strong&gt;use DATABASE&lt;/strong&gt; 语句应该如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;use mydb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;switched to db mydb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要检查当前选择的数据库使用命令 &lt;strong&gt;db&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;db&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mydb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果想查询数据库列表，那么使用命令 &lt;strong&gt;show dbs&lt;/strong&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;show dbs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local     &lt;span class=&quot;number&quot;&gt;0.78125&lt;/span&gt;GB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test      &lt;span class=&quot;number&quot;&gt;0.23012&lt;/span&gt;GB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所创建的数据库（mydb）不存在于列表中。要显示的数据库，需要至少插入一个文档进去。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;db.movie.insert(&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;yiibai tutorials&quot;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;show dbs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;local      &lt;span class=&quot;number&quot;&gt;0.78125&lt;/span&gt;GB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mydb       &lt;span class=&quot;number&quot;&gt;0.23012&lt;/span&gt;GB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test       &lt;span class=&quot;number&quot;&gt;0.23012&lt;/span&gt;GB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;MongoDB的默认数据库是test。 如果没有创建任何数据库，那么集合将被保存在测试数据库。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mongodb" scheme="https://daziweb.github.io/categories/mongodb/"/>
    
    
      <category term="mongodb" scheme="https://daziweb.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 数据类型(数值)</title>
    <link href="https://daziweb.github.io/2019/04/10/javascript/%E6%95%B0%E5%80%BC/"/>
    <id>https://daziweb.github.io/2019/04/10/javascript/数值/</id>
    <published>2019-04-10T07:39:27.364Z</published>
    <updated>2019-04-12T02:33:13.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>Javascript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，<code>1</code> 与 <code>1.0</code> 是相同的，是同一个数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这就是说，Javascript 语言的底层根本没有整数，所有数字都是小数(64 位浮点数)。容易造成混淆的是，某些运算只有整数才能完成，此时 Javascript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算。</p><p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> - <span class="number">0.2</span> === <span class="number">0.2</span> - <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h2><p>根据国际标准 IEEE 754，Javascript 浮点数的 64 个二进制位，从最左边开始，是这样组成的。</p><ul><li>第 1 位：符号位，<code>0</code> 表示正数，<code>1</code> 表示负数。</li><li>第 2 位到第 12 位(共 11 位)：指数部分。</li><li>第 13 位到第 64 位(共 52 位)：小数部分(即有效数字)。</li></ul><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p><p>指数部分一共有 11 个二进制位，因些大小范围就是 0 到 2047。IEEE 754 规定，如果指数部分的值在 0 到 2047 之间(不含两个端点)，那么有效数字的第一位默认总是 1，不保存在 64 位浮点数之中。也就是说，有效数字这时总是 <code>1.xx...xx</code> 的形式，其中 <code>xx...xx</code> 的部分保存在 64 位浮点数之中，最长可能为 52 位。因此，Javascript 提供的有效数字最长为 53 个二进制位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">-1</span>)^符号位 * <span class="number">1.</span>xx...xx * <span class="number">2</span>^指数部分</span><br></pre></td></tr></table></figure><p>上面公式是正常情况下(指数部分在 0 到 2047 之间)，一个数在 Javascript 内部实际的表示形式。</p><p>精度最多只能到 53 个二进制位，这意味着，绝对值小于 2 的 53 次方的整数，即 <code>-2^53</code> 到<br><code>2^53</code>，都可以精确表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>);</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 9007199254740994</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br></pre></td></tr></table></figure><p>上面代码中，大于 2 的 53 次方以后，整数运算的结果开始出现错误。所以，大于 2 的 53 次方的数值，都无法保持精度。由于 2 的 53 次方是一个 16 位的十进制数值，所以简单的法则就是，Javascript 对 15 位的十进制数都可以精确处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>);</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多出的三个有效数字，将无法保存</span></span><br><span class="line"><span class="number">9007199254740992111</span>;</span><br><span class="line"><span class="comment">// 9007199254740992000</span></span><br></pre></td></tr></table></figure><p>上面示例表明，大于 2 的 53 次方以后，多出来的有效数字(最后三位的 <code>111</code>)都会无法保存，变成 0。</p><h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>根据标准，64 位浮点数的指数部分的长度是 11 个二进制位，意味着指数部分的最大值是 2047(2 的 11 次方减 1)。也就是说，64 位浮点数的指数部分的值最大为 2047，分出一半表示负数，则 Javascript 能够表示的数值范围为 <code>2^1024</code> 到 <code>2^-1023</code> (开区间)，超出这个范围的数无法表示。</p><p>如果一个数大于等于 2 的 1024 次方，那么就会发生<strong>正向溢出</strong>，即 Javascript 无法表示这么大的数，这时就会返回 <code>Infinity</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>如果一个数小于等于 2 的-1075 次方(指数部分最小值-1023，再加上小数部分的 52 位)，那么就会发生为<strong>负向溢出</strong>，即 Javascript 无法表示这么小的数，这时会直接返回 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-1075</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>下面是一个实际的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">  x = x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，对 <code>0.5</code> 连续做 25 次平方，由于最后结果太接近 0，超出了可表示的范围，Javascript 就直接将其转为 0。</p><p>Javascriptr 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE; <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE; <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure><h2 id="数值的表示法"><a href="#数值的表示法" class="headerlink" title="数值的表示法"></a>数值的表示法</h2><p>javascript 的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>(十进制)和<code>0xFF</code>(十六进制)。</p><p>数值也可以采用科学计数法表示，下面是几个科学计数法的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123e3</span>; <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span>; <span class="comment">// 0.123</span></span><br><span class="line"><span class="number">-3.1e12</span>; <span class="comment">// -3100000000000</span></span><br><span class="line"><span class="number">0.1e-23</span>; <span class="comment">// 1e-24</span></span><br></pre></td></tr></table></figure><p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。</p><p>以下两种情况，javascript 会自动将数值转为科学计数法表示。其他情况都采用字面形式直接表示。</p><p>（1）小数点前的数字多于 21 位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234567890123456789012</span>;</span><br><span class="line"><span class="comment">// 1.2345678901234568e+21</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789012345678901</span>;</span><br><span class="line"><span class="comment">// 123456789012345680000</span></span><br></pre></td></tr></table></figure><p>（2）小数点后的零多于 5 个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小数点后紧跟5个以上的零，</span></span><br><span class="line"><span class="comment">// 就自动转为科学计数法</span></span><br><span class="line"><span class="number">0.0000003</span>; <span class="comment">// 3e-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，就保持原来的字面形式</span></span><br><span class="line"><span class="number">0.000003</span>; <span class="comment">// 0.000003</span></span><br></pre></td></tr></table></figure><h2 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h2><p>使用字面量（literal）直接表示一个数值时，javascript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p><ul><li>十进制：没有前导 0 的数值。</li><li>八进制：有前缀<code>0o</code>或<code>00</code>的数值，或者有前导 0、且只用到 0-7 的八个阿拉伯数字的数值。</li><li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li><li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li></ul><p>默认情况下，javascript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xff</span>; <span class="comment">// 255</span></span><br><span class="line"><span class="number">0o377</span>; <span class="comment">// 255</span></span><br><span class="line"><span class="number">0b11</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>xzz; <span class="comment">// 报错</span></span><br><span class="line"><span class="number">0</span>o88; <span class="comment">// 报错</span></span><br><span class="line"><span class="number">0</span>b22; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，十六进制出现了字母<code>z</code>、八进制出现数字<code>8</code>、二进制出现数字<code>2</code>，因此报错。</p><p>通常来说，有前导 0 的数值会被视为八进制，但是如果前导 0 后面有数字<code>8</code>和<code>9</code>，则该数值被视为十进制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0888</span>; <span class="comment">// 888</span></span><br><span class="line"><span class="number">0777</span>; <span class="comment">// 511</span></span><br></pre></td></tr></table></figure><p>前导 0 表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p><h2 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h2><h3 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h3><p>前面说过，Javascript 的 64 位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的值，就连 <code>0</code> 也不例外。</p><p>javascript 内部实际上存在 2 个 <code>0</code>：一个是 <code>+0</code>，一个是<code>-0</code>，区别就是 64 位浮点数表示法的符号位不同。它们是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-0</span> === +<span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === <span class="number">-0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === +<span class="number">0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>几乎所有场合，正零和负零都会被当作正常的 <code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> - <span class="comment">// 0</span></span><br><span class="line">  <span class="number">0</span>(</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="number">-0</span></span><br><span class="line">  )</span><br><span class="line">    .toString()(</span><br><span class="line">      <span class="comment">// '0'</span></span><br><span class="line">      +<span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    .toString(); <span class="comment">// '0'</span></span><br></pre></td></tr></table></figure><p>唯一有区别的场合是，<code>+0</code> 或 <code>-0</code> 当作分母，返回的值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / +<span class="number">0</span> === <span class="number">1</span> / <span class="number">-0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure><p>上面的代码之所以出现这样的结果，是因为除以正零得到 <code>+Infinity</code>，除以负零得到 <code>-Infinity</code>，这两者是不相等的。</p><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><ul><li>含义</li></ul><p><code>NaN</code> 是 javascript 的特殊值，表示<strong>非数字</strong>(Not a Number)，主要出现在将字符串解析成数字出错的场合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="string">'x'</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面的代码运行时，会自动将字符串 <code>x</code> 转为数值，但是由于 <code>x</code> 不是数值，所以最后得到结果为 <code>NaN</code>，表示它是<strong>非数字</strong>(<code>NaN</code>)。</p><p>另外，一些数学函数的运算结果会出现 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.acos(<span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.log(<span class="number">-1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(<span class="number">-1</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><code>0</code> 除以 <code>0</code> 也会得到 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>NaN</code> 不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于 <code>Number</code>，使用 <code>typeof</code> 运算符可以看得很清楚。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// 'number'</span></span><br></pre></td></tr></table></figure><ul><li>运算规则</li></ul><p><code>NaN</code> 不等于任何值，包括它本事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>数组的 <code>indexOf</code> 方法内部使用的是严格相等运算符，所以该方法对 <code>NaN</code> 不成立。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 在布尔运算时被当作 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 与任何数(包括它自己)的运算，得到的都是 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> + <span class="number">32</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> - <span class="number">32</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> * <span class="number">32</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> / <span class="number">32</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><ul><li>含义</li></ul><p><code>Infinity</code> 表示<strong>无穷</strong>，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非 0 数值除以 0，得到<code>Infinity</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景一</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景二</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回 <code>Infinity</code>。第二个场景是 <code>0</code> 除以 <code>0</code> 会得到 <code>NaN</code>，而非 0 数值除以 <code>0</code>，会返回 <code>Infinity</code>。</p><p><code>Infinity</code> 有正负之分，<code>Infinity</code> 表示正的无穷，<code>-Infinity</code> 表示负的无穷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> === -<span class="literal">Infinity</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> / <span class="number">-0</span>; <span class="comment">// -Infinity</span></span><br><span class="line"><span class="number">-1</span> / <span class="number">-0</span>; <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>由于数值正向溢出（overflow）、负向溢出（underflow）和被 <code>0</code> 除，javascript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。</p><p><code>Infinity</code> 大于一切数值（别无他物了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了 <code>NaN</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> &gt;</span><br><span class="line">  <span class="number">1000</span> - <span class="comment">// true</span></span><br><span class="line">    <span class="literal">Infinity</span> &lt;</span><br><span class="line">  <span class="number">-1000</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Infinity</code> 与 <code>NaN</code> 比较，总是返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> &gt; <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &gt; <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> &lt; <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line">-<span class="literal">Infinity</span> &lt; <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>运算规则</li></ul><p><code>Infinity</code> 的四则运算，符合无穷的数学计算规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="literal">Infinity</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="literal">Infinity</span>; <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">5</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="literal">Infinity</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>0 乘以<code>Infinity</code>，返回<code>NaN</code>；0 除以<code>Infinity</code>，返回<code>0</code>；<code>Infinity</code>除以 0，返回<code>Infinity</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> * <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="literal">Infinity</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p><code>Infinity</code>加上或乘以<code>Infinity</code>，返回的还是<code>Infinity</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> + <span class="literal">Infinity</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> * <span class="literal">Infinity</span>; <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p><code>Infinity</code>减去或除以<code>Infinity</code>，得到<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><code>Infinity</code>与<code>null</code>计算时，<code>null</code>会转成 0，等同于与<code>0</code>的计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> * <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="literal">Infinity</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">null</span>; <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p><code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> - <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> * <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> / <span class="literal">Infinity</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h2><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><ul><li>基本用法</li></ul><p><code>parseInt</code> 方法用于将字符串转为整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>如果字符串头部有空格，空格会被自动去除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'    81'</span>); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure><p>如果 <code>parseInt</code> 的参数不是字符串，则会先转为字符串再转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1.23'</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8a'</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12**'</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.34'</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15e2'</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15px'</span>); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p><p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'.3'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+1'</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p><p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x10'</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>如果字符串以<code>0</code>开头，将其按照 10 进制解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'011'</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1e+21'</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8e-7'</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><ul><li>进制转换</li></ul><p><code>parseInt</code>方法还可以接受第二个参数(2 到 36)之间，表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为 10，即默认是十进制转十进制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>); <span class="comment">// 1000</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">10</span>); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>下面是转换指定进制的数的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">2</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">6</span>); <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">8</span>); <span class="comment">// 512</span></span><br></pre></td></tr></table></figure><p>上面代码中，二进制、六进制、八进制的 <code>1000</code>，分别等于十进制的 8、216 和 512。这意味着，可以用 <code>parseInt</code> 方法进行进制的转换。</p><p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在 2 到 36 之间，才能得到有意义的结果，超出这个范围，则返回 <code>NaN</code>。如果第二个参数是 <code>0</code>、<code>undefined</code> 和 <code>null</code>，则直接忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">37</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">0</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="literal">null</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="literal">undefined</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1546'</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'546'</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面代码中，对于二进制来说，<code>1</code> 是有意义的字符，<code>5</code>、<code>4</code>、<code>6</code> 都是无意义的字符，所以第一行返回 1，第二行返回 <code>NaN</code>。</p><p>前面说过，如果 <code>parseInt</code> 的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">36</span>); <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">36</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">0x11</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'17'</span>, <span class="number">36</span>);</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'17'</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，十六进制的 <code>0x11</code> 会被先转为十进制的 17，再转为字符串。然后，再用 36 进制或二进制解读字符串<code>17</code>，最后返回结果 <code>43</code> 和 <code>1</code>。</p><p>这种处理方式，对于八进制的前缀 0，尤其需要注意。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">011</span>, <span class="number">2</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">011</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">9</span>), <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，第一行的 <code>011</code> 会被先转为字符串 <code>9</code>，因为 <code>9</code> 不是二进制的有效字符，所以返回 <code>NaN</code>。如果直接计算 <code>parseInt(&#39;011&#39;, 2)</code>，<code>011</code> 则是会被当作二进制处理，返回 3。</p><p>JavaScript 不再允许将带有前缀 0 的数字视为八进制数，而是要求忽略这个 <code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p><code>parseFloat</code> 方法用于将一个字符串转为浮点数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14'</span>); <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><p>如果字符串符合科学计数法，则会进行相应的转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'314e-2'</span>); <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'0.0314E+2'</span>); <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14more non-digit characters'</span>); <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><p><code>parseFloat</code> 方法会自动过滤字符串前导的空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'\t\v\r12.34\n '</span>); <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>([]); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'FF2'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>上面代码中，尤其值得注意，<code>parseFloat</code> 会将空字符串转为 <code>NaN</code>。</p><p>这些特点使得 <code>parseFloat</code> 的转换结果不同于 <code>Number</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>); <span class="comment">// 123.45</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'123.45#'</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p><code>isNaN</code> 方法可以用来判断一个值是否为 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>但是，<code>isNaN</code> 只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成 <code>NaN</code>，所以最后返回 <code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code> 为 <code>true</code> 的值，有可能不是 <code>NaN</code>，而是一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">'Hello'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(<span class="string">'Hello'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>出于同样的原因，对于对象和数组，<code>isNaN</code> 也返回 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>(&#123;&#125;)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">'xzy'</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>([<span class="string">'xzy'</span>])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code> 返回 <code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>([]); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">'123'</span>]); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码之所以返回 <code>false</code>，原因是这些数组能被 <code>Number</code> 函数转成数值。</p><p>因此，使用 <code>isNaN</code> 之前，最好判断一下数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 <code>NaN</code> 更可靠的方法是，利用 <code>NaN</code> 为唯一不等于自身的值的这个特点，进行判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h3><p><code>isFinite</code> 方法返回一个布尔值，表示某个值是否为正常的数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">-1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>除了 <code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code> 和 <code>undefined</code> 这几个值会返回 <code>false</code>，<code>isFinite</code> 对于其他的数值都会返回 <code>true</code>。</p><h2 id="关于本文档的来历"><a href="#关于本文档的来历" class="headerlink" title="关于本文档的来历"></a>关于本文档的来历</h2><blockquote><p><strong>摘抄自《JavaScript 标准参考教程（alpha）》，by 阮一峰</strong></p><p><strong><em>仅供学习使用</em></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整数和浮点数&quot;&gt;&lt;a href=&quot;#整数和浮点数&quot; class=&quot;headerlink&quot; title=&quot;整数和浮点数&quot;&gt;&lt;/a&gt;整数和浮点数&lt;/h2&gt;&lt;p&gt;Javascript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，&lt;code&gt;1&lt;/code&gt; 与 &lt;code&gt;1.0&lt;/code&gt; 是相同的，是同一个数。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; === &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就是说，Javascript 语言的底层根本没有整数，所有数字都是小数(64 位浮点数)。容易造成混淆的是，某些运算只有整数才能完成，此时 Javascript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算。&lt;/p&gt;
&lt;p&gt;由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt; === &lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2.9999999999999996&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0.3&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt; === &lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://daziweb.github.io/categories/javascript/"/>
    
    
      <category term="javascript 数值" scheme="https://daziweb.github.io/tags/javascript-%E6%95%B0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="https://daziweb.github.io/2019/04/10/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://daziweb.github.io/2019/04/10/javascript/数据类型/</id>
    <published>2019-04-10T07:31:38.321Z</published>
    <updated>2019-04-10T07:38:27.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Javascript 语言的每一个值，都属于某一种数据类型。Javascript 的数据类型，共有六种。</p><ul><li>数值(number): 整数和小数(比如 <code>1</code> 和 <code>3.14</code>)。</li><li>字符串(string): 文本(比如 <code>hello world</code>)。</li><li>布尔值(boolean): 表示真伪的两个特殊值，即 <code>true</code> (真)和 <code>false</code> (假)。</li><li><code>undefined</code>: 表示”未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</li><li><code>null</code>: 表示空值，即此处的值为空。</li><li>对象(object): 各种值组成的集合。</li></ul><p>通常，数值、字符串、布尔值这三种类型，合称为原始类型(primitive type) 的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型(complex type) 的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于 <code>undefined</code> 和 <code>null</code>，一般将它们看成两个特殊值。</p><p>对象是最复杂的数据类型，又可以分成三个子类型。</p><ul><li>狭义的对象(object)</li><li>数值(array)</li><li>函数(function)</li></ul><p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象”都特指狭义的对象。函数其实是处理数据的方法，Javascript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 Javascript 的”函数式编程”奠定了基础。</p><a id="more"></a><h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><p>Javascript 有三种方法，可以确定一个值到底是什么类型。</p><ul><li><code>typeof</code> 运算符</li><li><code>instanceof</code> 运算符</li><li><code>Object.prototype.toString</code> 方法</li></ul><p><code>instanceof</code> 运算符和 <code>Object.prototype.toString</code> 方法，将在后文介绍。这里介绍 <code>typeof</code> 运算符。</p><p><code>typeof</code> 运算符可以返回一个值的数据类型。</p><p>数值、字符串、布尔值分别返回 <code>number</code> 、<code>string</code> 、 <code>boolean</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span>; <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span>; <span class="comment">// 'boolean'</span></span><br></pre></td></tr></table></figure><p>函数返回 <code>funciton</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> f; <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><p><code>undefined</code> 返回 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// 'undefined'</span></span><br></pre></td></tr></table></figure><p>利用这一点，<code>typeof</code> 可以用来检查一个没有声明的变量，而不报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v;</span><br><span class="line"><span class="comment">// 'undefined'</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>v</code> 没有用 <code>var</code> 命令声明，直接使用就会报错。但是，放在 <code>typeof</code> 后面，就不报错了，而是返回 <code>undefined</code>。</p><p>实际编程中，这个特点通常用在判断语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象返回 <code>object</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure><p>上面代码中，空数组( <code>[]</code> )的类型也是 <code>object</code>，这表示在 Javascript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，<code>instanceof</code> 运算符可以区分数组和对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>null</code> 返回 <code>object</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure><p><code>null</code> 的类型是 <code>object</code>，这是由于历史原因造成的。1955 年的 Javascript 语言第一版，只设计了五种数据类型(对象、整数、浮点数、字符串和布尔值)，没考虑 <code>null</code>，只把它当作 <code>object</code> 的一种特殊值。后来 <code>null</code> 独立出来。作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code> 返回 <code>object</code> 就没法改变了。</p><h2 id="null、undefined-和布尔值"><a href="#null、undefined-和布尔值" class="headerlink" title="null、undefined 和布尔值"></a>null、undefined 和布尔值</h2><h3 id="null-undefined-概述"><a href="#null-undefined-概述" class="headerlink" title="null undefined 概述"></a>null undefined 概述</h3><p><code>null</code> 与 <code>undefined</code> 都可以表示<strong>没有</strong>，含义非常相似。将一个变量赋值为 <code>undefined</code> 或 <code>null</code>，老实说，语法效果几乎没区别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>a</code> 分别被赋值为 <code>undefined</code> 和 <code>null</code>，这两种写法的效果几乎等价。</p><p>在 <code>if</code> 语句中，它们都会被自动转为 <code>false</code>，相等运算符( <code>==</code> )甚至直接报告两者相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'undefined is false'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'null is false);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// null is false</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">undefined == null;</span></span><br><span class="line"><span class="string">// true</span></span><br></pre></td></tr></table></figure><p>从上面代码可见，两者的行为是何等相似！谷歌公司开发的 Javascript 语言的替代品 Dart 语言，就明确规定只有 <code>null</code>，没有 <code>undefined</code> ！</p><p>既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史有关。</p><p>1995 年 Javascript 诞生时，最初像 Java 一样，只设置了 <code>null</code> 表示<strong>无</strong>。根据 C 语言的传统，<code>null</code> 可以自动转为 <code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span>; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>null</code> 转为数字时，自动变成 0。</p><p>但是，Javascript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 Javascript 里面，<code>null</code> 就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示<strong>无</strong>的值最好不是对象。其次，那时的 Javascript 不包括错误处理机制，Brendan Eich 觉得，如果 <code>null</code> 自动转为 0，很不容易发现错误。</p><p>因些，他又设计了一个 <code>undefined</code>。区别是这样的：<code>null</code> 是一个表示<strong>空</strong>的对象，转为数值时为 <code>0</code>；<code>undefined</code> 是一个表示<strong>此处无定义</strong>的原始值，转为数值时为 <code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h3 id="用法和含义"><a href="#用法和含义" class="headerlink" title="用法和含义"></a>用法和含义</h3><p>对于 <code>null</code> 和 <code>undefined</code>，大致可以像下面这样理解。</p><p><code>null</code> 表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这里就可以传入 <code>null</code>，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入 <code>null</code>，表示未发生错误。</p><p><code>undefined</code> 表示<strong>未定义</strong>，下面是返回 <code>undefined</code> 的典型场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明了 但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时， 默认返回 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值代表<strong>真</strong>和<strong>假</strong>两个状态。<strong>真</strong>用关键字 <code>true</code> 表示，<strong>假</strong>用关键字 <code>false</code> 表示。布尔值只有这两个值。</p><p>下列运算符会返回布尔值：</p><ul><li>前置逻辑运算符： <code>!</code>(Not)</li><li>相等运算符：<code>===</code>, <code>!==</code>, <code>==</code>, <code>!=</code></li><li>比较运算符：<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></li></ul><p>如果 Javascript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 <code>false</code>，其他值都视为 <code>true</code>。</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li><code>&quot;&quot;</code> 或 <code>&#39;&#39;</code> (空字符串)</li></ul><p>布尔值往往用于程序流程的控制，请看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">''</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>if</code> 命令后面的判断条件，预期应该是一个布尔值，所以 Javascript 自动将空字符串，转为布尔值 <code>false</code>，导致程序不会进入代码块，所以没有任何输出。</p><p>注意，空数组( <code>[]</code> )和空对象( <code>{}</code> )对应的布尔值，都是 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([].length == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="关于本文档的来历"><a href="#关于本文档的来历" class="headerlink" title="关于本文档的来历"></a>关于本文档的来历</h2><blockquote><p><strong>摘抄自《JavaScript 标准参考教程（alpha）》，by 阮一峰</strong></p><p><strong><em>仅供学习使用</em></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Javascript 语言的每一个值，都属于某一种数据类型。Javascript 的数据类型，共有六种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数值(number): 整数和小数(比如 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;3.14&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;字符串(string): 文本(比如 &lt;code&gt;hello world&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;布尔值(boolean): 表示真伪的两个特殊值，即 &lt;code&gt;true&lt;/code&gt; (真)和 &lt;code&gt;false&lt;/code&gt; (假)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;: 表示”未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;: 表示空值，即此处的值为空。&lt;/li&gt;
&lt;li&gt;对象(object): 各种值组成的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，数值、字符串、布尔值这三种类型，合称为原始类型(primitive type) 的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型(complex type) 的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt;，一般将它们看成两个特殊值。&lt;/p&gt;
&lt;p&gt;对象是最复杂的数据类型，又可以分成三个子类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;狭义的对象(object)&lt;/li&gt;
&lt;li&gt;数值(array)&lt;/li&gt;
&lt;li&gt;函数(function)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象”都特指狭义的对象。函数其实是处理数据的方法，Javascript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 Javascript 的”函数式编程”奠定了基础。&lt;/p&gt;
    
    </summary>
    
      <category term="数据类型" scheme="https://daziweb.github.io/categories/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="数据类型" scheme="https://daziweb.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>javascript 基本语法</title>
    <link href="https://daziweb.github.io/2019/04/03/javascript/javascript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://daziweb.github.io/2019/04/03/javascript/javascript基本语法/</id>
    <published>2019-04-03T00:28:13.240Z</published>
    <updated>2019-04-03T00:28:13.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Javascript 程度的执行单位为行（line）,也就是一行行地执行。一般情况下，每一行就是一个语句。</p><p>语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这条语句先用 <code>var</code> 命令，声明了变量 <code>a</code>，然后将 <code>1 + 3</code> 的运算结果赋值给变量 <code>a</code>。</p><p><code>1 + 3</code> 叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，语句主要为了进行某种操作，一般情况下不需要返回值；表达式则是为了得到返回值，一定会返回一个值。凡是 Javascript 语句中预期为值的地方，都可以使用表达式。比如，赋值语句的选号右边，预期是一个值，因此可以放置各种表达式。</p><a id="more"></a><p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 + 3; var b = &apos;abc&apos;;</span><br></pre></td></tr></table></figure><p>分号前面可以没有任何内容，Javascript 引擎将其视为空语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;;;</span><br></pre></td></tr></table></figure><p>上面的代码就表示 3 个空语句。</p><p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 javascript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span>;</span><br><span class="line">(<span class="string">'abc'</span>);</span><br></pre></td></tr></table></figure><p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>变量是对 <strong>值</strong> 的具名引用。变量就是为 <strong>值</strong> 起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面的代码先声明变量 <code>a</code>，然后在变量 <code>a</code> 与数值 1 之间建立引用关系，称为将数值 1 <strong>赋值</strong> 给变量 <code>a</code>。以后，引用变量名 <code>a</code> 就会得到数值 1。最前面的 <code>var</code>，是变量声明命令。它表示通知解释引擎，要创建一个变量 <code>a</code>。</p><p><strong>注意，javascript 的变量名区分大小写， <code>A</code> 和 <code>a</code> 是两个不同的变量。</strong></p><p>变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果只是声明变量而没有赋值，则该变量的值是 <code>undefined</code>。<code>undefined</code> 是一个特殊的值，表示<strong>无定义</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果变量赋值的时候，忘了写 <code>var</code> 命令，这条语句也是有效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 基本等同</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但是，不写 <code>var</code> 的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用 <code>var</code> 命令表明变量。</p><p>如果一个变量没有声明就直接使用， javascirpt 会报错，告诉你变量未定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a;</span><br><span class="line"><span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>上面的代码直接使用变量 <code>a</code>，系统就报错，告诉你变量 <code>a</code> 没有声明。</p><p>可以在同一条 <code>var</code> 命令中声明多个变量,变量之间用逗号隔开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br></pre></td></tr></table></figure><p>Javascript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>a</code> 开始被赋值为一个数值，后面又被重新赋值为一个字符串。第二次赋值的时候，因为变量 <code>a</code> 已经存在，所以不需要使用 <code>var</code> 命令。</p><p>如果使用 <code>var</code> 重新声明一个已经存在的变量，是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>x</code> 声明了两次，第二次声明是无效的。</p><p>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>Javascript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升(hoistin)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面代码首先使用 <code>console.log</code> 方法，在控制台(console)显示变量 <code>a</code> 的值。这时变量 <code>a</code> 还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>最后显示的结果是显示 <code>undefined</code>，表示变量 <code>a</code> 已声明，但还未赋值。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符(identifier)指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。Javascript 语言的标识符对大小写敏感，所以 <code>a</code> 和 <code>A</code> 是两个不同的标识符。</p><p>标识符有一套命名规则，不符合规则的就是非法标识符。Javascript 引擎遇到非法标识符，就会报错。</p><p>简单说，标识符命名规则如下。</p><ul><li><p>第一个字符，可以是任意 Unicode 字母(包括英文字母和其他语言的字母)，以及美元符号(<code>$</code>)和下划线(<code>_</code>)。</p></li><li><p>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字 <code>0-9</code>。</p></li></ul><p>下面这些都是合法的标识符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg0</span><br><span class="line">_tmp</span><br><span class="line">$elem</span><br><span class="line">π</span><br></pre></td></tr></table></figure><p>下面这些则是不合法的标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>a <span class="comment">// 第一个字符不能是数字</span></span><br><span class="line"><span class="number">23</span> <span class="comment">// 同上</span></span><br><span class="line">*** <span class="comment">// 标识符不能包含星号</span></span><br><span class="line">a+b <span class="comment">// 标识符不能包含加号</span></span><br><span class="line">-d <span class="comment">// 标识符不能包含减号或者连词线</span></span><br></pre></td></tr></table></figure><p>中文是合法的标识符，可以用作变量名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 临时变量 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Javascript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>源码中被 Javascript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用 <code>//</code> 起头；另一种是多行注释，放在 <code>/*</code> 和 <code>*/</code> 之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是</span></span><br><span class="line"><span class="comment">  多行</span></span><br><span class="line"><span class="comment">  注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此外，由于历史上 Javascript 可以兼容 HTML 代码的注释，所以 <code>&lt;!--</code> 和 <code>--&gt;</code> 也被视为合法的单行注释。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>; <span class="xml"><span class="comment">&lt;!-- x = 2;</span></span></span><br><span class="line"><span class="xml">--&gt; x = 3;</span></span><br></pre></td></tr></table></figure><p>上面代码中，只有 <code>x = 1</code> 会执行，其他的部分都被注释掉了。</p><p>需要注意的是， <code>--&gt;</code> 只有在行首，才会被当成单行注释，否则会当作正常的运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function countdown(n) &#123;</span><br><span class="line">  while (n --&gt; 0) console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">countdown(3);</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><p>上面代码中，<code>n --&gt; 0</code> 实际上会当作 <code>n-- &gt; 0</code>，因此输出 2、1、0。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Javascript 使用大括号，将多个相关的语句组合在一起，称为<strong>区块</strong>(block)。</p><p>对于 <code>var</code> 命令来说，Javascript 的区块不构成单独的作用域(scope)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码在区块内部，使用 <code>var</code> 命令声明并赋值了变量 <code>a</code>，然后在区块外部，变量 <code>a</code> 依然有效，区块对于 <code>var</code> 命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 Javascript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如 <code>for</code> 、<code>if</code> 、<code>while</code> 、<code>function</code> 等。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Javascript 提供 <code>if</code> 结构和 <code>switch</code> 结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</p><h3 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a><code>if</code> 结构</h3><p><code>if</code> 结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指是 Javascript 的两个特殊值，<code>true</code> 表示<strong>真</strong>，<code>false</code> 表示<strong>伪</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值) 语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (布尔值) 语句;</span><br></pre></td></tr></table></figure><p>上面是 <code>if</code> 结构的基本形式。需要注意的是，<strong>布尔值</strong>往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为 <code>true</code>，就执行紧跟在后面的语句；如果结果为 <code>false</code>，则跳过紧跟在后面的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) m = m + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面代码表示，只有在 <code>m</code> 等于 3 时，才会将其值加上 1。</p><p>这种写法要求条件表达式只能有一个语句。如果想执行多个语句，必须在 <code>if</code> 的条件判断之后，加上大括号，表示代码块(多个语句合并成一个语句)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) &#123;</span><br><span class="line">  m += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议总是在 <code>if</code> 语句中使用大括号，因为这样方便插入语句。</strong></p><p><strong>注意，<code>if</code> 后面的表达式之中，不要混淆赋值表达式( <code>=</code> )、严格相等运算符( <code>===</code> )和相等运算符( <code>==</code> )。尤其是赋值表达式不具有比较作用。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ((x = y)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "2"</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是，当 <code>x</code> 等于 <code>y</code> 的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将 <code>y</code> 赋值给变量 <code>x</code>，再判断变量 <code>x</code> 的值(等于 2)的布尔值(结果为 <code>true</code>)。</p><p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将运算符写成赋值运算符，就会报错，因为常量不能被赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = <span class="number">2</span>) &#123; <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> = x) &#123; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="if-else-结构"><a href="#if-else-结构" class="headerlink" title="if...else 结构"></a><code>if...else</code> 结构</h3><p><code>if</code> 代码块后面，还可以跟一个 <code>else</code> 代码块，表示不满足条件时，所要执行的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">3</span> === m) &#123;</span><br><span class="line">  <span class="comment">// 满足条件时 执行的语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不满足条件时 执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码判断变量 <code>m</code> 是否等于 3，如果等于就执行 <code>if</code> 代码块，否则执行 <code>else</code> 代码块。</p><p>对同一个变量进行多次判断时，多个 <code>if...else</code> 语句可以连写在一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span> === m) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> === m) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> === m) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>else</code> 代码块总是与离自己最近的那个 <code>if</code> 语句配对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> !== m)</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> === n) <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br></pre></td></tr></table></figure><p>上面代码不会有任何输出，<code>else</code> 代码块不会得到执行，因为它跟着的是最近的那个 <code>if</code> 语句，相当于下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> !== m) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> === n) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让 <code>else</code> 代码块跟随最上面的那个 <code>if</code> 语句，就要改变大括号的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> !== m) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> === n) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a><code>switch</code> 结构</h3><p>多个 <code>if...else</code> 连在一起使用的时候，可以转为使用更方便的 <code>switch</code> 结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'banana'</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'apple'</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码根据变量 <code>fruit</code> 的值，选择执行相应的 <code>case</code>。如果所有 <code>case</code>都不符合，则执行最后的 <code>default</code> 部分。需要注意的是，每个 <code>case</code> 代码块内部的 <code>break</code> 语句不能少，否则会接下去执行下一个 <code>case</code> 代码块，而不是跳出 <code>switch</code> 结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于1'</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于2'</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于其他值'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x 等于1</span></span><br><span class="line"><span class="comment">// x 等于2</span></span><br><span class="line"><span class="comment">// x 等于其他值</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>case</code> 代码块之中没有 <code>break</code> 语句，导致不会跳出 <code>switch</code> 结构，而会一直执行下去。正确的写法是像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于1'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于2'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于其他值'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 语句部分和 <code>case</code> 语句部分，都可以使用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span> + <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> + <span class="number">2</span>:</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    neverHappens();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 <code>default</code> 部分，是永远不会执行到的。</p><p>需要注意的是， <code>switch</code> 语句后面的表达式，与 <code>cae</code> 语句后面的表达式比较运行结果时，采用的是严格相等运算符( <code>===</code> )，而不是相等运算符( <code>==</code> )，这意味着比较时不会发生类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 发生类型转换'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 没有发生类型转换'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x 没有发生类型转换</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于变量 <code>x</code> 没有发生类型转换，所以不会执行 <code>case true</code> 的情况。这表明，<code>switch</code> 语句内部采用的是<strong>严格相等运算符</strong>。</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ?:"></a>三元运算符 <code>?:</code></h3><p>Javascript 还有一个三元运算符(即该运算符需要三个运算子) <code>?:</code>，也可以用于逻辑判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(条件) ? 表达式1 : 表达式2;</span><br></pre></td></tr></table></figure><p>上面代码中，如果<strong>条件</strong>为 <code>true</code>，则返回<strong>表达式 1</strong>的值，否则返回<strong>表达式 2</strong>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> even = n % <span class="number">2</span> === <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，如果 <code>n</code> 可以被 2 整除，则 <code>even</code> 等于 <code>true</code>，否则等于 <code>false</code>。它等同于下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> even;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">  even = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  even = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个三元运算符可以被视为 <code>if...else...</code> 的简写形式，因些可以用于多种场合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar;</span><br><span class="line"><span class="built_in">console</span>.log(myVar ? <span class="string">'myVar has a value'</span> : <span class="string">'myVar does not have a value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// myVar does not have a value</span></span><br></pre></td></tr></table></figure><p>上面代码利用三元运算符，输出相应的提示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'数字'</span> + n + <span class="string">'是'</span> + (n % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'偶数'</span> : <span class="string">'奇数'</span>);</span><br></pre></td></tr></table></figure><p>上面代码利用三元运算符，在字符串之中插入不同的值。</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h3><p><code>while</code> 语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (条件)</span><br><span class="line">  语句;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">while (条件) 语句;</span><br></pre></td></tr></table></figure><p><code>while</code> 语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>while</code> 语句的一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i 当前为：'</span> + i);</span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将循环 100 次，直到 <code>i</code> 等于 100 为止。</p><p>下面的例子是一个无限循环，因为循环条件总是为真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h3><p><code>for</code> 语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(初始化表达式; 条件; 递增表达式)</span><br><span class="line">  语句</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">for (初始化表达式; 条件; 递增表达式) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code> 语句后面的括号里面，有三个表达式。</p><ul><li>初始化表达式(initalize)：确定循环变量的初始值，只在循环开始时执行一次。</li><li>条件表达式(test)：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li><li>递增表达式(increment)：每轮循环的最后一个操作，通常用来递增循环变量。</li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，初始化表达式是 <code>var i = 0;</code>，即初始化一个变量 <code>i</code>，测试表达式是 <code>i &lt; x</code>，即只要 <code>i</code> 小于 <code>x</code>，就会执行循环；递增表达式是 <code>i++</code>，即每次循环结束后，<code>i</code> 增大 1。</p><p>所有 <code>for</code> 循环，都可以改写成 <code>while</code> 循环。上面的例子改为 <code>while</code> 循环，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; x) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code> 语句的三个部分(initalize、test、increment)，可以省略任何一个，也可以全部省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码省略了 <code>for</code> 语句表达式的三个部分，结果就导致了一个无限循环。</p><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do...while 循环"></a><code>do...while</code> 循环</h3><p><code>do...while</code> 循环与 <code>while</code> 循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">  语句</span><br><span class="line">while (条件);</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">do &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; while (条件);</span><br></pre></td></tr></table></figure><p>不管条件是否为真，<code>do...while</code> 循环至少运行一次，这是这种结构最大的特点。另外，<code>while</code> 语句后面的分号注意不要省略。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; x);</span><br></pre></td></tr></table></figure><h3 id="break-语句和-continue-语句"><a href="#break-语句和-continue-语句" class="headerlink" title="break 语句和 continue 语句"></a><code>break</code> 语句和 <code>continue</code> 语句</h3><p><code>break</code> 语句和 <code>continue</code> 语句都具有跳转作用，可以让代码不按既有的顺序执行。</p><p><code>break</code> 语句用于跳出代码块或循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i当前为：'</span> + i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只会执行 10 次循环，一旦 <code>i</code> 等于 10，就会跳出循环。</p><p><code>for</code> 循环也可以使用 <code>break</code> 语句跳出循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码执行到 <code>i</code> 等于 3，就会跳出循环。</p><p><code>continue</code> 语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i 当前为：'</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只有在 <code>i</code> 为奇数时，才会输出 <code>i</code> 的值。如果 <code>i</code> 为偶数，则直接进入下一轮循环。如果存在多重循环，不带参数的 <code>break</code> 语句和 <code>continue</code> 语句都只针对最内层循环。</p><h3 id="标签-label"><a href="#标签-label" class="headerlink" title="标签(label)"></a>标签(label)</h3><p>Javascript 语言允许，语句的前面有标签(label)，相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">  语句</span><br></pre></td></tr></table></figure><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p><p>标签通常与 <code>break</code> 语句和 <code>continue</code> 语句配合使用，跳出特定的循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i=0 j=0</span></span><br><span class="line"><span class="comment">// i=0 j=1</span></span><br><span class="line"><span class="comment">// i=0 j=2</span></span><br><span class="line"><span class="comment">// i=1 j=0</span></span><br></pre></td></tr></table></figure><p>上面代码为一个双重循环区块，<code>break</code> 命令后面加上了 <code>top</code> 标签(注意，<code>top</code> 不用加引号)，满足条件时，直接跳出双层循环。如果 <code>break</code> 语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p><p>标签也可以用于跳出代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'本行不会输出'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码执行到 <code>break foo</code>，就会跳出区块。</p><p><code>continue</code> 语句也可以与标签配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i=0 j=0</span></span><br><span class="line"><span class="comment">// i=0 j=1</span></span><br><span class="line"><span class="comment">// i=0 j=2</span></span><br><span class="line"><span class="comment">// i=1 j=0</span></span><br><span class="line"><span class="comment">// i=2 j=0</span></span><br><span class="line"><span class="comment">// i=2 j=1</span></span><br><span class="line"><span class="comment">// i=2 j=2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>continue</code> 命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果 <code>continue</code> 语句后面不使用标签，则只能进入下一轮的内层循环。</p><h2 id="关于本文档的来历"><a href="#关于本文档的来历" class="headerlink" title="关于本文档的来历"></a>关于本文档的来历</h2><blockquote><p><strong>摘抄自《JavaScript 标准参考教程（alpha）》，by 阮一峰</strong></p><p><strong><em>仅供学习使用</em></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;p&gt;Javascript 程度的执行单位为行（line）,也就是一行行地执行。一般情况下，每一行就是一个语句。&lt;/p&gt;
&lt;p&gt;语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这条语句先用 &lt;code&gt;var&lt;/code&gt; 命令，声明了变量 &lt;code&gt;a&lt;/code&gt;，然后将 &lt;code&gt;1 + 3&lt;/code&gt; 的运算结果赋值给变量 &lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 + 3&lt;/code&gt; 叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，语句主要为了进行某种操作，一般情况下不需要返回值；表达式则是为了得到返回值，一定会返回一个值。凡是 Javascript 语句中预期为值的地方，都可以使用表达式。比如，赋值语句的选号右边，预期是一个值，因此可以放置各种表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://daziweb.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://daziweb.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>markdown 学习语法</title>
    <link href="https://daziweb.github.io/2019/03/27/markdown/01%20%E8%AF%AD%E6%B3%95/"/>
    <id>https://daziweb.github.io/2019/03/27/markdown/01 语法/</id>
    <published>2019-03-27T07:45:40.899Z</published>
    <updated>2019-03-27T07:48:29.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-学习语法"><a href="#markdown-学习语法" class="headerlink" title="markdown 学习语法"></a>markdown 学习语法</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h2><ul><li>加粗<br><code>要加粗的文字左右分别用两个*号包起来</code></li><li>斜体<br><code>要倾斜的文字左右分别用一个*号包起来</code></li><li>斜体加粗<br><code>要倾斜和加粗的文字左右分别用三个*号包起来</code></li><li><p>删除线<br><code>要加删除线的文字左右分别用两个~~号包起来</code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h2><ul><li><p><code>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4. 分割线"></a>4. 分割线</h2><ul><li><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h2><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h2><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure></li><li><p>注：Markdown 本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用 html 语言的 a 标签代替。</p></li></ul><h2 id="7-列表"><a href="#7-列表" class="headerlink" title="7. 列表"></a>7. 列表</h2><ul><li><p>语法</p><ul><li>无序列表 <strong>用 - + * 任何一种都可以</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><ul><li>有序列表 <strong>用数字加点</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h2><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-流程图"><a href="#9-流程图" class="headerlink" title="9. 流程图"></a>9. 流程图</h2><ul><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;```</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;markdown-学习语法&quot;&gt;&lt;a href=&quot;#markdown-学习语法&quot; class=&quot;headerlink&quot; title=&quot;markdown 学习语法&quot;&gt;&lt;/a&gt;markdown 学习语法&lt;/h1&gt;&lt;h2 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1. 标题&quot;&gt;&lt;/a&gt;1. 标题&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 这是一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 这是二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 这是三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 这是四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 这是五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 这是六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="markdown" scheme="https://daziweb.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="https://daziweb.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>从 URL 输入到页面展示</title>
    <link href="https://daziweb.github.io/2019/03/27/interview/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
    <id>https://daziweb.github.io/2019/03/27/interview/从URL输入到页面展示/</id>
    <published>2019-03-27T07:39:29.668Z</published>
    <updated>2019-03-27T07:55:43.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-URL-输入到页面展示"><a href="#从-URL-输入到页面展示" class="headerlink" title="从 URL 输入到页面展示"></a>从 URL 输入到页面展示</h1><p>打开浏览器输入 url 的过程中，背后到底发生了哪些事情？从下面两张图来开始说。</p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16qec1mmpj20m00fijrs.jpg" alt="HTTP请求图"></p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16qetejlfj20yg0c8dgr.jpg" alt="HTTP请求详细图"></p><p>可以分为如下几个过程：</p><ul><li>DNS 解析: 将域名(domain)解析成 IP 地址</li><li>TCP 连接: TCP 三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接: TCP 四次挥手</li></ul><h2 id="一、URL-到底是啥"><a href="#一、URL-到底是啥" class="headerlink" title="一、URL 到底是啥"></a>一、URL 到底是啥</h2><p>URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上的资源。<br>结构如下:<br><strong>scheme://host.domain:port/path/filename</strong><br>scheme - 定义因特网服务类型。有 http， https，ftp，file 等，最常见的类型是 http，而 https 则是进行加密的网络传输，安全性更高。<br>host - 定义域主机(http 的默认主机是 WWW)<br>domain - 定义域名(常见有 .com .cn .net 现在还有中文域名)<br>port - 定义主机上的端口 http 默认端口 80(tcp)，https 默认端口 443(tcp,udp)<br>path - 定义服务器上的路径<br>filename - 定义文档/资源的名称</p><a id="more"></a><h2 id="二、域名解析（DNS）"><a href="#二、域名解析（DNS）" class="headerlink" title="二、域名解析（DNS）"></a>二、域名解析（DNS）</h2><p>在浏览器输入网址后，首页要经过域名解析，浏览器不能直接通过域名找到对应的服务器，需通过 IP 地址。</p><ol><li><p>IP 地址（IP Address）<br>ip 地址是指互联网协议地址，是 ip 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽设备物理地址的差异。IPv4 为一个 32 位的二进制数， IPv6 为 128 位的十六进制数</p></li><li><p>域名解析<br>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</p></li><li><p>浏览器如何通过域名去查询 URL 对应的 IP</p><ul><li>浏览器缓存: 浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存: 如果浏览器缓存中找不到需要的记录，会去操作系统中找。</li><li>路由缓存: 路由器也可缓存 DNS 记录。</li><li>ISP 的 DNS 服务器: ISP 指互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器: 递归查询。</li></ul></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16rm4k05mj20qb0ezwg3.jpg" alt="DNS查询"></p><ol start="4"><li>小结<br>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16rsgky05j20i00bwmy1.jpg" alt="小结"></p><h2 id="三、TCP-三次握手"><a href="#三、TCP-三次握手" class="headerlink" title="三、TCP 三次握手"></a>三、TCP 三次握手</h2><p>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16rur33ilj20mf0i7gma.jpg" alt="TCP三次握手"></p><ol><li><p>TCP 三次握手的过程如下:</p><ul><li><strong>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li><li><strong>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li><li><strong>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li></ul></li><li><p>为啥需要三次握手</p><ul><li>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</li></ul></li></ol><h2 id="四、发送-HTTP-请求"><a href="#四、发送-HTTP-请求" class="headerlink" title="四、发送 HTTP 请求"></a>四、发送 HTTP 请求</h2><ol><li><p>TCP 三次握手结束后，开始发送 HTTP 请求报文。</p><p>请求报文由请求行(request line)、请求头(header)、 请求体四个部分组成，如图所示:</p></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16sthv6hdj20h406rwf7.jpg" alt="HTTP请求"></p><ul><li><p>请求行包含请求方法、URL、协议版本</p><ul><li>请求方法包含: GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li><li>URL 即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt;组成。</li><li>协议版本即 http 版本号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  /chapter17/user.html HTTP/1.1</span><br></pre></td></tr></table></figure></li></ul><p>以上代码中<code>POST</code>代表请求方法，<code>/chapter17/user.html</code>表示 URL，<code>HTTP/1.1</code>代表协议和协议的版本。</p></li></ul><ol start="2"><li><p>请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号分隔。</p><p>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如: Host 表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent,请求发出者，兼容性以及定制化需求。</p></li><li><p>请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=tom&amp;password=1234&amp;realName=tomson</span><br></pre></td></tr></table></figure><p>上面代码，承载着 name、password、realName 三个请求参数。</p></li></ol><h2 id="五、服务器处理请求并返回-HTTP-报文"><a href="#五、服务器处理请求并返回-HTTP-报文" class="headerlink" title="五、服务器处理请求并返回 HTTP 报文"></a>五、服务器处理请求并返回 HTTP 报文</h2><ol><li><p>服务器</p><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机(客户机)提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache 、nginx 、IIS 等。</p><p>web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理(例如 CGL 脚本，JSP 脚本，servlets，ASP 脚本，服务端 JavaScript，或者一些其它的服务器端技术等)，然后返回后台程序处理产生的结果作为响应。</p></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16z4ewah3j20oe0aaq5j.jpg" alt="服务器与客户端的区别"></p><ol start="2"><li><p>MVC 后台处理阶段</p><p>后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。</p><p>MVC 是一个设计模式，将应用程序分成三个核心部件: 模型（model）- 视图（view）- 控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。</p></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16z864tr1j20el0f3750.jpg" alt="MVC设计模式"></p><ul><li>视图（view）<br><strong>它是提供给用户的操作界面，是程序的外壳。</strong></li><li>模型（model）<br><strong>模型主要负责数据交互。</strong> 在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。</li><li><p>控制器（controller）<br><strong>它负责根据用户从<code>视图层</code>输入的指令，选取<code>模型层</code>中的数据，然后对其进行相应的操作，产生最终结果。</strong> 控制器属于管理者角色，从视图接收请求并决定调用哪 个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。</p><p>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口，供上面一层调用。<strong>首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。</strong></p></li></ul><ol start="3"><li><p>http 响应报文</p><p>响应报文由响应行（response line）、响应头部（header）、响应主体三个部分组成。如下图所示：</p></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16zk73a42j20bb080mxm.jpg" alt="响应报文"></p><ul><li>响应行包含: 协议版本、状态码<br>状态码规则如下：<br>1xx：指示信息 - 表示请求已接收，继续处理。<br>2xx：成功 - 表示请求已被成功接收、理解、接受。<br>3xx：重定向 - 要完成请求必须进行更进一步的操作。<br>4xx：客户端错误 - 请求有语法错误或请求无法实现。<br>5xx：服务器端错误 - 服务器未能实现合法的请求。</li><li>响应头部包含响应报文的附加信息，由 名/值 对组成</li><li>响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</li></ul><h2 id="六、浏览器解析渲染页面"><a href="#六、浏览器解析渲染页面" class="headerlink" title="六、浏览器解析渲染页面"></a>六、浏览器解析渲染页面</h2><p>浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制</p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16zqnnv5cj20kw076aab.jpg" alt="浏览器响应机制"></p><p>浏览器解析渲染页面分为五个步骤：</p><ul><li>根据 HTML 解析出 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面</li></ul><ol><li>根据 HTML 解析 DOM 树<ul><li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优选遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li><li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li></ul></li><li>根据 CSS 解析生成 CSS 规则树<ul><li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li><li>浏览器在 CSS 规则树生成之前不会进行渲染。</li></ul></li><li>结合 DOM 树和 CSS 规则树，生成渲染树<ul><li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li><li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li></ul></li><li>根据渲染树计算每一个节点的信息(布局)<ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li><li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul></li><li>根据计算好的信息绘制页面<ul><li>绘制阶段，系统会遍历呈现树，并调用呈现器的<strong>paint</strong>方法，将呈现器的内容显示在屏幕上。</li><li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li><li>回流：某个元素的尺寸发生了变化，则需要重新计算渲染树，重新渲染。</li></ul></li></ol><h2 id="七、断开连接"><a href="#七、断开连接" class="headerlink" title="七、断开连接"></a>七、断开连接</h2><p>当数据传送完毕，需要断开 TCP 连接，此时发起 TCP 四次挥手。</p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g1706quw5ej20i40cit9m.jpg" alt="TCP四次挥手"></p><ul><li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。</strong>（第一次挥手由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧）</li><li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。</strong>(第二次挥手由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li><li><strong>被动方向发起发送报文段，Fin、Ack、Seq 请求关闭连接。并进入 LAST_ACK 状态。</strong>(第三次挥手由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li><li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。</strong>(第四次挥手由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也关闭吧)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从-URL-输入到页面展示&quot;&gt;&lt;a href=&quot;#从-URL-输入到页面展示&quot; class=&quot;headerlink&quot; title=&quot;从 URL 输入到页面展示&quot;&gt;&lt;/a&gt;从 URL 输入到页面展示&lt;/h1&gt;&lt;p&gt;打开浏览器输入 url 的过程中，背后到底发生了哪些事情？从下面两张图来开始说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/b3ad6cffly1g16qec1mmpj20m00fijrs.jpg&quot; alt=&quot;HTTP请求图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/b3ad6cffly1g16qetejlfj20yg0c8dgr.jpg&quot; alt=&quot;HTTP请求详细图&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以分为如下几个过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DNS 解析: 将域名(domain)解析成 IP 地址&lt;/li&gt;
&lt;li&gt;TCP 连接: TCP 三次握手&lt;/li&gt;
&lt;li&gt;发送 HTTP 请求&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回 HTTP 报文&lt;/li&gt;
&lt;li&gt;浏览器解析渲染页面&lt;/li&gt;
&lt;li&gt;断开连接: TCP 四次挥手&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一、URL-到底是啥&quot;&gt;&lt;a href=&quot;#一、URL-到底是啥&quot; class=&quot;headerlink&quot; title=&quot;一、URL 到底是啥&quot;&gt;&lt;/a&gt;一、URL 到底是啥&lt;/h2&gt;&lt;p&gt;URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上的资源。&lt;br&gt;结构如下:&lt;br&gt;&lt;strong&gt;scheme://host.domain:port/path/filename&lt;/strong&gt;&lt;br&gt;scheme - 定义因特网服务类型。有 http， https，ftp，file 等，最常见的类型是 http，而 https 则是进行加密的网络传输，安全性更高。&lt;br&gt;host - 定义域主机(http 的默认主机是 WWW)&lt;br&gt;domain - 定义域名(常见有 .com .cn .net 现在还有中文域名)&lt;br&gt;port - 定义主机上的端口 http 默认端口 80(tcp)，https 默认端口 443(tcp,udp)&lt;br&gt;path - 定义服务器上的路径&lt;br&gt;filename - 定义文档/资源的名称&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://daziweb.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://daziweb.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vue 常见知识点</title>
    <link href="https://daziweb.github.io/2019/03/27/interview/vue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://daziweb.github.io/2019/03/27/interview/vue相关知识点/</id>
    <published>2019-03-27T07:39:29.624Z</published>
    <updated>2019-03-27T07:48:34.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-常见知识点"><a href="#Vue-常见知识点" class="headerlink" title="Vue 常见知识点"></a>Vue 常见知识点</h1><h2 id="一、什么是-mvvm"><a href="#一、什么是-mvvm" class="headerlink" title="一、什么是 mvvm"></a>一、什么是 mvvm</h2><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。 Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来， ViewModel 是一个同步 View 和 Model 的对象。</p><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因些 View 数据的变化会同步到 Model 中，而且 Model 数据的变化也会立即反应到 View 上。</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而且 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><a id="more"></a><h2 id="二、mvvm-和-mvc-区别？"><a href="#二、mvvm-和-mvc-区别？" class="headerlink" title="二、mvvm 和 mvc 区别？"></a>二、mvvm 和 mvc 区别？</h2><p>mvc 和 mvvm 其实区别不大。 都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 ViewModel。 mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 model 频繁发生变化，开发者需要主动更新到 View。</p><h2 id="三、vue-的优点是什么？"><a href="#三、vue-的优点是什么？" class="headerlink" title="三、vue 的优点是什么？"></a>三、vue 的优点是什么？</h2><ul><li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的<strong>VIew</strong>上，当 View 变化的时候 Model 可以不变， 当 Model 变化的时候 View 也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li><li>独立开发。 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li>可测试。 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul><h2 id="四、vue-生命周期的理解"><a href="#四、vue-生命周期的理解" class="headerlink" title="四、vue 生命周期的理解"></a>四、vue 生命周期的理解</h2><p><strong>总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</strong></p><ul><li>创建前/后: 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。</li><li>载入前/后: 在 beforeMount 阶段，vue 实例的 \$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点， data.message 还未替换。在 mounted 阶段， vue 实例挂载完成，data.message 成功渲染。</li><li>更新前/后: 当 data 变化时，会触发 beforeUpdate 和 updated 方法。</li><li>销毁前/后: 在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。</li></ul><h2 id="五、组件之间的传值"><a href="#五、组件之间的传值" class="headerlink" title="五、组件之间的传值"></a>五、组件之间的传值</h2><ol><li>父组件与子组件传值（<strong>父组件通过标签上面定义传值</strong>）<ul><li>子组件在 props 中创建一个属性，用以接收父组件传过来的值</li><li>父组件中注册子组件</li><li>在子组件标签中添加子组件 props 中创建的属性</li><li>把需要传给子组件的值赋给该属性</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件通过标签上面定义传值</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Main :obj=<span class="string">"data"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Main</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 引入子组件</span></span><br><span class="line"><span class="regexp">  import Main form "./m</span>ain<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: "</span>parent<span class="string">",</span></span><br><span class="line"><span class="string">    data() &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        data: "</span>我要向子组件传递的数据<span class="string">"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    // 初始化组件</span></span><br><span class="line"><span class="string">    components: &#123;</span></span><br><span class="line"><span class="string">      Main</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 子组件通过 props 方法接受数据</span></span><br><span class="line"><span class="string">&lt;template&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;&#123;&#123; data &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: "</span>son<span class="string">",</span></span><br><span class="line"><span class="string">    // 接受父组件传值</span></span><br><span class="line"><span class="string">    props: ["</span>data<span class="string">"]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>子组件向父组件传递数据（<strong>子组件通过\$emit 方法传递参数</strong>）<ul><li>子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件</li><li>将需要传的值作为\$emit 的第二个参数，该值将作为实参传给响应自定义事件的方法</li><li>在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Main v-bind:message=<span class="string">"parentMessage"</span> v-on:listenToChildEvent=<span class="string">"showMsgFromChild"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Main</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 引入子组件</span></span><br><span class="line"><span class="regexp">  import Main form "./m</span>ain<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: "</span>parent<span class="string">",</span></span><br><span class="line"><span class="string">    data() &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        parentMessage: "</span>hello<span class="string">"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    methods: &#123;</span></span><br><span class="line"><span class="string">      showMsgFromChild: function(data) &#123;</span></span><br><span class="line"><span class="string">        console.log(data)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 子组件</span></span><br><span class="line"><span class="string">&lt;template&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;button v-on:click="</span>sendMsgToParent<span class="string">"&gt;向父组件传值&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: "</span>son<span class="string">",</span></span><br><span class="line"><span class="string">    props: ["</span>message<span class="string">"],</span></span><br><span class="line"><span class="string">    methods: &#123;</span></span><br><span class="line"><span class="string">      sendMsgToParent: function() &#123;</span></span><br><span class="line"><span class="string">        this.$emit("</span>listenToChildEvent<span class="string">", "</span><span class="keyword">this</span> message is <span class="keyword">from</span> child<span class="string">")</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="六、-active-class-是哪个组件的属性"><a href="#六、-active-class-是哪个组件的属性" class="headerlink" title="六、 active-class 是哪个组件的属性"></a>六、 active-class 是哪个组件的属性</h2><p>vue-router 模块的 router-link 组件。</p><h2 id="七、嵌套路由怎么定义"><a href="#七、嵌套路由怎么定义" class="headerlink" title="七、嵌套路由怎么定义"></a>七、嵌套路由怎么定义</h2><p>在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。index.html 只有一个路由出口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;!-- router-view 路由出口 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class="line">  &lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>main.js 路由的重定向，就会在页面一加载的时候，就会将 home 组件显示出来，因为重定向指向了 home 组件， redirect 的指向与 path 的必须一致。 children 里面是子路由，当然子路由里面还可以继续嵌套子路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入两个组件</span></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'./home.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> game <span class="keyword">from</span> <span class="string">'./game.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    redirect: <span class="string">'/home'</span> <span class="comment">// 重定向 指向了 home 组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/home/game'</span>,</span><br><span class="line">        component: game</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; routes &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>home.vue 点击显示就会将子路由显示出来，子路由的出口必须在父路由里面，否则子路由无法显示。</p><h2 id="八、路由之间跳转"><a href="#八、路由之间跳转" class="headerlink" title="八、路由之间跳转"></a>八、路由之间跳转</h2><ul><li>声明式（标签跳转） <code>&lt;router-link :to=&quot;index&quot;&gt;</code></li><li>编程式（js 跳转）<code>router.push(&#39;index&#39;)</code></li></ul><h2 id="九、懒加载（按需加载路由）"><a href="#九、懒加载（按需加载路由）" class="headerlink" title="九、懒加载（按需加载路由）"></a>九、懒加载（按需加载路由）</h2><p>webpack 中提供了 require.ensure() 来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。</p><ul><li>不进行页面按需加载引入方式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'../../common/home.vue'</span>;</span><br></pre></td></tr></table></figure><ul><li>进行页面按需加载的引入方式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> home = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'../../common.vue'</span>)));</span><br></pre></td></tr></table></figure><h2 id="十、vuex-是什么-怎么使用-哪种功能场景使用它"><a href="#十、vuex-是什么-怎么使用-哪种功能场景使用它" class="headerlink" title="十、vuex 是什么 怎么使用 哪种功能场景使用它"></a>十、vuex 是什么 怎么使用 哪种功能场景使用它</h2><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store， … export。<br>场景有： 单面应用中，组件之间的状态。音乐播放、登录状态、加入购物车。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 store.js</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">vue.use(vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vuex.store(&#123;</span><br><span class="line">  <span class="comment">// ...code</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="十一、vue-router-有哪几种导航钩子"><a href="#十一、vue-router-有哪几种导航钩子" class="headerlink" title="十一、vue-router 有哪几种导航钩子"></a>十一、vue-router 有哪几种导航钩子</h2><p>三种</p><ul><li><p>全局导航钩子</p><ul><li>router.beforeEach(to, from, next),</li><li>router.beforeResolve(to, from, next),</li><li>router.afterEach(to, from, next)</li></ul></li><li><p>组件内钩子</p><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate</li><li>beforeRouteLeave</li></ul></li><li><p>单独路由独享组件</p><ul><li>beforeEnter</li></ul></li></ul><h2 id="十二、自定义指令（v-check-v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数"><a href="#十二、自定义指令（v-check-v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数" class="headerlink" title="十二、自定义指令（v-check, v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数"></a>十二、自定义指令（v-check, v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数</h2><ul><li>全局定义指令： 在 vue 对象的 directive 方法里面有两个参数，一个是指令名称，另一个是函数。</li><li>组件内定义指令：directives</li><li>钩子函数：bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新)</li><li>钩子函数参数：el、binding</li></ul><h2 id="十三、说出至少-4-种-vue-当中的指令和它的用法"><a href="#十三、说出至少-4-种-vue-当中的指令和它的用法" class="headerlink" title="十三、说出至少 4 种 vue 当中的指令和它的用法"></a>十三、说出至少 4 种 vue 当中的指令和它的用法</h2><p>v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)</p><p>##</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vue-常见知识点&quot;&gt;&lt;a href=&quot;#Vue-常见知识点&quot; class=&quot;headerlink&quot; title=&quot;Vue 常见知识点&quot;&gt;&lt;/a&gt;Vue 常见知识点&lt;/h1&gt;&lt;h2 id=&quot;一、什么是-mvvm&quot;&gt;&lt;a href=&quot;#一、什么是-mvvm&quot; class=&quot;headerlink&quot; title=&quot;一、什么是 mvvm&quot;&gt;&lt;/a&gt;一、什么是 mvvm&lt;/h2&gt;&lt;p&gt;MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。 Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来， ViewModel 是一个同步 View 和 Model 的对象。&lt;/p&gt;
&lt;p&gt;在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因些 View 数据的变化会同步到 Model 中，而且 Model 数据的变化也会立即反应到 View 上。&lt;/p&gt;
&lt;p&gt;ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而且 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://daziweb.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://daziweb.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack 配置</title>
    <link href="https://daziweb.github.io/2019/03/04/webpack/webpack%E9%85%8D%E7%BD%AE/"/>
    <id>https://daziweb.github.io/2019/03/04/webpack/webpack配置/</id>
    <published>2019-03-04T02:40:11.877Z</published>
    <updated>2019-03-27T07:48:23.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack-配置学习"><a href="#webpack-配置学习" class="headerlink" title="webpack 配置学习"></a>webpack 配置学习</h1><h2 id="一-入口-entry"><a href="#一-入口-entry" class="headerlink" title="一. 入口[entry]"></a>一. 入口[entry]</h2><ol><li>介绍<ul><li>指示 webpack 应该使用哪个模块，来作为构建内部<em>依赖图</em>的开始</li><li>每个依赖项都被处理，最后输出到 <em>bundles</em> 文件中</li><li>入口可指定一个或多个，默认值为 <code>./src</code></li></ul></li><li>配置<ul><li>单个入口</li><li>多个入口<a id="more"></a></li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二-出口-output"><a href="#二-出口-output" class="headerlink" title="二. 出口[output]"></a>二. 出口[output]</h2><ol><li>介绍<ul><li>告诉 wepback 在哪里输出所创建的 <em>bundles</em> ，以及如何命名这些文件，默认值为 <code>./dist</code></li><li>整个应用程序结构，都会被编译到所指定的输出路径的文件夹中</li><li><code>output.filename</code> 属性配置输出文件名，<code>output.path</code> 属性配置输出文件路径</li></ul></li><li>配置<ul><li>单个入口对应出口配置</li><li>多个入口对应出口配置（可配置 hash，避免缓存；publicPath 可配置静态资源 CDN 或者服务器访问地址，也可不配置）</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/assets'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    publicPath: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure><h2 id="三-loader"><a href="#三-loader" class="headerlink" title="三. loader"></a>三. loader</h2><ol><li>介绍<ul><li><code>loader</code> 让 webpack 能够去处理那些非 javascript 文件</li><li>定义在 <code>module.rules</code> 中</li><li><code>test</code> 属性，设置应该被对应的 loader 进行转换的某个或某些文件</li><li><code>use</code> 属性，设置对应的 loader</li></ul></li></ol><h2 id="四-插件-plugins"><a href="#四-插件-plugins" class="headerlink" title="四. 插件[plugins]"></a>四. 插件[plugins]</h2><ol><li>介绍<ul><li>插件功能相当强大</li><li>可解决打包优化和压缩优化等</li><li>定义在 <code>plugins</code> 中</li><li>在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例</li></ul></li></ol><h2 id="五-模式"><a href="#五-模式" class="headerlink" title="五. 模式"></a>五. 模式</h2><ol><li>介绍<ul><li><code>mode</code> 有 <code>development</code> 和 <code>production</code> 两种模式，分别用于开发环境和生产环境</li><li>可设置对应模式下的相关 webpack 配置</li></ul></li><li><p>使用</p><ul><li>webpack 配置中使用 <code>mode</code></li><li>可从 CLI 参数中传递</li></ul></li><li><p>注意</p><ul><li>development: 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>；并启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code>。</li><li>production: 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>； 并启用 <code>FlagDependencyUsagePlugin</code> , <code>FlagIncludedChunksPlugin</code> , <code>ModuleConcatenationPlugin</code> , <code>NoEmitOnErrorsPlugin</code> , <code>OccurrenceOrderPlugin</code> , <code>SideEffectsFlagPlugin</code> , <code>UglifyJsPlugin</code> 。</li><li>只设置 <code>NODE_ENV</code> ，则不会自动设置 <code>mode</code> 。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span> <span class="comment">// development production</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --mode=production</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack-配置学习&quot;&gt;&lt;a href=&quot;#webpack-配置学习&quot; class=&quot;headerlink&quot; title=&quot;webpack 配置学习&quot;&gt;&lt;/a&gt;webpack 配置学习&lt;/h1&gt;&lt;h2 id=&quot;一-入口-entry&quot;&gt;&lt;a href=&quot;#一-入口-entry&quot; class=&quot;headerlink&quot; title=&quot;一. 入口[entry]&quot;&gt;&lt;/a&gt;一. 入口[entry]&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;介绍&lt;ul&gt;
&lt;li&gt;指示 webpack 应该使用哪个模块，来作为构建内部&lt;em&gt;依赖图&lt;/em&gt;的开始&lt;/li&gt;
&lt;li&gt;每个依赖项都被处理，最后输出到 &lt;em&gt;bundles&lt;/em&gt; 文件中&lt;/li&gt;
&lt;li&gt;入口可指定一个或多个，默认值为 &lt;code&gt;./src&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置&lt;ul&gt;
&lt;li&gt;单个入口&lt;/li&gt;
&lt;li&gt;多个入口
    
    </summary>
    
      <category term="webpack" scheme="https://daziweb.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://daziweb.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
