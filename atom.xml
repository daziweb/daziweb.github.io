<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dazi-World</title>
  
  <subtitle>黄昏恬静到三更</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://daziweb.github.io/"/>
  <updated>2019-04-02T09:25:57.397Z</updated>
  <id>https://daziweb.github.io/</id>
  
  <author>
    <name>Dazi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript 基本语法</title>
    <link href="https://daziweb.github.io/2019/04/02/javascript/javascript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://daziweb.github.io/2019/04/02/javascript/javascript基本语法/</id>
    <published>2019-04-02T00:31:00.706Z</published>
    <updated>2019-04-02T09:25:57.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Javascript 程度的执行单位为行（line）,也就是一行行地执行。一般情况下，每一行就是一个语句。</p><p>语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这条语句先用 <code>var</code> 命令，声明了变量 <code>a</code>，然后将 <code>1 + 3</code> 的运算结果赋值给变量 <code>a</code>。</p><p><code>1 + 3</code> 叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，语句主要为了进行某种操作，一般情况下不需要返回值；表达式则是为了得到返回值，一定会返回一个值。凡是 Javascript 语句中预期为值的地方，都可以使用表达式。比如，赋值语句的选号右边，预期是一个值，因此可以放置各种表达式。</p><a id="more"></a><p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 + 3; var b = &apos;abc&apos;;</span><br></pre></td></tr></table></figure><p>分号前面可以没有任何内容，Javascript 引擎将其视为空语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;;;</span><br></pre></td></tr></table></figure><p>上面的代码就表示 3 个空语句。</p><p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 javascript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span>;</span><br><span class="line">(<span class="string">'abc'</span>);</span><br></pre></td></tr></table></figure><p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>变量是对 <strong>值</strong> 的具名引用。变量就是为 <strong>值</strong> 起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面的代码先声明变量 <code>a</code>，然后在变量 <code>a</code> 与数值 1 之间建立引用关系，称为将数值 1 <strong>赋值</strong> 给变量 <code>a</code>。以后，引用变量名 <code>a</code> 就会得到数值 1。最前面的 <code>var</code>，是变量声明命令。它表示通知解释引擎，要创建一个变量 <code>a</code>。</p><p><strong>注意，javascript 的变量名区分大小写， <code>A</code> 和 <code>a</code> 是两个不同的变量。</strong></p><p>变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如果只是声明变量而没有赋值，则该变量的值是 <code>undefined</code>。<code>undefined</code> 是一个特殊的值，表示<strong>无定义</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果变量赋值的时候，忘了写 <code>var</code> 命令，这条语句也是有效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 基本等同</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>但是，不写 <code>var</code> 的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用 <code>var</code> 命令表明变量。</p><p>如果一个变量没有声明就直接使用， javascirpt 会报错，告诉你变量未定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a;</span><br><span class="line"><span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>上面的代码直接使用变量 <code>a</code>，系统就报错，告诉你变量 <code>a</code> 没有声明。</p><p>可以在同一条 <code>var</code> 命令中声明多个变量,变量之间用逗号隔开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br></pre></td></tr></table></figure><p>Javascript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">'hello'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>a</code> 开始被赋值为一个数值，后面又被重新赋值为一个字符串。第二次赋值的时候，因为变量 <code>a</code> 已经存在，所以不需要使用 <code>var</code> 命令。</p><p>如果使用 <code>var</code> 重新声明一个已经存在的变量，是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>x</code> 声明了两次，第二次声明是无效的。</p><p>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>Javascript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升(hoistin)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面代码首先使用 <code>console.log</code> 方法，在控制台(console)显示变量 <code>a</code> 的值。这时变量 <code>a</code> 还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>最后显示的结果是显示 <code>undefined</code>，表示变量 <code>a</code> 已声明，但还未赋值。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符(identifier)指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。Javascript 语言的标识符对大小写敏感，所以 <code>a</code> 和 <code>A</code> 是两个不同的标识符。</p><p>标识符有一套命名规则，不符合规则的就是非法标识符。Javascript 引擎遇到非法标识符，就会报错。</p><p>简单说，标识符命名规则如下。</p><ul><li><p>第一个字符，可以是任意 Unicode 字母(包括英文字母和其他语言的字母)，以及美元符号(<code>$</code>)和下划线(<code>_</code>)。</p></li><li><p>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字 <code>0-9</code>。</p></li></ul><p>下面这些都是合法的标识符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg0</span><br><span class="line">_tmp</span><br><span class="line">$elem</span><br><span class="line">π</span><br></pre></td></tr></table></figure><p>下面这些则是不合法的标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>a <span class="comment">// 第一个字符不能是数字</span></span><br><span class="line"><span class="number">23</span> <span class="comment">// 同上</span></span><br><span class="line">*** <span class="comment">// 标识符不能包含星号</span></span><br><span class="line">a+b <span class="comment">// 标识符不能包含加号</span></span><br><span class="line">-d <span class="comment">// 标识符不能包含减号或者连词线</span></span><br></pre></td></tr></table></figure><p>中文是合法的标识符，可以用作变量名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 临时变量 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Javascript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>源码中被 Javascript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用 <code>//</code> 起头；另一种是多行注释，放在 <code>/*</code> 和 <code>*/</code> 之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是</span></span><br><span class="line"><span class="comment">  多行</span></span><br><span class="line"><span class="comment">  注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>此外，由于历史上 Javascript 可以兼容 HTML 代码的注释，所以 <code>&lt;!--</code> 和 <code>--&gt;</code> 也被视为合法的单行注释。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>; &lt;!-- x = 2;</span><br><span class="line">--&gt; x = 3;</span><br></pre></td></tr></table></figure><p>上面代码中，只有 <code>x = 1</code> 会执行，其他的部分都被注释掉了。</p><p>需要注意的是， <code>--&gt;</code> 只有在行首，才会被当成单行注释，否则会当作正常的运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function countdown(n) &#123;</span><br><span class="line">  while (n --&gt; 0) console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">countdown(3);</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><p>上面代码中，<code>n --&gt; 0</code> 实际上会当作 <code>n-- &gt; 0</code>，因此输出 2、1、0。</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Javascript 使用大括号，将多个相关的语句组合在一起，称为<strong>区块</strong>(block)。</p><p>对于 <code>var</code> 命令来说，Javascript 的区块不构成单独的作用域(scope)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码在区块内部，使用 <code>var</code> 命令声明并赋值了变量 <code>a</code>，然后在区块外部，变量 <code>a</code> 依然有效，区块对于 <code>var</code> 命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 Javascript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如 <code>for</code> 、<code>if</code> 、<code>while</code> 、<code>function</code> 等。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Javascript 提供 <code>if</code> 结构和 <code>switch</code> 结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</p><h3 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a><code>if</code> 结构</h3><p><code>if</code> 结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指是 Javascript 的两个特殊值，<code>true</code> 表示<strong>真</strong>，<code>false</code> 表示<strong>伪</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值) 语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (布尔值) 语句;</span><br></pre></td></tr></table></figure><p>上面是 <code>if</code> 结构的基本形式。需要注意的是，<strong>布尔值</strong>往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为 <code>true</code>，就执行紧跟在后面的语句；如果结果为 <code>false</code>，则跳过紧跟在后面的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) m = m + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面代码表示，只有在 <code>m</code> 等于 3 时，才会将其值加上 1。</p><p>这种写法要求条件表达式只能有一个语句。如果想执行多个语句，必须在 <code>if</code> 的条件判断之后，加上大括号，表示代码块(多个语句合并成一个语句)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) &#123;</span><br><span class="line">  m += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议总是在 <code>if</code> 语句中使用大括号，因为这样方便插入语句。</strong></p><p><strong>注意，<code>if</code> 后面的表达式之中，不要混淆赋值表达式( <code>=</code> )、严格相等运算符( <code>===</code> )和相等运算符( <code>==</code> )。尤其是赋值表达式不具有比较作用。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ((x = y)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "2"</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是，当 <code>x</code> 等于 <code>y</code> 的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将 <code>y</code> 赋值给变量 <code>x</code>，再判断变量 <code>x</code> 的值(等于 2)的布尔值(结果为 <code>true</code>)。</p><p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将运算符写成赋值运算符，就会报错，因为常量不能被赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = <span class="number">2</span>) &#123; <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> = x) &#123; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="if-else-结构"><a href="#if-else-结构" class="headerlink" title="if...else 结构"></a><code>if...else</code> 结构</h3><p><code>if</code> 代码块后面，还可以跟一个 <code>else</code> 代码块，表示不满足条件时，所要执行的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">3</span> === m) &#123;</span><br><span class="line">  <span class="comment">// 满足条件时 执行的语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不满足条件时 执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码判断变量 <code>m</code> 是否等于 3，如果等于就执行 <code>if</code> 代码块，否则执行 <code>else</code> 代码块。</p><p>对同一个变量进行多次判断时，多个 <code>if...else</code> 语句可以连写在一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span> === m) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> === m) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> === m) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>else</code> 代码块总是与离自己最近的那个 <code>if</code> 语句配对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> !== m)</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> === n) <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br></pre></td></tr></table></figure><p>上面代码不会有任何输出，<code>else</code> 代码块不会得到执行，因为它跟着的是最近的那个 <code>if</code> 语句，相当于下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> !== m) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> === n) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让 <code>else</code> 代码块跟随最上面的那个 <code>if</code> 语句，就要改变大括号的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> !== m) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">2</span> === n) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a><code>switch</code> 结构</h3><p>多个 <code>if...else</code> 连在一起使用的时候，可以转为使用更方便的 <code>switch</code> 结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'banana'</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'apple'</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码根据变量 <code>fruit</code> 的值，选择执行相应的 <code>case</code>。如果所有 <code>case</code>都不符合，则执行最后的 <code>default</code> 部分。需要注意的是，每个 <code>case</code> 代码块内部的 <code>break</code> 语句不能少，否则会接下去执行下一个 <code>case</code> 代码块，而不是跳出 <code>switch</code> 结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于1'</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于2'</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于其他值'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x 等于1</span></span><br><span class="line"><span class="comment">// x 等于2</span></span><br><span class="line"><span class="comment">// x 等于其他值</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>case</code> 代码块之中没有 <code>break</code> 语句，导致不会跳出 <code>switch</code> 结构，而会一直执行下去。正确的写法是像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于1'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于2'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 等于其他值'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>switch</code> 语句部分和 <code>case</code> 语句部分，都可以使用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span> + <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> + <span class="number">2</span>:</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    neverHappens();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 <code>default</code> 部分，是永远不会执行到的。</p><p>需要注意的是， <code>switch</code> 语句后面的表达式，与 <code>cae</code> 语句后面的表达式比较运行结果时，采用的是严格相等运算符( <code>===</code> )，而不是相等运算符( <code>==</code> )，这意味着比较时不会发生类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 发生类型转换'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x 没有发生类型转换'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x 没有发生类型转换</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于变量 <code>x</code> 没有发生类型转换，所以不会执行 <code>case true</code> 的情况。这表明，<code>switch</code> 语句内部采用的是<strong>严格相等运算符</strong>。</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ?:"></a>三元运算符 <code>?:</code></h3><p>Javascript 还有一个三元运算符(即该运算符需要三个运算子) <code>?:</code>，也可以用于逻辑判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(条件) ? 表达式1 : 表达式2;</span><br></pre></td></tr></table></figure><p>上面代码中，如果<strong>条件</strong>为 <code>true</code>，则返回<strong>表达式 1</strong>的值，否则返回<strong>表达式 2</strong>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> even = n % <span class="number">2</span> === <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，如果 <code>n</code> 可以被 2 整除，则 <code>even</code> 等于 <code>true</code>，否则等于 <code>false</code>。它等同于下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> even;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">  even = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  even = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个三元运算符可以被视为 <code>if...else...</code> 的简写形式，因些可以用于多种场合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar;</span><br><span class="line"><span class="built_in">console</span>.log(myVar ? <span class="string">'myVar has a value'</span> : <span class="string">'myVar does not have a value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// myVar does not have a value</span></span><br></pre></td></tr></table></figure><p>上面代码利用三元运算符，输出相应的提示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'数字'</span> + n + <span class="string">'是'</span> + (n % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'偶数'</span> : <span class="string">'奇数'</span>);</span><br></pre></td></tr></table></figure><p>上面代码利用三元运算符，在字符串之中插入不同的值。</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a><code>while</code> 循环</h3><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h3><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do...while 循环"></a><code>do...while</code> 循环</h3><h3 id="break-语句和-continue-语句"><a href="#break-语句和-continue-语句" class="headerlink" title="break 语句和 continue 语句"></a><code>break</code> 语句和 <code>continue</code> 语句</h3><h3 id="标签-label"><a href="#标签-label" class="headerlink" title="标签(label)"></a>标签(label)</h3><h2 id="关于本文档的来历"><a href="#关于本文档的来历" class="headerlink" title="关于本文档的来历"></a>关于本文档的来历</h2><blockquote><p><strong>摘抄自《JavaScript 标准参考教程（alpha）》，by 阮一峰</strong></p><p><strong><em>仅供学习使用</em></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;p&gt;Javascript 程度的执行单位为行（line）,也就是一行行地执行。一般情况下，每一行就是一个语句。&lt;/p&gt;
&lt;p&gt;语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这条语句先用 &lt;code&gt;var&lt;/code&gt; 命令，声明了变量 &lt;code&gt;a&lt;/code&gt;，然后将 &lt;code&gt;1 + 3&lt;/code&gt; 的运算结果赋值给变量 &lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1 + 3&lt;/code&gt; 叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，语句主要为了进行某种操作，一般情况下不需要返回值；表达式则是为了得到返回值，一定会返回一个值。凡是 Javascript 语句中预期为值的地方，都可以使用表达式。比如，赋值语句的选号右边，预期是一个值，因此可以放置各种表达式。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://daziweb.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://daziweb.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>markdown 学习语法</title>
    <link href="https://daziweb.github.io/2019/03/27/markdown/01%20%E8%AF%AD%E6%B3%95/"/>
    <id>https://daziweb.github.io/2019/03/27/markdown/01 语法/</id>
    <published>2019-03-27T07:45:40.899Z</published>
    <updated>2019-03-27T07:48:29.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-学习语法"><a href="#markdown-学习语法" class="headerlink" title="markdown 学习语法"></a>markdown 学习语法</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h2><ul><li>加粗<br><code>要加粗的文字左右分别用两个*号包起来</code></li><li>斜体<br><code>要倾斜的文字左右分别用一个*号包起来</code></li><li>斜体加粗<br><code>要倾斜和加粗的文字左右分别用三个*号包起来</code></li><li><p>删除线<br><code>要加删除线的文字左右分别用两个~~号包起来</code><br>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h2><ul><li><p><code>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4. 分割线"></a>4. 分割线</h2><ul><li><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h2><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h2><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure></li><li><p>注：Markdown 本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用 html 语言的 a 标签代替。</p></li></ul><h2 id="7-列表"><a href="#7-列表" class="headerlink" title="7. 列表"></a>7. 列表</h2><ul><li><p>语法</p><ul><li>无序列表 <strong>用 - + * 任何一种都可以</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><ul><li>有序列表 <strong>用数字加点</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h2><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure></li></ul><h2 id="9-流程图"><a href="#9-流程图" class="headerlink" title="9. 流程图"></a>9. 流程图</h2><ul><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;```</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;markdown-学习语法&quot;&gt;&lt;a href=&quot;#markdown-学习语法&quot; class=&quot;headerlink&quot; title=&quot;markdown 学习语法&quot;&gt;&lt;/a&gt;markdown 学习语法&lt;/h1&gt;&lt;h2 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1. 标题&quot;&gt;&lt;/a&gt;1. 标题&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 这是一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 这是二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 这是三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 这是四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 这是五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 这是六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="markdown" scheme="https://daziweb.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="https://daziweb.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>从 URL 输入到页面展示</title>
    <link href="https://daziweb.github.io/2019/03/27/interview/%E4%BB%8EURL%E8%BE%93%E5%85%A5%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/"/>
    <id>https://daziweb.github.io/2019/03/27/interview/从URL输入到页面展示/</id>
    <published>2019-03-27T07:39:29.668Z</published>
    <updated>2019-03-27T07:55:43.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从-URL-输入到页面展示"><a href="#从-URL-输入到页面展示" class="headerlink" title="从 URL 输入到页面展示"></a>从 URL 输入到页面展示</h1><p>打开浏览器输入 url 的过程中，背后到底发生了哪些事情？从下面两张图来开始说。</p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16qec1mmpj20m00fijrs.jpg" alt="HTTP请求图"></p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16qetejlfj20yg0c8dgr.jpg" alt="HTTP请求详细图"></p><p>可以分为如下几个过程：</p><ul><li>DNS 解析: 将域名(domain)解析成 IP 地址</li><li>TCP 连接: TCP 三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>断开连接: TCP 四次挥手</li></ul><h2 id="一、URL-到底是啥"><a href="#一、URL-到底是啥" class="headerlink" title="一、URL 到底是啥"></a>一、URL 到底是啥</h2><p>URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上的资源。<br>结构如下:<br><strong>scheme://host.domain:port/path/filename</strong><br>scheme - 定义因特网服务类型。有 http， https，ftp，file 等，最常见的类型是 http，而 https 则是进行加密的网络传输，安全性更高。<br>host - 定义域主机(http 的默认主机是 WWW)<br>domain - 定义域名(常见有 .com .cn .net 现在还有中文域名)<br>port - 定义主机上的端口 http 默认端口 80(tcp)，https 默认端口 443(tcp,udp)<br>path - 定义服务器上的路径<br>filename - 定义文档/资源的名称</p><a id="more"></a><h2 id="二、域名解析（DNS）"><a href="#二、域名解析（DNS）" class="headerlink" title="二、域名解析（DNS）"></a>二、域名解析（DNS）</h2><p>在浏览器输入网址后，首页要经过域名解析，浏览器不能直接通过域名找到对应的服务器，需通过 IP 地址。</p><ol><li><p>IP 地址（IP Address）<br>ip 地址是指互联网协议地址，是 ip 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽设备物理地址的差异。IPv4 为一个 32 位的二进制数， IPv6 为 128 位的十六进制数</p></li><li><p>域名解析<br>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</p></li><li><p>浏览器如何通过域名去查询 URL 对应的 IP</p><ul><li>浏览器缓存: 浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存: 如果浏览器缓存中找不到需要的记录，会去操作系统中找。</li><li>路由缓存: 路由器也可缓存 DNS 记录。</li><li>ISP 的 DNS 服务器: ISP 指互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器: 递归查询。</li></ul></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16rm4k05mj20qb0ezwg3.jpg" alt="DNS查询"></p><ol start="4"><li>小结<br>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。</li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16rsgky05j20i00bwmy1.jpg" alt="小结"></p><h2 id="三、TCP-三次握手"><a href="#三、TCP-三次握手" class="headerlink" title="三、TCP 三次握手"></a>三、TCP 三次握手</h2><p>在客户端发送数据之前会发起 TCP 三次握手用以同步客户端和服务端的序列号和确认号，并交换 TCP 窗口大小信息。</p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16rur33ilj20mf0i7gma.jpg" alt="TCP三次握手"></p><ol><li><p>TCP 三次握手的过程如下:</p><ul><li><strong>客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口</strong>（第一次握手，由浏览器发起，告诉服务器我要发送请求了）</li><li><strong>服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息</strong>（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）</li><li><strong>客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”</strong>（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）</li></ul></li><li><p>为啥需要三次握手</p><ul><li>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</li></ul></li></ol><h2 id="四、发送-HTTP-请求"><a href="#四、发送-HTTP-请求" class="headerlink" title="四、发送 HTTP 请求"></a>四、发送 HTTP 请求</h2><ol><li><p>TCP 三次握手结束后，开始发送 HTTP 请求报文。</p><p>请求报文由请求行(request line)、请求头(header)、 请求体四个部分组成，如图所示:</p></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16sthv6hdj20h406rwf7.jpg" alt="HTTP请求"></p><ul><li><p>请求行包含请求方法、URL、协议版本</p><ul><li>请求方法包含: GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li><li>URL 即请求地址，由&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt;组成。</li><li>协议版本即 http 版本号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  /chapter17/user.html HTTP/1.1</span><br></pre></td></tr></table></figure></li></ul><p>以上代码中<code>POST</code>代表请求方法，<code>/chapter17/user.html</code>表示 URL，<code>HTTP/1.1</code>代表协议和协议的版本。</p></li></ul><ol start="2"><li><p>请求头包含请求的附加信息，由关键字/值对组成，每行一对，关键字和值用英文冒号分隔。</p><p>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如: Host 表示主机名，虚拟主机；Connection,HTTP/1.1 增加的，使用 keepalive，即持久连接，一个连接可以发多个请求；User-Agent,请求发出者，兼容性以及定制化需求。</p></li><li><p>请求体，可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=tom&amp;password=1234&amp;realName=tomson</span><br></pre></td></tr></table></figure><p>上面代码，承载着 name、password、realName 三个请求参数。</p></li></ol><h2 id="五、服务器处理请求并返回-HTTP-报文"><a href="#五、服务器处理请求并返回-HTTP-报文" class="headerlink" title="五、服务器处理请求并返回 HTTP 报文"></a>五、服务器处理请求并返回 HTTP 报文</h2><ol><li><p>服务器</p><p>服务器是网络环境中的高性能计算机，它侦听网络上的其他计算机(客户机)提交的服务请求，并提供相应的服务，比如网页服务、文件下载服务、邮件服务、视频服务。而客户端主要的功能是浏览网页、看视频、听音乐等等，两者截然不同。每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache 、nginx 、IIS 等。</p><p>web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理(例如 CGL 脚本，JSP 脚本，servlets，ASP 脚本，服务端 JavaScript，或者一些其它的服务器端技术等)，然后返回后台程序处理产生的结果作为响应。</p></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16z4ewah3j20oe0aaq5j.jpg" alt="服务器与客户端的区别"></p><ol start="2"><li><p>MVC 后台处理阶段</p><p>后台开发现在有很多框架，但大部分都还是按照 MVC 设计模式进行搭建的。</p><p>MVC 是一个设计模式，将应用程序分成三个核心部件: 模型（model）- 视图（view）- 控制器（controller），它们各自处理自己的任务，实现输入、处理和输出的分离。</p></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16z864tr1j20el0f3750.jpg" alt="MVC设计模式"></p><ul><li>视图（view）<br><strong>它是提供给用户的操作界面，是程序的外壳。</strong></li><li>模型（model）<br><strong>模型主要负责数据交互。</strong> 在 MVC 的三个部件中，模型拥有最多的处理任务。一个模型能为多个视图提供数据。</li><li><p>控制器（controller）<br><strong>它负责根据用户从<code>视图层</code>输入的指令，选取<code>模型层</code>中的数据，然后对其进行相应的操作，产生最终结果。</strong> 控制器属于管理者角色，从视图接收请求并决定调用哪 个模型构件去处理请求，然后再确定用哪个视图来显示模型处理返回的数据。</p><p>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口，供上面一层调用。<strong>首先浏览器发送过来的请求先经过控制器，控制器进行逻辑处理和请求分发，接着会调用模型，这一阶段模型会获取 redis db 以及 MySQL 的数据，获取数据后将渲染好的页面，响应信息会以响应报文的形式返回给客户端，最后浏览器通过渲染引擎将网页呈现在用户面前。</strong></p></li></ul><ol start="3"><li><p>http 响应报文</p><p>响应报文由响应行（response line）、响应头部（header）、响应主体三个部分组成。如下图所示：</p></li></ol><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16zk73a42j20bb080mxm.jpg" alt="响应报文"></p><ul><li>响应行包含: 协议版本、状态码<br>状态码规则如下：<br>1xx：指示信息 - 表示请求已接收，继续处理。<br>2xx：成功 - 表示请求已被成功接收、理解、接受。<br>3xx：重定向 - 要完成请求必须进行更进一步的操作。<br>4xx：客户端错误 - 请求有语法错误或请求无法实现。<br>5xx：服务器端错误 - 服务器未能实现合法的请求。</li><li>响应头部包含响应报文的附加信息，由 名/值 对组成</li><li>响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</li></ul><h2 id="六、浏览器解析渲染页面"><a href="#六、浏览器解析渲染页面" class="headerlink" title="六、浏览器解析渲染页面"></a>六、浏览器解析渲染页面</h2><p>浏览器拿到响应文本 HTML 后，接下来介绍下浏览器渲染机制</p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g16zqnnv5cj20kw076aab.jpg" alt="浏览器响应机制"></p><p>浏览器解析渲染页面分为五个步骤：</p><ul><li>根据 HTML 解析出 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面</li></ul><ol><li>根据 HTML 解析 DOM 树<ul><li>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优选遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。</li><li>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li></ul></li><li>根据 CSS 解析生成 CSS 规则树<ul><li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li><li>浏览器在 CSS 规则树生成之前不会进行渲染。</li></ul></li><li>结合 DOM 树和 CSS 规则树，生成渲染树<ul><li>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。</li><li>精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li></ul></li><li>根据渲染树计算每一个节点的信息(布局)<ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li><li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul></li><li>根据计算好的信息绘制页面<ul><li>绘制阶段，系统会遍历呈现树，并调用呈现器的<strong>paint</strong>方法，将呈现器的内容显示在屏幕上。</li><li>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。</li><li>回流：某个元素的尺寸发生了变化，则需要重新计算渲染树，重新渲染。</li></ul></li></ol><h2 id="七、断开连接"><a href="#七、断开连接" class="headerlink" title="七、断开连接"></a>七、断开连接</h2><p>当数据传送完毕，需要断开 TCP 连接，此时发起 TCP 四次挥手。</p><p><img src="https://ww1.sinaimg.cn/large/b3ad6cffly1g1706quw5ej20i40cit9m.jpg" alt="TCP四次挥手"></p><ul><li><strong>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。</strong>（第一次挥手由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧）</li><li><strong>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。</strong>(第二次挥手由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</li><li><strong>被动方向发起发送报文段，Fin、Ack、Seq 请求关闭连接。并进入 LAST_ACK 状态。</strong>(第三次挥手由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</li><li><strong>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。</strong>(第四次挥手由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也关闭吧)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从-URL-输入到页面展示&quot;&gt;&lt;a href=&quot;#从-URL-输入到页面展示&quot; class=&quot;headerlink&quot; title=&quot;从 URL 输入到页面展示&quot;&gt;&lt;/a&gt;从 URL 输入到页面展示&lt;/h1&gt;&lt;p&gt;打开浏览器输入 url 的过程中，背后到底发生了哪些事情？从下面两张图来开始说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/b3ad6cffly1g16qec1mmpj20m00fijrs.jpg&quot; alt=&quot;HTTP请求图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/b3ad6cffly1g16qetejlfj20yg0c8dgr.jpg&quot; alt=&quot;HTTP请求详细图&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以分为如下几个过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DNS 解析: 将域名(domain)解析成 IP 地址&lt;/li&gt;
&lt;li&gt;TCP 连接: TCP 三次握手&lt;/li&gt;
&lt;li&gt;发送 HTTP 请求&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回 HTTP 报文&lt;/li&gt;
&lt;li&gt;浏览器解析渲染页面&lt;/li&gt;
&lt;li&gt;断开连接: TCP 四次挥手&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一、URL-到底是啥&quot;&gt;&lt;a href=&quot;#一、URL-到底是啥&quot; class=&quot;headerlink&quot; title=&quot;一、URL 到底是啥&quot;&gt;&lt;/a&gt;一、URL 到底是啥&lt;/h2&gt;&lt;p&gt;URL(Uniform Resource Locator)，统一资源定位符，用于定位互联网上的资源。&lt;br&gt;结构如下:&lt;br&gt;&lt;strong&gt;scheme://host.domain:port/path/filename&lt;/strong&gt;&lt;br&gt;scheme - 定义因特网服务类型。有 http， https，ftp，file 等，最常见的类型是 http，而 https 则是进行加密的网络传输，安全性更高。&lt;br&gt;host - 定义域主机(http 的默认主机是 WWW)&lt;br&gt;domain - 定义域名(常见有 .com .cn .net 现在还有中文域名)&lt;br&gt;port - 定义主机上的端口 http 默认端口 80(tcp)，https 默认端口 443(tcp,udp)&lt;br&gt;path - 定义服务器上的路径&lt;br&gt;filename - 定义文档/资源的名称&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://daziweb.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://daziweb.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vue 常见知识点</title>
    <link href="https://daziweb.github.io/2019/03/27/interview/vue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://daziweb.github.io/2019/03/27/interview/vue相关知识点/</id>
    <published>2019-03-27T07:39:29.624Z</published>
    <updated>2019-03-27T07:48:34.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-常见知识点"><a href="#Vue-常见知识点" class="headerlink" title="Vue 常见知识点"></a>Vue 常见知识点</h1><h2 id="一、什么是-mvvm"><a href="#一、什么是-mvvm" class="headerlink" title="一、什么是 mvvm"></a>一、什么是 mvvm</h2><p>MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。 Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来， ViewModel 是一个同步 View 和 Model 的对象。</p><p>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因些 View 数据的变化会同步到 Model 中，而且 Model 数据的变化也会立即反应到 View 上。</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而且 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><a id="more"></a><h2 id="二、mvvm-和-mvc-区别？"><a href="#二、mvvm-和-mvc-区别？" class="headerlink" title="二、mvvm 和 mvc 区别？"></a>二、mvvm 和 mvc 区别？</h2><p>mvc 和 mvvm 其实区别不大。 都是一种设计思想。主要就是 mvc 中 Controller 演变成 mvvm 中的 ViewModel。 mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。和当 model 频繁发生变化，开发者需要主动更新到 View。</p><h2 id="三、vue-的优点是什么？"><a href="#三、vue-的优点是什么？" class="headerlink" title="三、vue 的优点是什么？"></a>三、vue 的优点是什么？</h2><ul><li>低耦合。视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的<strong>VIew</strong>上，当 View 变化的时候 Model 可以不变， 当 Model 变化的时候 View 也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑。</li><li>独立开发。 开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li>可测试。 界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul><h2 id="四、vue-生命周期的理解"><a href="#四、vue-生命周期的理解" class="headerlink" title="四、vue 生命周期的理解"></a>四、vue 生命周期的理解</h2><p><strong>总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</strong></p><ul><li>创建前/后: 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。</li><li>载入前/后: 在 beforeMount 阶段，vue 实例的 \$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点， data.message 还未替换。在 mounted 阶段， vue 实例挂载完成，data.message 成功渲染。</li><li>更新前/后: 当 data 变化时，会触发 beforeUpdate 和 updated 方法。</li><li>销毁前/后: 在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。</li></ul><h2 id="五、组件之间的传值"><a href="#五、组件之间的传值" class="headerlink" title="五、组件之间的传值"></a>五、组件之间的传值</h2><ol><li>父组件与子组件传值（<strong>父组件通过标签上面定义传值</strong>）<ul><li>子组件在 props 中创建一个属性，用以接收父组件传过来的值</li><li>父组件中注册子组件</li><li>在子组件标签中添加子组件 props 中创建的属性</li><li>把需要传给子组件的值赋给该属性</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件通过标签上面定义传值</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Main :obj=<span class="string">"data"</span>&gt;&lt;/Main&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 引入子组件</span></span><br><span class="line"><span class="regexp">  import Main form "./m</span>ain<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: "</span>parent<span class="string">",</span></span><br><span class="line"><span class="string">    data() &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        data: "</span>我要向子组件传递的数据<span class="string">"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    // 初始化组件</span></span><br><span class="line"><span class="string">    components: &#123;</span></span><br><span class="line"><span class="string">      Main</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 子组件通过 props 方法接受数据</span></span><br><span class="line"><span class="string">&lt;template&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;&#123;&#123; data &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: "</span>son<span class="string">",</span></span><br><span class="line"><span class="string">    // 接受父组件传值</span></span><br><span class="line"><span class="string">    props: ["</span>data<span class="string">"]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>子组件向父组件传递数据（<strong>子组件通过\$emit 方法传递参数</strong>）<ul><li>子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件</li><li>将需要传的值作为\$emit 的第二个参数，该值将作为实参传给响应自定义事件的方法</li><li>在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Main v-bind:message=<span class="string">"parentMessage"</span> v-on:listenToChildEvent=<span class="string">"showMsgFromChild"</span>&gt;&lt;/Main&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 引入子组件</span></span><br><span class="line"><span class="regexp">  import Main form "./m</span>ain<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: "</span>parent<span class="string">",</span></span><br><span class="line"><span class="string">    data() &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        parentMessage: "</span>hello<span class="string">"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    methods: &#123;</span></span><br><span class="line"><span class="string">      showMsgFromChild: function(data) &#123;</span></span><br><span class="line"><span class="string">        console.log(data)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 子组件</span></span><br><span class="line"><span class="string">&lt;template&gt;</span></span><br><span class="line"><span class="string">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;button v-on:click="</span>sendMsgToParent<span class="string">"&gt;向父组件传值&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: "</span>son<span class="string">",</span></span><br><span class="line"><span class="string">    props: ["</span>message<span class="string">"],</span></span><br><span class="line"><span class="string">    methods: &#123;</span></span><br><span class="line"><span class="string">      sendMsgToParent: function() &#123;</span></span><br><span class="line"><span class="string">        this.$emit("</span>listenToChildEvent<span class="string">", "</span><span class="keyword">this</span> message is <span class="keyword">from</span> child<span class="string">")</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="六、-active-class-是哪个组件的属性"><a href="#六、-active-class-是哪个组件的属性" class="headerlink" title="六、 active-class 是哪个组件的属性"></a>六、 active-class 是哪个组件的属性</h2><p>vue-router 模块的 router-link 组件。</p><h2 id="七、嵌套路由怎么定义"><a href="#七、嵌套路由怎么定义" class="headerlink" title="七、嵌套路由怎么定义"></a>七、嵌套路由怎么定义</h2><p>在实际项目中我们会碰到多层嵌套的组件组合而成，但是我们如何实现嵌套路由呢？因此我们需要在 VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。index.html 只有一个路由出口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;!-- router-view 路由出口 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>main.js 路由的重定向，就会在页面一加载的时候，就会将 home 组件显示出来，因为重定向指向了 home 组件， redirect 的指向与 path 的必须一致。 children 里面是子路由，当然子路由里面还可以继续嵌套子路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入两个组件</span></span><br><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'./home.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> game <span class="keyword">from</span> <span class="string">'./game.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义路由</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    redirect: <span class="string">'/home'</span> <span class="comment">// 重定向 指向了 home 组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/home/game'</span>,</span><br><span class="line">        component: game</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; routes &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>home.vue 点击显示就会将子路由显示出来，子路由的出口必须在父路由里面，否则子路由无法显示。</p><h2 id="八、路由之间跳转"><a href="#八、路由之间跳转" class="headerlink" title="八、路由之间跳转"></a>八、路由之间跳转</h2><ul><li>声明式（标签跳转） <code>&lt;router-link :to=&quot;index&quot;&gt;</code></li><li>编程式（js 跳转）<code>router.push(&#39;index&#39;)</code></li></ul><h2 id="九、懒加载（按需加载路由）"><a href="#九、懒加载（按需加载路由）" class="headerlink" title="九、懒加载（按需加载路由）"></a>九、懒加载（按需加载路由）</h2><p>webpack 中提供了 require.ensure() 来实现按需加载。以前引入路由是通过 import 这样的方式引入，改为 const 定义的方式进行引入。</p><ul><li>不进行页面按需加载引入方式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'../../common/home.vue'</span>;</span><br></pre></td></tr></table></figure><ul><li>进行页面按需加载的引入方式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> home = <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'../../common.vue'</span>)));</span><br></pre></td></tr></table></figure><h2 id="十、vuex-是什么-怎么使用-哪种功能场景使用它"><a href="#十、vuex-是什么-怎么使用-哪种功能场景使用它" class="headerlink" title="十、vuex 是什么 怎么使用 哪种功能场景使用它"></a>十、vuex 是什么 怎么使用 哪种功能场景使用它</h2><p>vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store， … export。<br>场景有： 单面应用中，组件之间的状态。音乐播放、登录状态、加入购物车。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 store.js</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">vue.use(vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vuex.store(&#123;</span><br><span class="line">  <span class="comment">// ...code</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="十一、vue-router-有哪几种导航钩子"><a href="#十一、vue-router-有哪几种导航钩子" class="headerlink" title="十一、vue-router 有哪几种导航钩子"></a>十一、vue-router 有哪几种导航钩子</h2><p>三种</p><ul><li><p>全局导航钩子</p><ul><li>router.beforeEach(to, from, next),</li><li>router.beforeResolve(to, from, next),</li><li>router.afterEach(to, from, next)</li></ul></li><li><p>组件内钩子</p><ul><li>beforeRouteEnter</li><li>beforeRouteUpdate</li><li>beforeRouteLeave</li></ul></li><li><p>单独路由独享组件</p><ul><li>beforeEnter</li></ul></li></ul><h2 id="十二、自定义指令（v-check-v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数"><a href="#十二、自定义指令（v-check-v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数" class="headerlink" title="十二、自定义指令（v-check, v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数"></a>十二、自定义指令（v-check, v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数</h2><ul><li>全局定义指令： 在 vue 对象的 directive 方法里面有两个参数，一个是指令名称，另一个是函数。</li><li>组件内定义指令：directives</li><li>钩子函数：bind(绑定事件出发)、inserted(节点插入时候触发)、update(组件内相关更新)</li><li>钩子函数参数：el、binding</li></ul><h2 id="十三、说出至少-4-种-vue-当中的指令和它的用法"><a href="#十三、说出至少-4-种-vue-当中的指令和它的用法" class="headerlink" title="十三、说出至少 4 种 vue 当中的指令和它的用法"></a>十三、说出至少 4 种 vue 当中的指令和它的用法</h2><p>v-if(判断是否隐藏)、v-for(把数据遍历出来)、v-bind(绑定属性)、v-model(实现双向绑定)</p><p>##</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vue-常见知识点&quot;&gt;&lt;a href=&quot;#Vue-常见知识点&quot; class=&quot;headerlink&quot; title=&quot;Vue 常见知识点&quot;&gt;&lt;/a&gt;Vue 常见知识点&lt;/h1&gt;&lt;h2 id=&quot;一、什么是-mvvm&quot;&gt;&lt;a href=&quot;#一、什么是-mvvm&quot; class=&quot;headerlink&quot; title=&quot;一、什么是 mvvm&quot;&gt;&lt;/a&gt;一、什么是 mvvm&lt;/h2&gt;&lt;p&gt;MVVM 是 Model-View-ViewModel 的缩写。mvvm 是一种设计思想。 Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来， ViewModel 是一个同步 View 和 Model 的对象。&lt;/p&gt;
&lt;p&gt;在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因些 View 数据的变化会同步到 Model 中，而且 Model 数据的变化也会立即反应到 View 上。&lt;/p&gt;
&lt;p&gt;ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而且 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://daziweb.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://daziweb.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack 配置</title>
    <link href="https://daziweb.github.io/2019/03/04/webpack/webpack%E9%85%8D%E7%BD%AE/"/>
    <id>https://daziweb.github.io/2019/03/04/webpack/webpack配置/</id>
    <published>2019-03-04T02:40:11.877Z</published>
    <updated>2019-03-27T07:48:23.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack-配置学习"><a href="#webpack-配置学习" class="headerlink" title="webpack 配置学习"></a>webpack 配置学习</h1><h2 id="一-入口-entry"><a href="#一-入口-entry" class="headerlink" title="一. 入口[entry]"></a>一. 入口[entry]</h2><ol><li>介绍<ul><li>指示 webpack 应该使用哪个模块，来作为构建内部<em>依赖图</em>的开始</li><li>每个依赖项都被处理，最后输出到 <em>bundles</em> 文件中</li><li>入口可指定一个或多个，默认值为 <code>./src</code></li></ul></li><li>配置<ul><li>单个入口</li><li>多个入口<a id="more"></a></li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二-出口-output"><a href="#二-出口-output" class="headerlink" title="二. 出口[output]"></a>二. 出口[output]</h2><ol><li>介绍<ul><li>告诉 wepback 在哪里输出所创建的 <em>bundles</em> ，以及如何命名这些文件，默认值为 <code>./dist</code></li><li>整个应用程序结构，都会被编译到所指定的输出路径的文件夹中</li><li><code>output.filename</code> 属性配置输出文件名，<code>output.path</code> 属性配置输出文件路径</li></ul></li><li>配置<ul><li>单个入口对应出口配置</li><li>多个入口对应出口配置（可配置 hash，避免缓存；publicPath 可配置静态资源 CDN 或者服务器访问地址，也可不配置）</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/assets'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    publicPath: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure><h2 id="三-loader"><a href="#三-loader" class="headerlink" title="三. loader"></a>三. loader</h2><ol><li>介绍<ul><li><code>loader</code> 让 webpack 能够去处理那些非 javascript 文件</li><li>定义在 <code>module.rules</code> 中</li><li><code>test</code> 属性，设置应该被对应的 loader 进行转换的某个或某些文件</li><li><code>use</code> 属性，设置对应的 loader</li></ul></li></ol><h2 id="四-插件-plugins"><a href="#四-插件-plugins" class="headerlink" title="四. 插件[plugins]"></a>四. 插件[plugins]</h2><ol><li>介绍<ul><li>插件功能相当强大</li><li>可解决打包优化和压缩优化等</li><li>定义在 <code>plugins</code> 中</li><li>在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例</li></ul></li></ol><h2 id="五-模式"><a href="#五-模式" class="headerlink" title="五. 模式"></a>五. 模式</h2><ol><li>介绍<ul><li><code>mode</code> 有 <code>development</code> 和 <code>production</code> 两种模式，分别用于开发环境和生产环境</li><li>可设置对应模式下的相关 webpack 配置</li></ul></li><li><p>使用</p><ul><li>webpack 配置中使用 <code>mode</code></li><li>可从 CLI 参数中传递</li></ul></li><li><p>注意</p><ul><li>development: 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>；并启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code>。</li><li>production: 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>； 并启用 <code>FlagDependencyUsagePlugin</code> , <code>FlagIncludedChunksPlugin</code> , <code>ModuleConcatenationPlugin</code> , <code>NoEmitOnErrorsPlugin</code> , <code>OccurrenceOrderPlugin</code> , <code>SideEffectsFlagPlugin</code> , <code>UglifyJsPlugin</code> 。</li><li>只设置 <code>NODE_ENV</code> ，则不会自动设置 <code>mode</code> 。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span> <span class="comment">// development production</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --mode=production</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack-配置学习&quot;&gt;&lt;a href=&quot;#webpack-配置学习&quot; class=&quot;headerlink&quot; title=&quot;webpack 配置学习&quot;&gt;&lt;/a&gt;webpack 配置学习&lt;/h1&gt;&lt;h2 id=&quot;一-入口-entry&quot;&gt;&lt;a href=&quot;#一-入口-entry&quot; class=&quot;headerlink&quot; title=&quot;一. 入口[entry]&quot;&gt;&lt;/a&gt;一. 入口[entry]&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;介绍&lt;ul&gt;
&lt;li&gt;指示 webpack 应该使用哪个模块，来作为构建内部&lt;em&gt;依赖图&lt;/em&gt;的开始&lt;/li&gt;
&lt;li&gt;每个依赖项都被处理，最后输出到 &lt;em&gt;bundles&lt;/em&gt; 文件中&lt;/li&gt;
&lt;li&gt;入口可指定一个或多个，默认值为 &lt;code&gt;./src&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置&lt;ul&gt;
&lt;li&gt;单个入口&lt;/li&gt;
&lt;li&gt;多个入口
    
    </summary>
    
      <category term="webpack" scheme="https://daziweb.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://daziweb.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
