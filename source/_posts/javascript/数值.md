---
title: Javascript 数据类型(数值)
tags:
  - javascript 数值
categories:
  - javascript
comments: true
---

## 整数和浮点数

Javascript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，`1` 与 `1.0` 是相同的，是同一个数。

```javascript
1 === 1.0;
// true
```

这就是说，Javascript 语言的底层根本没有整数，所有数字都是小数(64 位浮点数)。容易造成混淆的是，某些运算只有整数才能完成，此时 Javascript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算。

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。

```javascript
0.1 + 0.2 === 0.3;
// false

0.3 / 0.1;
// 2.9999999999999996

0.3 - 0.2 === 0.2 - 0.1;
// false
```

## 数值精度

根据国际标准 IEEE 754，Javascript 浮点数的 64 个二进制位，从最左边开始，是这样组成的。

- 第 1 位：符号位，`0` 表示正数，`1` 表示负数。
- 第 2 位到第 12 位(共 11 位)：指数部分。
- 第 13 位到第 64 位(共 52 位)：小数部分(即有效数字)。

符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。

指数部分一共有 11 个二进制位，因些大小范围就是 0 到 2047。IEEE 754 规定，如果指数部分的值在 0 到 2047 之间(不含两个端点)，那么有效数字的第一位默认总是 1，不保存在 64 位浮点数之中。也就是说，有效数字这时总是 `1.xx...xx` 的形式，其中 `xx...xx` 的部分保存在 64 位浮点数之中，最长可能为 52 位。因此，Javascript 提供的有效数字最长为 53 个二进制位。

```javascript
(-1)^符号位 * 1.xx...xx * 2^指数部分
```

上面公式是正常情况下(指数部分在 0 到 2047 之间)，一个数在 Javascript 内部实际的表示形式。

精度最多只能到 53 个二进制位，这意味着，绝对值小于 2 的 53 次方的整数，即 `-2^53` 到
`2^53`，都可以精确表示。

```javascript
Math.pow(2, 53);
// 9007199254740992

Math.pow(2, 53) + 1;
// 9007199254740992

Math.pow(2, 53) + 2;
// 9007199254740994

Math.pow(2, 53) + 3;
// 9007199254740996

Math.pow(2, 53) + 4;
// 9007199254740996
```

上面代码中，大于 2 的 53 次方以后，整数运算的结果开始出现错误。所以，大于 2 的 53 次方的数值，都无法保持精度。由于 2 的 53 次方是一个 16 位的十进制数值，所以简单的法则就是，Javascript 对 15 位的十进制数都可以精确处理。

```javascript
Math.pow(2, 53);
// 9007199254740992

// 多出的三个有效数字，将无法保存
9007199254740992111;
// 9007199254740992000
```

上面示例表明，大于 2 的 53 次方以后，多出来的有效数字(最后三位的 `111`)都会无法保存，变成 0。

## 数值范围

根据标准，64 位浮点数的指数部分的长度是 11 个二进制位，意味着指数部分的最大值是 2047(2 的 11 次方减 1)。也就是说，64 位浮点数的指数部分的值最大为 2047，分出一半表示负数，则 Javascript 能够表示的数值范围为 `2^1024` 到 `2^-1023` (开区间)，超出这个范围的数无法表示。

如果一个数大于等于 2 的 1024 次方，那么就会发生**正向溢出**，即 Javascript 无法表示这么大的数，这时就会返回 `Infinity`。

```javascript
Math.pow(2, 1024); // Infinity
```

如果一个数小于等于 2 的-1075 次方(指数部分最小值-1023，再加上小数部分的 52 位)，那么就会发生为**负向溢出**，即 Javascript 无法表示这么小的数，这时会直接返回 0。

```javascript
Math.pow(2, -1075); // 0
```

下面是一个实际的例子。

```javascript
var x = 0.5;

for (var i = 0; i < 25; i++) {
  x = x * x;
}

x; // 0
```

上面代码中，对 `0.5` 连续做 25 次平方，由于最后结果太接近 0，超出了可表示的范围，Javascript 就直接将其转为 0。

Javascriptr 提供`Number`对象的`MAX_VALUE`和`MIN_VALUE`属性，返回可以表示的具体的最大值和最小值。

```javascript
Number.MAX_VALUE; // 1.7976931348623157e+308
Number.MIN_VALUE; // 5e-324
```

## 数值的表示法

javascript 的数值有多种表示方法，可以用字面形式直接表示，比如`35`(十进制)和`0xFF`(十六进制)。

数值也可以采用科学计数法表示，下面是几个科学计数法的例子。

```javascript
123e3; // 123000
123e-3; // 0.123
-3.1e12; // -3100000000000
0.1e-23; // 1e-24
```

科学计数法允许字母`e`或`E`的后面，跟着一个整数，表示这个数值的指数部分。

以下两种情况，javascript 会自动将数值转为科学计数法表示。其他情况都采用字面形式直接表示。

（1）小数点前的数字多于 21 位。

```javascript
1234567890123456789012;
// 1.2345678901234568e+21

123456789012345678901;
// 123456789012345680000
```

（2）小数点后的零多于 5 个。

```javascript
// 小数点后紧跟5个以上的零，
// 就自动转为科学计数法
0.0000003; // 3e-7

// 否则，就保持原来的字面形式
0.000003; // 0.000003
```

## 数值的进制

使用字面量（literal）直接表示一个数值时，javascript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。

- 十进制：没有前导 0 的数值。
- 八进制：有前缀`0o`或`00`的数值，或者有前导 0、且只用到 0-7 的八个阿拉伯数字的数值。
- 十六进制：有前缀`0x`或`0X`的数值。
- 二进制：有前缀`0b`或`0B`的数值。

默认情况下，javascript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。

```javascript
0xff; // 255
0o377; // 255
0b11; // 3
```

如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。

```javascript
0xzz; // 报错
0o88; // 报错
0b22; // 报错
```

上面代码中，十六进制出现了字母`z`、八进制出现数字`8`、二进制出现数字`2`，因此报错。

通常来说，有前导 0 的数值会被视为八进制，但是如果前导 0 后面有数字`8`和`9`，则该数值被视为十进制。

```javascript
0888; // 888
0777; // 511
```

前导 0 表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。

## 关于本文档的来历

> **摘抄自《JavaScript 标准参考教程（alpha）》，by 阮一峰**
>
> **_仅供学习使用_**
