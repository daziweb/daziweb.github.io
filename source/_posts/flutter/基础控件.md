---
title: Flutter 基础控件
tags:
  - flutter
categories:
  - flutter
comments: true
---

## 基础控件

### Tabbar 控件实现

Tabbar 页面是常有需求，而在 Flutter 中：**Scaffold、AppBar、Tabbar、TabbarView** 是 Tabbar 页面的最简单实现。

<!--more-->

下面代码为一个 Tabbar Widget。

```dart
class _GSYTabBarState extends State<GSYTabBarWidget> with SingleTickerProviderStateMixin {
  // ...省略非关键代码
  @override
  void initState() {
    super.initState();
    // 初始化时创建控制器
    // 通过 with SingleTickerProviderStateMixin 实现动画效果
    _tabController = new TabController(vsync: this, length: _tabItems.length);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // 底部 Tabbar 模式
    return new Scaffold(
      // 设置侧边滑出 drawer 不需要可以不设置
      drawer: _drawer,
      // 设置悬浮按键 不需要可以不设置
      floatingActionButton: _floatingActionButton,
      // 标题栏
      appBar: new AppBar(
        backgroundColor: _backgroundColor,
        title: _title,
      ),
      // 页面主体 PageView 用于承载 Tab 对应的页面
      body: new PageView(
        // 必须有的控制器 与 tabBar 的控制器同步
        controller: _pageController,
        // 每一个 tab 对应的页面主体 是一个 List<Widget>
        children: _tabViews,
        onPageChanged: (index) {
          // 页面触摸作用滑动回调 用于同步 tab 选中状态
          _tabController.animateTo(index);
        },
      ),
      // 底部导航栏 也就是 tab 栏
      bottomNavigationBar: new Material(
        color: _backgroundColor,
        // tabbar 控件
        child: new TabBar(
          // 必须有的控制器 与 pageView 的控制器同步
          controller: _tabController,
          // 每一个 tab item 是一个 List<Widget>
          tabs: _tabItems,
          // tab 底部选中条颜色
          indicatorColor: _indicatorColor,
        ),
      ),
    );
  }
}
```

如上代码所示，这是一个 _底部 TabBar_ 的页面效果。TabBar 和 PageView 之间通过 `_pageController` 和 `_tabController` 实现 Tab 和页面的同步，通过 `SingleTickerProviderStateMixin` 实现 Tab 的动画切换效果：

- 手动左右滑动 `PageView` 时，通过 `onPageChanged` 回调使用 `_tabController.animateTo(index);` 同步 TabBar 状态。

- `_tabItems` 中，监听每个 TabBarItem 的点击，通过 `_pageController` 实现 PageView 的状态同步。

而上面代码还缺少了 TabBarItem 的点击，因为这块被放到了外部实现。当然你也可以直接在内部封装好控件，直接传递配置数据显示，这个可以根据个人需要封装。

外部调用代码如下：每个 Tabbar 点击时，通过 `pageController.jumpTo` 跳转页面，每个页面需要跳转坐标为：**当前屏幕大小乘以索引 index**。

```dart
class _TabBarBottomPageWidgetState extends State<TabBarBottomPageWidget> {
  final PageController pageController = new PageController();
  final List<String> tab = ['动态', '趋势', '我的'];

  // 渲染底部Tab
  _renderTab() {
    List<Widget> list = new List();
    for (int i = 0; i < tab.length; i++) {
      list.add(new FlatButton(onPressed: () {
        // 每个 Tabbar 点击时，通过jumpTo 跳转页面
        // 每个页面需要跳转坐标为：当前屏幕大小 * 索引index。
        topPageControl.jumpTo(MediaQuery.of(context).size.width * i);
      }, child: new Text(
        tab[i],
        maxLines: 1,
      )));
    }
    return list;
  }

  // 渲染Tab 对应页面
  _renderPage() {
    return [
      new TabBarPageFirst(),
      new TabBarPageSecond(),
      new TabBarPageThree(),
    ];
  }


  @override
  Widget build(BuildContext context) {
    // 带 Scaffold 的 Tabbar 页面
    return new GSYTabBarWidget(
      type: GSYTabBarWidget.BOTTOM_TAB,
      // 渲染tab
      tabItems: _renderTab(),
      // 渲染页面
      tabViews: _renderPage(),
      topPageControl: pageController,
      backgroundColor: Colors.black45,
      indicatorColor: Colors.white,
      title: new Text("Flutter Demo"));
  }
}
```

如果到此结束，你会发现页面点击切换时，`StatefulWidget` 的子页面每次都会重新调用 `initState`。这肯定不是我们想要的，所以这时你就需要 `AutomaticKeepAliveClientMixin`。

每个 Tab 对应的 `StatefulWidget` 的 State ，需要通过 `with AutomaticKeepAliveClientMixin`，然后重写 `@override bool get wantKeepAlive => true;`，就可以实不重新构建的效果。

既然底部 Tab 页面都实现了，干脆顶部 tab 页面也一起完成。如下代码，和底部 Tab 页的区别在于：

- 底部 tab 是放在了 `Scaffold` 的 `bottomNavigationBar` 中。
- 顶部 tab 是放在 `AppBar` 的 `bottom` 中，也就是标题栏之下。

```dart
return new Scaffold(
  // 设置侧边滑出 drawer，不需要可以不设置
  drawer: _drawer,
  // 设置悬浮按键，不需要可以不设置
  floatingActionButton: _floatingActionButton,
  // 标题栏
  appBar: new AppBar(
    backgroundColor: _backgroundColor,
    title: _title,
    // tabBar控件
    bottom: new TabBar(
      // 顶部时，tabBar为可以滑动的模式
      isScrollable: true,
      // 必须有的控制器，与pageView的控制器同步
      controller: _tabController,
      // 每一个tab item，是一个List<Widget>
      tabs: _tabItems,
      // tab底部选中条颜色
      indicatorColor: _indicatorColor,
    ),
  ),
  // 页面主体，PageView，用于承载Tab对应的页面
  body: new PageView(
    // 必须有的控制器，与tabBar的控制器同步
    controller: _pageController,
    // 每一个 tab 对应的页面主体，是一个List<Widget>
    children: _tabViews,
    // 页面触摸作用滑动回调，用于同步tab选中状态
    onPageChanged: (index) {
      _tabController.animateTo(index);
    },
  ),
);
```

在 TabBar 页面中，一般还会出现：**父页面需要控制 PageView 中子页的需求**。这时候就需要用到 `GlobalKey` 了。比如 `GlobalKey<PageOneState> stateOne = new GlobalKey<PageOneState>();`，通过 `globalKey.currentState` 对象，你就可以调用到 `PageOneState` 中的公开方法。这里需要注意 `GlobalKey` 需要全局唯一，一般可以在 `build` 方法中创建。

### 上下刷新列表

毫无争议，必备控件。Flutter 中 为我们提供了 `RefreshIndicator` 作为内置下拉刷新控件；同时我们通过给 `ListView` 添加 `ScrollController` 做滑动监听，在最后增加一个 Item， 作为上滑加载更多的 Loading 显示。

如下代码所示，通过 `RefreshIndicator` 控件可以简单完成下拉刷新工作。这里需要注意一点是：**可以利用 `GlobalKey<RefreshIndicatorState>` 对外提供 `RefreshIndicator` 的 `RefreshIndicatorState`，这样外部就 可以通过 `GlobalKey` 调用 `globalKey.currentState.show();`，主动显示刷新状态并触发 `onRefresh`** 。

上拉加载更多在代码中是通过 `_getListCount()` 方法，在原本的数据基础上，增加实际需要渲染的 item 数量给 ListView 实现的，最后通过 `ScrollController` 监听到底部，触发 `onLoadMore`。

如下代码所示，通过 `_getListCount()` 方法，还可以配置空页面，头部等常用效果。其实就是**在内部通过改变实际 item 数量与渲染 Item，以实现更多配置效果**。

```dart
class _GSYPullLoadWidgetState extends State<GSYPullLoadWidget> {
  // ···
  final ScrollController _scrollController = new ScrollController();

  @override
  void initState() {
    // 增加滑动监听
    _scrollController.addListener(() {
      // 判断当前滑动位置是不是到达底部，触发加载更多回调
      if (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) {
        if (this.onLoadMore != null && this.control.needLoadMore) {
          this.onLoadMore();
        }
      }
    });
    super.initState();
  }

  // 根据配置状态返回实际列表数量
  // 实际上这里可以根据你的需要做更多的处理
  // 比如多个头部，是否需要空页面，是否需要显示加载更多。
  _getListCount() {
    // 是否需要头部
    if (control.needHeader) {
      // 如果需要头部，用Item 0 的 Widget 作为ListView的头部
      // 列表数量大于0时，因为头部和底部加载更多选项，需要对列表数据总数+2
      return (control.dataList.length > 0) ? control.dataList.length + 2 : control.dataList.length + 1;
    } else {
      // 如果不需要头部，在没有数据时，固定返回数量1用于空页面呈现
      if (control.dataList.length == 0) {
        return 1;
      }

      // 如果有数据,因为不加载更多选项，需要对列表数据总数+1
      return (control.dataList.length > 0) ? control.dataList.length + 1 : control.dataList.length;
    }
  }

  // 根据配置状态返回实际列表渲染Item
  _getItem(int index) {
    if (!control.needHeader && index == control.dataList.length && control.dataList.length != 0) {
      // 如果不需要头部，并且数据不为0，当index等于数据长度时，渲染加载更多Item（因为index是从0开始）
      return _buildProgressIndicator();
    } else if (control.needHeader && index == _getListCount() - 1 && control.dataList.length != 0) {
      // 如果需要头部，并且数据不为0，当index等于实际渲染长度 - 1时，渲染加载更多Item（因为index是从0开始）
      return _buildProgressIndicator();
    } else if (!control.needHeader && control.dataList.length == 0) {
      // 如果不需要头部，并且数据为0，渲染空页面
      return _buildEmpty();
    } else {
      // 回调外部正常渲染Item，如果这里有需要，可以直接返回相对位置的index
      return itemBuilder(context, index);
    }
  }

  @override
  Widget build(BuildContext context) {
    return new RefreshIndicator(
      // GlobalKey，用户外部获取RefreshIndicator的State，做显示刷新
      key: refreshKey,
      // 下拉刷新触发，返回的是一个Future
      onRefresh: onRefresh,
      child: new ListView.builder(
        // 保持ListView任何情况都能滚动，解决在RefreshIndicator的兼容问题。
        physics: const AlwaysScrollableScrollPhysics(),
        // 根据状态返回子孔健
        itemBuilder: (context, index) {
          return _getItem(index);
        },
        // 根据状态返回数量
        itemCount: _getListCount(),
        // 滑动监听
        controller: _scrollController,
      ),
    );
  }

  // 空页面
  Widget _buildEmpty() {
    // ···
  }

  // 上拉加载更多
  Widget _buildProgressIndicator() {
    // ···
  }
}
```

### Loading

### 矢量图标库

### 路由跳转

## 数据模块
